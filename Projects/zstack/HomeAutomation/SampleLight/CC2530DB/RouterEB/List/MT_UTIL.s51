///////////////////////////////////////////////////////////////////////////////
//
// IAR C/C++ Compiler V10.30.1.6000 for 8051              05/May/2021  18:21:31
// Copyright 2004-2018 IAR Systems AB.
// Evaluation license - IAR Embedded Workbench for 8051, Evaluation edition 10.40
//
//    Core               =  plain
//    Code model         =  banked
//    Data model         =  large
//    Calling convention =  xdata reentrant
//    Constant location  =  data_rom
//    Dptr setup         =  1,16
//                          
//    Source file        =  
//        C:\Texas Instruments\2. main recover\Z-Stack 3.0.2\Z-Stack
//        3.0.2\Components\mt\MT_UTIL.c
//    Command line       =  
//        -f C:\users\slavko\Temp\EW342f.tmp ("C:\Texas Instruments\2. main
//        recover\Z-Stack 3.0.2\Z-Stack 3.0.2\Components\mt\MT_UTIL.c" -D
//        BDB_REPORTING -D SECURE=1 -D TC_LINKKEY_JOIN -D NV_INIT -D NV_RESTORE
//        -D xZTOOL_P1 -D xMT_TASK -D xMT_APP_FUNC -D xMT_SYS_FUNC -D
//        xMT_ZDO_FUNC -D xMT_ZDO_MGMT -D xMT_APP_CNF_FUNC -D
//        LCD_SUPPORTED=DEBUG -D MULTICAST_ENABLED=FALSE -D ZCL_READ -D
//        ZCL_DISCOVER -D ZCL_WRITE -D ZCL_BASIC -D ZCL_IDENTIFY -D ZCL_ON_OFF
//        -D ZCL_SCENES -D ZCL_GROUPS -D ZCL_LEVEL_CTRL -D HAL_LED=TRUE -D
//        HAL_KEY=TRUE -D BLINK_LEDS -lC "C:\Texas Instruments\2. main
//        recover\Z-Stack 3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\RouterEB\List"
//        -lA "C:\Texas Instruments\2. main recover\Z-Stack 3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\RouterEB\List"
//        --diag_suppress Pe001,Pa010 -o "C:\Texas Instruments\2. main
//        recover\Z-Stack 3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\RouterEB\Obj"
//        -e --debug --core=plain --dptr=16,1 --data_model=large
//        --code_model=banked --calling_convention=xdata_reentrant
//        --place_constants=data_rom --nr_virtual_regs 16 -f "C:\Texas
//        Instruments\2. main recover\Z-Stack 3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\Tools\CC2530DB\f8wRouter.cfg"
//        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRUE
//        -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8 -DMAC_CFG_RX_MAX=5
//        -DRTR_NWK) -f "C:\Texas Instruments\2. main recover\Z-Stack
//        3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg"
//        (-DZIGBEEPRO -DSECURE=1 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
//        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
//        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
//        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
//        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
//        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
//        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
//        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
//        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
//        -DMAX_BINDING_CLUSTER_IDS=4 -DDEFAULT_KEY={0}
//        -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
//        "-DCONST=const __code" -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE
//        -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100
//        -DREJOIN_POLL_RATE=440 -DREJOIN_BACKOFF=900000 -DREJOIN_SCAN=900000
//        -DENABLE_LED4_DISABLE_S1) -f "C:\Texas Instruments\2. main
//        recover\Z-Stack 3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\Tools\CC2530DB\f8wZCL.cfg"
//        -I "C:\Texas Instruments\2. main recover\Z-Stack 3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\" -I
//        "C:\Texas Instruments\2. main recover\Z-Stack 3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\Source\"
//        -I "C:\Texas Instruments\2. main recover\Z-Stack 3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\Source\"
//        -I "C:\Texas Instruments\2. main recover\Z-Stack 3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\ZMain\TI2530DB\"
//        -I "C:\Texas Instruments\2. main recover\Z-Stack 3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\hal\include\"
//        -I "C:\Texas Instruments\2. main recover\Z-Stack 3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\"
//        -I "C:\Texas Instruments\2. main recover\Z-Stack 3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\mac\include\"
//        -I "C:\Texas Instruments\2. main recover\Z-Stack 3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\mac\high_level\"
//        -I "C:\Texas Instruments\2. main recover\Z-Stack 3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\"
//        -I "C:\Texas Instruments\2. main recover\Z-Stack 3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\single_chip\"
//        -I "C:\Texas Instruments\2. main recover\Z-Stack 3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\mt\"
//        -I "C:\Texas Instruments\2. main recover\Z-Stack 3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\osal\include\"
//        -I "C:\Texas Instruments\2. main recover\Z-Stack 3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\services\saddr\"
//        -I "C:\Texas Instruments\2. main recover\Z-Stack 3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\services\sdata\"
//        -I "C:\Texas Instruments\2. main recover\Z-Stack 3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\af\"
//        -I "C:\Texas Instruments\2. main recover\Z-Stack 3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\bdb\"
//        -I "C:\Texas Instruments\2. main recover\Z-Stack 3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\nwk\"
//        -I "C:\Texas Instruments\2. main recover\Z-Stack 3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\bdb\"
//        -I "C:\Texas Instruments\2. main recover\Z-Stack 3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\gp\"
//        -I "C:\Texas Instruments\2. main recover\Z-Stack 3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\sapi\"
//        -I "C:\Texas Instruments\2. main recover\Z-Stack 3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\sec\"
//        -I "C:\Texas Instruments\2. main recover\Z-Stack 3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\sys\"
//        -I "C:\Texas Instruments\2. main recover\Z-Stack 3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\zcl\"
//        -I "C:\Texas Instruments\2. main recover\Z-Stack 3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\zdo\"
//        -I "C:\Texas Instruments\2. main recover\Z-Stack 3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\zmac\"
//        -I "C:\Texas Instruments\2. main recover\Z-Stack 3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\zmac\f8w\"
//        -Ohz --require_prototypes)
//    Locale             =  English_USA.1252
//    List file          =  
//        C:\Texas Instruments\2. main recover\Z-Stack 3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\RouterEB\List\MT_UTIL.s51
//
///////////////////////////////////////////////////////////////////////////////

        NAME MT_UTIL

        RTMODEL "__SystemLibrary", "CLib"
        RTMODEL "__calling_convention", "xdata_reentrant"
        RTMODEL "__code_model", "banked"
        RTMODEL "__core", "plain"
        RTMODEL "__data_model", "large"
        RTMODEL "__dptr_size", "16"
        RTMODEL "__extended_stack", "disabled"
        RTMODEL "__location_for_constants", "data"
        RTMODEL "__number_of_dptrs", "1"
        RTMODEL "__register_banks", "*"
        RTMODEL "__rt_version", "1"

        RSEG DOVERLAY:DATA:NOROOT(0)
        RSEG IOVERLAY:IDATA:NOROOT(0)
        RSEG ISTACK:IDATA:NOROOT(0)
        RSEG PSTACK:XDATA:NOROOT(0)
        RSEG XSTACK:XDATA:NOROOT(0)


        END
// C:\Texas Instruments\2. main recover\Z-Stack 3.0.2\Z-Stack 3.0.2\Components\mt\MT_UTIL.c
//    1 /***************************************************************************************************
//    2   Filename:       MT_UTIL.c
//    3   Revised:        $Date: 2015-01-26 08:25:50 -0800 (Mon, 26 Jan 2015) $
//    4   Revision:       $Revision: 42025 $
//    5 
//    6   Description:    MonitorTest Utility Functions
//    7 
//    8   Copyright 2007-2015 Texas Instruments Incorporated. All rights reserved.
//    9 
//   10   IMPORTANT: Your use of this Software is limited to those specific rights
//   11   granted under the terms of a software license agreement between the user
//   12   who downloaded the software, his/her employer (which must be your employer)
//   13   and Texas Instruments Incorporated (the "License"). You may not use this
//   14   Software unless you agree to abide by the terms of the License. The License
//   15   limits your use, and you acknowledge, that the Software may not be modified,
//   16   copied or distributed unless embedded on a Texas Instruments microcontroller
//   17   or used solely and exclusively in conjunction with a Texas Instruments radio
//   18   frequency transceiver, which is integrated into your product. Other than for
//   19   the foregoing purpose, you may not use, reproduce, copy, prepare derivative
//   20   works of, modify, distribute, perform, display or sell this Software and/or
//   21   its documentation for any purpose.
//   22 
//   23   YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
//   24   PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
//   25   INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
//   26   NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
//   27   TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
//   28   NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
//   29   LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
//   30   INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
//   31   OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
//   32   OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
//   33   (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
//   34 
//   35   Should you have any questions regarding your right to use this Software,
//   36   contact Texas Instruments Incorporated at www.TI.com.
//   37 
//   38  ***************************************************************************************************/
//   39 
//   40 /***************************************************************************************************
//   41  * INCLUDES
//   42  ***************************************************************************************************/
//   43 #include "ZComDef.h"
//   44 
//   45 #include "AddrMgr.h"
//   46 
//   47 #include "OnBoard.h"   /* This is here because of the key reading */
//   48 #include "hal_key.h"
//   49 #include "hal_led.h"
//   50 #include "OSAL_Nv.h"
//   51 #include "osal.h"
//   52 #include "NLMEDE.h"
//   53 #include "MT.h"
//   54 #include "MT_UTIL.h"
//   55 #include "MT_MAC.h"
//   56 #include "ssp.h"
//   57 #if defined ZCL_KEY_ESTABLISH
//   58 #include "zcl_key_establish.h"
//   59 #include "zcl_se.h"
//   60 #endif
//   61 
//   62 #if !defined NONWK
//   63 #include "MT_ZDO.h"
//   64 #include "MT_SAPI.h"
//   65 #include "MT_NWK.h"
//   66 #include "MT_AF.h"
//   67 #include "AssocList.h"
//   68 #include "ZDApp.h"
//   69 #include "ZDSecMgr.h"
//   70 #endif
//   71 
//   72 #if defined MT_SRNG
//   73 #include "hal_srng.h"
//   74 #endif
//   75 
//   76 #if defined FEATURE_DUAL_MAC
//   77 #include "dmmgr.h"
//   78 #endif
//   79 
//   80 /***************************************************************************************************
//   81  * CONSTANTS
//   82  ***************************************************************************************************/
//   83 #define MT_UTIL_DEVICE_INFO_RESPONSE_LEN 14
//   84 #define MT_UTIL_STATUS_LEN    1
//   85 #define MT_UTIL_FRM_CTR_LEN   4
//   86 // Status + LinkKeyDataLen + Tx+Rx Frame counter.
//   87 #define MT_APSME_LINKKEY_GET_RSP_LEN (MT_UTIL_STATUS_LEN + SEC_KEY_LEN + (MT_UTIL_FRM_CTR_LEN * 2))
//   88 // Status + NV id
//   89 #define MT_APSME_LINKKEY_NV_ID_GET_RSP_LEN (MT_UTIL_STATUS_LEN + 2)
//   90 
//   91 /***************************************************************************************************
//   92  * LOCAL VARIABLES
//   93  ***************************************************************************************************/
//   94 #if defined ZCL_KEY_ESTABLISH
//   95 uint8 zcl_key_establish_task_id;
//   96 #endif
//   97 
//   98 #ifdef FEATURE_GET_PRIMARY_IEEE
//   99 /* This feature is not compatible with MSP430 or ARM platforms. */
//  100 __no_init const __xdata char ieeeMac[1] @ 0x780C;
//  101 #endif
//  102 
//  103 /***************************************************************************************************
//  104  * LOCAL FUNCTIONS
//  105  ***************************************************************************************************/
//  106 #ifdef AUTO_PEND
//  107 static void MT_UtilRevExtCpy( uint8 *pDst, uint8 *pSrc );
//  108 static void MT_UtilSpi2Addr( zAddrType_t *pDst, uint8 *pSrc );
//  109 #endif
//  110 
//  111 #if defined (MT_UTIL_FUNC)
//  112 static void MT_UtilGetDeviceInfo(void);
//  113 static void MT_UtilGetNvInfo(void);
//  114 static void MT_UtilSetPanID(uint8 *pBuf);
//  115 static void MT_UtilSetChannels(uint8 *pBuf);
//  116 static void MT_UtilSetSecLevel(uint8 *pBuf);
//  117 static void MT_UtilSetPreCfgKey(uint8 *pBuf);
//  118 static void MT_UtilCallbackSub(uint8 *pData);
//  119 static void MT_UtilTimeAlive(void);
//  120 static void MT_UtilSrcMatchEnable (uint8 *pBuf);
//  121 static void MT_UtilSrcMatchAddEntry (uint8 *pBuf);
//  122 static void MT_UtilSrcMatchDeleteEntry (uint8 *pBuf);
//  123 static void MT_UtilSrcMatchCheckSrcAddr (uint8 *pBuf);
//  124 static void MT_UtilSrcMatchAckAllPending (uint8 *pBuf);
//  125 static void MT_UtilSrcMatchCheckAllPending (uint8 *pBuf);
//  126 
//  127 static void MT_UtilGpioSetDirection(uint8 *pBuf);
//  128 static void MT_UtilGpioRead(uint8 *pBuf);
//  129 static void MT_UtilGpioWrite(uint8 *pBuf);
//  130 
//  131 #if (defined HAL_KEY) && (HAL_KEY == TRUE)
//  132 static void MT_UtilKeyEvent(uint8 *pBuf);
//  133 #endif
//  134 
//  135 #if (defined HAL_LED) && (HAL_LED == TRUE)
//  136 static void MT_UtilLedControl(uint8 *pBuf);
//  137 #endif
//  138 
//  139 #ifdef MT_SRNG
//  140 static void MT_UtilSrngGen(void);
//  141 #endif
//  142 
//  143 #ifdef FEATURE_GET_PRIMARY_IEEE
//  144 static void MT_UtilGetPrimaryIEEE(void);
//  145 #endif
//  146 
//  147 #if !defined NONWK
//  148 static void MT_UtilDataReq(uint8 *pBuf);
//  149 static void MT_UtilAddrMgrEntryLookupExt(uint8 *pBuf);
//  150 static void MT_UtilAddrMgrEntryLookupNwk(uint8 *pBuf);
//  151 #if defined MT_SYS_KEY_MANAGEMENT
//  152 static void MT_UtilAPSME_LinkKeyDataGet(uint8 *pBuf);
//  153 static void MT_UtilAPSME_LinkKeyNvIdGet(uint8 *pBuf);
//  154 #endif //MT_SYS_KEY_MANAGEMENT
//  155 static void MT_UtilAPSME_RequestKeyCmd(uint8 *pBuf);
//  156 static void MT_UtilAssocCount(uint8 *pBuf);
//  157 static void MT_UtilAssocFindDevice(uint8 *pBuf);
//  158 static void MT_UtilAssocGetWithAddress(uint8 *pBuf);
//  159 static void MT_UtilBindAddEntry(uint8 *pBuf);
//  160 static void packDev_t(uint8 *pBuf, associated_devices_t *pDev);
//  161 static void packBindEntry_t(uint8 *pBuf, BindingEntry_t *pBind);
//  162 #if defined ZCL_KEY_ESTABLISH
//  163 static void MT_UtilzclGeneral_KeyEstablish_InitiateKeyEstablishment(uint8 *pBuf);
//  164 static void MT_UtilzclGeneral_KeyEstablishment_ECDSASign(uint8 *pBuf);
//  165 #endif // ZCL_KEY_ESTABLISH
//  166 static void MT_UtilSync(void);
//  167 static void MT_UtilGetDevNwkInfo( uint8 *pBuf );
//  168 
//  169 #endif // !defined NONWK
//  170 #endif // MT_UTIL_FUNC
//  171 
//  172 #if defined (MT_UTIL_FUNC)
//  173 /***************************************************************************************************
//  174 * @fn      MT_UtilProcessing
//  175 *
//  176 * @brief   Process all the DEBUG commands that are issued by test tool
//  177 *
//  178 * @param   pBuf  - pointer to received SPI data message
//  179 *
//  180 * @return  status
//  181 ***************************************************************************************************/
//  182 uint8 MT_UtilCommandProcessing(uint8 *pBuf)
//  183 {
//  184   uint8 status = MT_RPC_SUCCESS;
//  185 
//  186   switch (pBuf[MT_RPC_POS_CMD1])
//  187   {
//  188     // CC253X MAC Network Processor does not have NV support
//  189 #if !defined(CC253X_MACNP)
//  190   case MT_UTIL_GET_DEVICE_INFO:
//  191     MT_UtilGetDeviceInfo();
//  192     break;
//  193 
//  194   case MT_UTIL_GET_NV_INFO:
//  195     MT_UtilGetNvInfo();
//  196     break;
//  197 
//  198   case MT_UTIL_SET_PANID:
//  199     MT_UtilSetPanID(pBuf);
//  200     break;
//  201 
//  202   case MT_UTIL_SET_CHANNELS:
//  203     MT_UtilSetChannels(pBuf);
//  204     break;
//  205 
//  206   case MT_UTIL_SET_SECLEVEL:
//  207     MT_UtilSetSecLevel(pBuf);
//  208     break;
//  209 
//  210   case MT_UTIL_SET_PRECFGKEY:
//  211     MT_UtilSetPreCfgKey(pBuf);
//  212     break;
//  213 #endif
//  214 
//  215 #ifdef FEATURE_GET_PRIMARY_IEEE
//  216   case MT_UTIL_GET_PRIMARY_IEEE:
//  217     MT_UtilGetPrimaryIEEE();
//  218     break;
//  219 #endif
//  220 
//  221   case MT_UTIL_CALLBACK_SUB_CMD:
//  222     MT_UtilCallbackSub(pBuf);
//  223     break;
//  224 
//  225   case MT_UTIL_KEY_EVENT:
//  226 #if (defined HAL_KEY) && (HAL_KEY == TRUE)
//  227     MT_UtilKeyEvent(pBuf);
//  228 #endif
//  229     break;
//  230 
//  231   case MT_UTIL_TIME_ALIVE:
//  232     MT_UtilTimeAlive();
//  233     break;
//  234 
//  235   case MT_UTIL_LED_CONTROL:
//  236 #if (defined HAL_LED) && (HAL_LED == TRUE)
//  237     MT_UtilLedControl(pBuf);
//  238 #endif
//  239     break;
//  240 
//  241   case MT_UTIL_SRC_MATCH_ENABLE:
//  242     MT_UtilSrcMatchEnable(pBuf);
//  243     break;
//  244 
//  245   case MT_UTIL_SRC_MATCH_ADD_ENTRY:
//  246     MT_UtilSrcMatchAddEntry(pBuf);
//  247     break;
//  248 
//  249   case MT_UTIL_SRC_MATCH_DEL_ENTRY:
//  250     MT_UtilSrcMatchDeleteEntry(pBuf);
//  251     break;
//  252 
//  253   case MT_UTIL_SRC_MATCH_CHECK_SRC_ADDR:
//  254     MT_UtilSrcMatchCheckSrcAddr(pBuf);
//  255     break;
//  256 
//  257   case MT_UTIL_SRC_MATCH_ACK_ALL_PENDING:
//  258     MT_UtilSrcMatchAckAllPending(pBuf);
//  259     break;
//  260 
//  261   case MT_UTIL_SRC_MATCH_CHECK_ALL_PENDING:
//  262     MT_UtilSrcMatchCheckAllPending(pBuf);
//  263     break;
//  264 
//  265   case MT_UTIL_TEST_LOOPBACK:
//  266     MT_BuildAndSendZToolResponse((MT_RPC_CMD_SRSP|(uint8)MT_RPC_SYS_UTIL), MT_UTIL_TEST_LOOPBACK,
//  267                                  pBuf[MT_RPC_POS_LEN], (pBuf+MT_RPC_FRAME_HDR_SZ));
//  268     break;
//  269 
//  270   case MT_UTIL_GPIO_SET_DIRECTION:
//  271     MT_UtilGpioSetDirection(pBuf);
//  272     break;
//  273 
//  274   case MT_UTIL_GPIO_READ:
//  275     MT_UtilGpioRead(pBuf);
//  276     break;
//  277 
//  278   case MT_UTIL_GPIO_WRITE:
//  279     MT_UtilGpioWrite(pBuf);
//  280     break;
//  281 
//  282 #if !defined NONWK
//  283   case MT_UTIL_DATA_REQ:
//  284     MT_UtilDataReq(pBuf);
//  285     break;
//  286 
//  287   case MT_UTIL_ADDRMGR_EXT_ADDR_LOOKUP:
//  288     MT_UtilAddrMgrEntryLookupExt(pBuf);
//  289     break;
//  290 
//  291   case MT_UTIL_ADDRMGR_NWK_ADDR_LOOKUP:
//  292     MT_UtilAddrMgrEntryLookupNwk(pBuf);
//  293     break;
//  294 
//  295 #if defined MT_SYS_KEY_MANAGEMENT
//  296   case MT_UTIL_APSME_LINK_KEY_DATA_GET:
//  297     MT_UtilAPSME_LinkKeyDataGet(pBuf);
//  298     break;
//  299 
//  300   case MT_UTIL_APSME_LINK_KEY_NV_ID_GET:
//  301     MT_UtilAPSME_LinkKeyNvIdGet(pBuf);
//  302     break;
//  303 #endif // MT_SYS_KEY_MANAGEMENT
//  304 
//  305   case MT_UTIL_APSME_REQUEST_KEY_CMD:
//  306     MT_UtilAPSME_RequestKeyCmd(pBuf);
//  307     break;
//  308 
//  309   case MT_UTIL_ASSOC_COUNT:
//  310     MT_UtilAssocCount(pBuf);
//  311     break;
//  312 
//  313   case MT_UTIL_ASSOC_FIND_DEVICE:
//  314     MT_UtilAssocFindDevice(pBuf);
//  315     break;
//  316 
//  317   case MT_UTIL_ASSOC_GET_WITH_ADDRESS:
//  318     MT_UtilAssocGetWithAddress(pBuf);
//  319     break;
//  320 
//  321   case MT_UTIL_BIND_ADD_ENTRY:
//  322     MT_UtilBindAddEntry(pBuf);
//  323     break;
//  324 
//  325 #if defined ZCL_KEY_ESTABLISH
//  326   case MT_UTIL_ZCL_KEY_EST_INIT_EST:
//  327     MT_UtilzclGeneral_KeyEstablish_InitiateKeyEstablishment(pBuf);
//  328     break;
//  329 
//  330   case MT_UTIL_ZCL_KEY_EST_SIGN:
//  331     MT_UtilzclGeneral_KeyEstablishment_ECDSASign(pBuf);
//  332     break;
//  333 #endif
//  334 
//  335   case MT_UTIL_SYNC_REQ:
//  336     MT_UtilSync();
//  337     break;
//  338     
//  339   case MT_UTIL_GET_DEV_NWK_INFO:
//  340     MT_UtilGetDevNwkInfo(pBuf);
//  341     break;
//  342     
//  343   case MT_UTIL_SET_DEV_NWK_INFO:
//  344     MT_UtilSetDevNwkInfo(pBuf);
//  345     break;
//  346 #endif /* !defined NONWK */
//  347 
//  348 #ifdef MT_SRNG
//  349   case MT_UTIL_SRNG_GENERATE:
//  350     MT_UtilSrngGen();
//  351     break;
//  352 #endif
//  353 
//  354   default:
//  355     status = MT_RPC_ERR_COMMAND_ID;
//  356     break;
//  357   }
//  358 
//  359   return status;
//  360 }
//  361 
//  362 /***************************************************************************************************
//  363 * @fn      MT_UtilGetDeviceInfo
//  364 *
//  365 * @brief   The Get Device Info serial message.
//  366 *
//  367 * @param   None.
//  368 *
//  369 * @return  void
//  370 ***************************************************************************************************/
//  371 static void MT_UtilGetDeviceInfo(void)
//  372 {
//  373   uint8  *buf;
//  374   uint8  *pBuf;
//  375   uint8  bufLen = MT_UTIL_DEVICE_INFO_RESPONSE_LEN;
//  376   uint16 *assocList = NULL;
//  377 
//  378 #if !defined NONWK
//  379   uint8  assocCnt = 0;
//  380 
//  381   if (ZG_DEVICE_RTR_TYPE)
//  382   {
//  383     assocList = AssocMakeList( &assocCnt );
//  384     bufLen += (assocCnt * sizeof(uint16));
//  385   }
//  386 #endif
//  387 
//  388   buf = osal_mem_alloc( bufLen );
//  389   if ( buf )
//  390   {
//  391     pBuf = buf;
//  392 
//  393     *pBuf++ = ZSUCCESS; // Status
//  394 
//  395     osal_nv_read( ZCD_NV_EXTADDR, 0, Z_EXTADDR_LEN, pBuf );
//  396     pBuf += Z_EXTADDR_LEN;
//  397 
//  398 #if defined NONWK
//  399     // Skip past ZStack only parameters for NONWK
//  400     *pBuf++ = 0;
//  401     *pBuf++ = 0;
//  402     *pBuf++ = 0;
//  403     *pBuf++ = 0;
//  404     *pBuf = 0;
//  405 #else
//  406     {
//  407       uint16 shortAddr = NLME_GetShortAddr();
//  408       *pBuf++ = LO_UINT16( shortAddr );
//  409       *pBuf++ = HI_UINT16( shortAddr );
//  410     }
//  411 
//  412     /* Return device type */
//  413     *pBuf++ = ZSTACK_DEVICE_BUILD;
//  414 
//  415     /*Return device state */
//  416     *pBuf++ = (uint8)devState;
//  417 
//  418     if (ZG_DEVICE_RTR_TYPE)
//  419     {
//  420       *pBuf++ = assocCnt;
//  421 
//  422       if ( assocCnt )
//  423       {
//  424         uint8 x;
//  425         uint16 *puint16 = assocList;
//  426 
//  427         for ( x = 0; x < assocCnt; x++, puint16++ )
//  428         {
//  429           *pBuf++ = LO_UINT16( *puint16 );
//  430           *pBuf++ = HI_UINT16( *puint16 );
//  431         }
//  432       }
//  433     }
//  434     else
//  435     {
//  436       *pBuf++ = 0;
//  437     }
//  438 #endif
//  439 
//  440     MT_BuildAndSendZToolResponse( ((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL),
//  441                                  MT_UTIL_GET_DEVICE_INFO,
//  442                                  bufLen, buf );
//  443 
//  444     osal_mem_free( buf );
//  445   }
//  446 
//  447   if ( assocList )
//  448   {
//  449     osal_mem_free( assocList );
//  450   }
//  451 }
//  452 
//  453 #ifdef MT_SRNG
//  454 /***************************************************************************************************
//  455 * @fn      MT_UtilSrngGen
//  456 *
//  457 * @brief   Generate Secure Random Numbers
//  458 *
//  459 * @param   None.
//  460 *
//  461 * @return  void
//  462 ***************************************************************************************************/
//  463 static void MT_UtilSrngGen(void)
//  464 {
//  465   static uint32 count = 125000; /* 125000 * 8 bits = 1000000 bits */
//  466   uint8 outrng[100];
//  467   uint8 status;
//  468 
//  469   if(count > 0)
//  470   {
//  471     status = ssp_srng_generate((uint8 *)outrng, 100, NULL);
//  472     if (status != SRNG_SUCCESS)
//  473     {
//  474       if(RNG_INIT_ERROR == status)
//  475       {
//  476         ssp_srng_reseed();
//  477       }
//  478       else
//  479       {
//  480         while(1)
//  481         {
//  482           ASM_NOP;
//  483         }
//  484       } /* if(RNG_INIT_ERROR == status) */
//  485     }/*if (status != SRNG_SUCCESS) */
//  486 
//  487     if(count >= 100)
//  488     {
//  489       count -= 100;
//  490     }
//  491     else
//  492     {
//  493       count = 0;
//  494     }
//  495     MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_AREQ |
//  496                                  (uint8)MT_RPC_SYS_DBG),
//  497                                   MT_DEBUG_MSG,
//  498                                   100,
//  499                                   outrng);
//  500     osal_start_timerEx(MT_TaskID, MT_SRNG_EVENT, 100);
//  501   }
//  502 }
//  503 #endif
//  504 
//  505 /***************************************************************************************************
//  506  * @fn      MT_UtilGetNvInfo
//  507  *
//  508  * @brief   The Get NV Info serial message.
//  509  *
//  510  * @param   None.
//  511  *
//  512  * @return  void
//  513  ***************************************************************************************************/
//  514 static void MT_UtilGetNvInfo(void)
//  515 {
//  516   uint8 len;
//  517   uint8 stat;
//  518   uint8 *buf;
//  519   uint8 *pBuf;
//  520   uint16 tmp16;
//  521   uint32 tmp32;
//  522 
//  523   /*
//  524     Get required length of buffer
//  525     Status + ExtAddr + ChanList + PanID  + SecLevel + PreCfgKey
//  526   */
//  527   len = 1 + Z_EXTADDR_LEN + 4 + 2 + 1 + SEC_KEY_LEN;
//  528 
//  529   buf = osal_mem_alloc( len );
//  530   if ( buf )
//  531   {
//  532     /* Assume NV not available */
//  533     osal_memset( buf, 0xFF, len );
//  534 
//  535     /* Skip over status */
//  536     pBuf = buf + 1;
//  537 
//  538     /* Start with 64-bit extended address */
//  539     stat = osal_nv_read( ZCD_NV_EXTADDR, 0, Z_EXTADDR_LEN, pBuf );
//  540     if ( stat ) stat = 0x01;
//  541     pBuf += Z_EXTADDR_LEN;
//  542 
//  543     /* Scan channel list (bit mask) */
//  544     if (  osal_nv_read( ZCD_NV_CHANLIST, 0, sizeof( tmp32 ), &tmp32 ) )
//  545     {
//  546       stat |= 0x02;
//  547     }
//  548     else
//  549     {
//  550       pBuf[0] = BREAK_UINT32( tmp32, 3 );
//  551       pBuf[1] = BREAK_UINT32( tmp32, 2 );
//  552       pBuf[2] = BREAK_UINT32( tmp32, 1 );
//  553       pBuf[3] = BREAK_UINT32( tmp32, 0 );
//  554     }
//  555     pBuf += sizeof( tmp32 );
//  556 
//  557     /* ZigBee PanID */
//  558     if ( osal_nv_read( ZCD_NV_PANID, 0, sizeof( tmp16 ), &tmp16 ) )
//  559     {
//  560       stat |= 0x04;
//  561     }
//  562     else
//  563     {
//  564       pBuf[0] = LO_UINT16( tmp16 );
//  565       pBuf[1] = HI_UINT16( tmp16 );
//  566     }
//  567     pBuf += sizeof( tmp16 );
//  568 
//  569     /* Security level */
//  570     if ( osal_nv_read( ZCD_NV_SECURITY_LEVEL, 0, sizeof( uint8 ), pBuf++ ) )
//  571     {
//  572       stat |= 0x08;
//  573     }
//  574     /* Pre-configured security key */
//  575     if ( osal_nv_read( ZCD_NV_PRECFGKEY, 0, SEC_KEY_LEN, pBuf ) )
//  576     {
//  577       stat |= 0x10;
//  578     }
//  579     /* Status bit mask - bit=1 indicates failure */
//  580     *buf = stat;
//  581 
//  582     MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), MT_UTIL_GET_NV_INFO,
//  583                                   len, buf );
//  584 
//  585     osal_mem_free( buf );
//  586   }
//  587 }
//  588 
//  589 /***************************************************************************************************
//  590  * @fn      MT_UtilSetPanID
//  591  *
//  592  * @brief   Set PanID message
//  593  *
//  594  * @param   pBuf - pointer to the data
//  595  *
//  596  * @return  void
//  597  ***************************************************************************************************/
//  598 static void MT_UtilSetPanID(uint8 *pBuf)
//  599 {
//  600   uint16 temp16;
//  601   uint8 retValue;
//  602   uint8 cmdId;
//  603 
//  604   /* parse header */
//  605   cmdId = pBuf[MT_RPC_POS_CMD1];
//  606   pBuf += MT_RPC_FRAME_HDR_SZ;
//  607 
//  608   temp16 = osal_build_uint16( pBuf );
//  609 
//  610   retValue = osal_nv_write(ZCD_NV_PANID, 0, osal_nv_item_len( ZCD_NV_PANID ), &temp16);
//  611 
//  612   /* Build and send back the response */
//  613   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue);
//  614 }
//  615 
//  616 /***************************************************************************************************
//  617  * @fn      MT_UtilSetChannels
//  618  *
//  619  * @brief   Set Channels
//  620  *
//  621  * @param   pBuf - pointer to the data
//  622  *
//  623  * @return  void
//  624  ***************************************************************************************************/
//  625 static void MT_UtilSetChannels(uint8 *pBuf)
//  626 {
//  627   uint32 tmp32;
//  628   uint8 retValue;
//  629   uint8 cmdId;
//  630 
//  631   /* parse header */
//  632   cmdId = pBuf[MT_RPC_POS_CMD1];
//  633   pBuf += MT_RPC_FRAME_HDR_SZ;
//  634 
//  635   tmp32 = osal_build_uint32( pBuf, 4 );
//  636 
//  637   retValue = osal_nv_write(ZCD_NV_CHANLIST, 0, osal_nv_item_len( ZCD_NV_CHANLIST ), &tmp32);
//  638 
//  639   /* Build and send back the response */
//  640   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue);
//  641 }
//  642 
//  643 /***************************************************************************************************
//  644  * @fn      MT_UtilSetSecLevel
//  645  *
//  646  * @brief   Set Sec Level
//  647  *
//  648  * @param   byte *msg - pointer to the data
//  649  *
//  650  * @return  void
//  651  ***************************************************************************************************/
//  652 static void MT_UtilSetSecLevel(uint8 *pBuf)
//  653 {
//  654   uint8 retValue;
//  655   uint8 cmdId;
//  656 
//  657   /* parse header */
//  658   cmdId = pBuf[MT_RPC_POS_CMD1];
//  659   pBuf += MT_RPC_FRAME_HDR_SZ;
//  660 
//  661   retValue = osal_nv_write( ZCD_NV_SECURITY_LEVEL, 0, osal_nv_item_len( ZCD_NV_SECURITY_LEVEL ), pBuf);
//  662 
//  663   /* Build and send back the response */
//  664   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
//  665 
//  666 }
//  667 
//  668 /***************************************************************************************************
//  669  * @fn      MT_UtilSetPreCfgKey
//  670  *
//  671  * @brief   Set Pre Cfg Key
//  672  *
//  673  * @param   pBuf - pointer to the data
//  674  *
//  675  * @return  void
//  676  ***************************************************************************************************/
//  677 static void MT_UtilSetPreCfgKey(uint8 *pBuf)
//  678 {
//  679   uint8 retValue;
//  680   uint8 cmdId;
//  681 
//  682   /* parse header */
//  683   cmdId = pBuf[MT_RPC_POS_CMD1];
//  684   pBuf += MT_RPC_FRAME_HDR_SZ;
//  685 
//  686   retValue = osal_nv_write( ZCD_NV_PRECFGKEY, 0, osal_nv_item_len( ZCD_NV_PRECFGKEY ), pBuf);
//  687 
//  688   /* Build and send back the response */
//  689   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
//  690 
//  691 }
//  692 
//  693 #ifdef FEATURE_GET_PRIMARY_IEEE
//  694 /***************************************************************************************************
//  695  * @fn      MT_UtilGetPrimaryIEEE
//  696  *
//  697  * @brief   Return a copy of the Primary IEEE address
//  698  *
//  699  * @param   none
//  700  *
//  701  * @return  void
//  702  ***************************************************************************************************/
//  703 static void MT_UtilGetPrimaryIEEE(void)
//  704 {
//  705   uint8 i;
//  706   uint8 retBuf[Z_EXTADDR_LEN+1];
//  707 
//  708   retBuf[0] = SUCCESS;
//  709 
//  710   for(i = 1; i <= Z_EXTADDR_LEN; i++)
//  711   {
//  712     retBuf[i] = ieeeMac[i];
//  713   }
//  714 
//  715   MT_BuildAndSendZToolResponse( ((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL),
//  716                                   MT_UTIL_GET_PRIMARY_IEEE, Z_EXTADDR_LEN+1, retBuf );
//  717 }
//  718 #endif /* FEATURE_GET_PRIMARY_IEEE */
//  719 
//  720 /***************************************************************************************************
//  721  * @fn      MT_UtilCallbackSub
//  722  *
//  723  * @brief   The Callback subscribe.
//  724  *
//  725  * @param   pBuf - pointer to the data
//  726  *
//  727  * @return  void
//  728  ***************************************************************************************************/
//  729 void MT_UtilCallbackSub(uint8 *pBuf)
//  730 {
//  731   uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
//  732   uint8 retValue = ZFailure;
//  733 
//  734 #if defined(MT_MAC_CB_FUNC) || defined(MT_NWK_CB_FUNC) || defined(MT_ZDO_CB_FUNC) || defined(MT_AF_CB_FUNC) || defined(MT_SAPI_CB_FUNC)
//  735   uint8 subSystem;
//  736   uint16 subscribed_command;
//  737 
//  738   // Move past header
//  739   retValue = ZSuccess;
//  740   pBuf += MT_RPC_FRAME_HDR_SZ;
//  741 
//  742   /* Command */
//  743   subscribed_command = osal_build_uint16( pBuf );
//  744   pBuf += 2;
//  745 
//  746   /* Subsystem - 5 bits on the MSB of the command */
//  747   subSystem = HI_UINT16(subscribed_command) & 0x1F ;
//  748 
//  749   /* What is the action - SUBSCRIBE or !SUBSCRIBE */
//  750   if (*pBuf)
//  751   {
//  752     /* Turn ON */
//  753   #if defined( MT_MAC_CB_FUNC )
//  754     if ((subSystem == MT_RPC_SYS_MAC) || (subscribed_command == 0xFFFF))
//  755     {
//  756     #if !defined (FEATURE_DUAL_MAC)
//  757       _macCallbackSub = 0xFFFF;
//  758     #else
//  759       DMMGR_SaveMacCbReg( 0xFFFF );
//  760     #endif /* ! FEATURE_DUAL_MAC */
//  761     }
//  762   #endif
//  763 
//  764   #if defined( MT_NWK_CB_FUNC )
//  765     if ((subSystem == MT_RPC_SYS_NWK) || (subscribed_command == 0xFFFF))
//  766       _nwkCallbackSub = 0xFFFF;
//  767   #endif
//  768 
//  769   #if defined( MT_ZDO_CB_FUNC )
//  770     if ((subSystem == MT_RPC_SYS_ZDO) || (subscribed_command == 0xFFFF))
//  771       _zdoCallbackSub = 0xFFFFFFFF;
//  772   #endif
//  773 
//  774   #if defined( MT_AF_CB_FUNC )
//  775     if ((subSystem == MT_RPC_SYS_AF) || (subscribed_command == 0xFFFF))
//  776       _afCallbackSub = 0xFFFF;
//  777   #endif
//  778 
//  779   #if defined( MT_SAPI_CB_FUNC )
//  780     if ((subSystem == MT_RPC_SYS_SAPI) || (subscribed_command == 0xFFFF))
//  781       _sapiCallbackSub = 0xFFFF;
//  782   #endif
//  783   }
//  784   else
//  785   {
//  786     /* Turn OFF */
//  787   #if defined( MT_MAC_CB_FUNC )
//  788     if ((subSystem == MT_RPC_SYS_MAC) || (subscribed_command == 0xFFFF))
//  789       _macCallbackSub = 0x0000;
//  790 
//  791   #if defined (FEATURE_DUAL_MAC )
//  792     DMMGR_SaveMacCbReg( 0x0000 );
//  793   #endif /* FEATURE_DUAL_MAC */
//  794 
//  795   #endif
//  796 
//  797   #if defined( MT_NWK_CB_FUNC )
//  798     if ((subSystem == MT_RPC_SYS_NWK) || (subscribed_command == 0xFFFF))
//  799       _nwkCallbackSub = 0x0000;
//  800   #endif
//  801 
//  802   #if defined( MT_ZDO_CB_FUNC )
//  803     if ((subSystem == MT_RPC_SYS_ZDO) || (subscribed_command == 0xFFFF))
//  804       _zdoCallbackSub = 0x00000000;
//  805   #endif
//  806 
//  807   #if defined( MT_AF_CB_FUNC )
//  808     if ((subSystem == MT_RPC_SYS_AF) || (subscribed_command == 0xFFFF))
//  809       _afCallbackSub = 0x0000;
//  810   #endif
//  811 
//  812   #if defined( MT_SAPI_CB_FUNC )
//  813     if ((subSystem == MT_RPC_SYS_SAPI) || (subscribed_command == 0xFFFF))
//  814         _sapiCallbackSub = 0x0000;
//  815   #endif
//  816   }
//  817 #endif  // MT_MAC_CB_FUNC || MT_NWK_CB_FUNC || MT_ZDO_CB_FUNC || MT_AF_CB_FUNC || MT_SAPI_CB_FUNC || MT_SAPI_CB_FUNC
//  818 
//  819   /* Build and send back the response */
//  820   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
//  821 }
//  822 
//  823 #if (defined HAL_KEY) && (HAL_KEY == TRUE)
//  824 /***************************************************************************************************
//  825  * @fn      MT_UtilKeyEvent
//  826  *
//  827  * @brief   Process Key Event
//  828  *
//  829  * @param   pBuf - pointer to the data
//  830  *
//  831  * @return  void
//  832  ***************************************************************************************************/
//  833 static void MT_UtilKeyEvent(uint8 *pBuf)
//  834 {
//  835   uint8 x = 0;
//  836   uint8 retValue;
//  837   uint8 cmdId;
//  838 
//  839   /* parse header */
//  840   cmdId = pBuf[MT_RPC_POS_CMD1];
//  841   pBuf += MT_RPC_FRAME_HDR_SZ;
//  842 
//  843   /* Translate between SPI values to device values */
//  844   if ( *pBuf & 0x01 )
//  845     x |= HAL_KEY_SW_1;
//  846   if ( *pBuf & 0x02 )
//  847     x |= HAL_KEY_SW_2;
//  848   if ( *pBuf & 0x04 )
//  849     x |= HAL_KEY_SW_3;
//  850   if ( *pBuf & 0x08 )
//  851     x |= HAL_KEY_SW_4;
//  852 #if defined ( HAL_KEY_SW_5 )
//  853   if ( *pBuf & 0x10 )
//  854     x |= HAL_KEY_SW_5;
//  855 #endif
//  856 #if defined ( HAL_KEY_SW_6 )
//  857   if ( *pBuf & 0x20 )
//  858     x |= HAL_KEY_SW_6;
//  859 #endif
//  860 #if defined ( HAL_KEY_SW_7 )
//  861   if ( *pBuf & 0x40 )
//  862     x |= HAL_KEY_SW_7;
//  863 #endif
//  864 #if defined ( HAL_KEY_SW_8 )
//  865   if ( *pBuf & 0x80 )
//  866     x |= HAL_KEY_SW_8;
//  867 #endif
//  868   pBuf++;
//  869 
//  870   retValue = OnBoard_SendKeys(x, *pBuf);
//  871 
//  872   /* Build and send back the response */
//  873   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
//  874 }
//  875 #endif
//  876 
//  877 /***************************************************************************************************
//  878  * @fn      MT_UtilTimeAlive
//  879  *
//  880  * @brief   Process Time Alive
//  881  *
//  882  * @param   None.
//  883  *
//  884  * @return  None
//  885  ***************************************************************************************************/
//  886 static void MT_UtilTimeAlive(void)
//  887 {
//  888   uint8 timeAlive[4];
//  889   uint32 tmp32;
//  890 
//  891   /* Time since last reset (seconds) */
//  892   tmp32 = osal_GetSystemClock() / 1000;
//  893 
//  894   /* Convert to high byte first into temp buffer */
//  895   osal_buffer_uint32( timeAlive, tmp32 );
//  896 
//  897   /* Build and send back the response */
//  898   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL),
//  899                                        MT_UTIL_TIME_ALIVE, sizeof(timeAlive), timeAlive);
//  900 }
//  901 
//  902 #if (defined HAL_LED) && (HAL_LED == TRUE)
//  903 /***************************************************************************************************
//  904  * @fn      MT_UtilLedControl
//  905  *
//  906  * @brief   Process the LED Control Message
//  907  *
//  908  * @param   pBuf - pointer to the received data
//  909  *
//  910  * @return  None
//  911  ***************************************************************************************************/
//  912 static void MT_UtilLedControl(uint8 *pBuf)
//  913 {
//  914   uint8 iLed, Led, iMode, Mode, cmdId;
//  915   uint8 retValue;
//  916 
//  917   /* parse header */
//  918   cmdId = pBuf[MT_RPC_POS_CMD1];
//  919   pBuf += MT_RPC_FRAME_HDR_SZ;
//  920 
//  921   /* LED and Mode */
//  922   iLed = *pBuf++;
//  923   iMode = *pBuf;
//  924 
//  925   if ( iLed == 1 )
//  926     Led = HAL_LED_1;
//  927   else if ( iLed == 2 )
//  928     Led = HAL_LED_2;
//  929   else if ( iLed == 3 )
//  930     Led = HAL_LED_3;
//  931   else if ( iLed == 4 )
//  932     Led = HAL_LED_4;
//  933   else if ( iLed == 0xFF )
//  934     Led = HAL_LED_ALL;
//  935   else
//  936     Led = 0;
//  937 
//  938   if ( iMode == 0 )
//  939     Mode = HAL_LED_MODE_OFF;
//  940   else if ( iMode == 1 )
//  941     Mode = HAL_LED_MODE_ON;
//  942   else if ( iMode == 2 )
//  943     Mode = HAL_LED_MODE_BLINK;
//  944   else if ( iMode == 3 )
//  945     Mode = HAL_LED_MODE_FLASH;
//  946   else if ( iMode == 4 )
//  947     Mode = HAL_LED_MODE_TOGGLE;
//  948   else
//  949     Led = 0;
//  950 
//  951   if ( Led != 0 )
//  952   {
//  953     HalLedSet (Led, Mode);
//  954     retValue = ZSuccess;
//  955   }
//  956   else
//  957   {
//  958     retValue = ZFailure;
//  959   }
//  960 
//  961   /* Build and send back the response */
//  962   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
//  963 }
//  964 #endif /* HAL_LED */
//  965 
//  966 /***************************************************************************************************
//  967  * @fn          MT_UtilSrcMatchEnable
//  968  *
//  969  * @brief      Enabled AUTOPEND and source address matching.
//  970  *
//  971  * @param      pBuf - Buffer contains the data
//  972  *
//  973  * @return     void
//  974  ***************************************************************************************************/
//  975 static void MT_UtilSrcMatchEnable (uint8 *pBuf)
//  976 {
//  977   uint8 retValue, cmdId;
//  978 
//  979   /* Parse header */
//  980   cmdId = pBuf[MT_RPC_POS_CMD1];
//  981   pBuf += MT_RPC_FRAME_HDR_SZ;
//  982 
//  983 #ifdef AUTO_PEND
//  984   /* Call the routine */
//  985   retValue = ZMacSrcMatchEnable();
//  986 #else
//  987   retValue = ZMacUnsupported;
//  988 #endif
//  989 
//  990   /* Build and send back the response */
//  991   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
//  992 
//  993 }
//  994 
//  995 /***************************************************************************************************
//  996  * @fn          MT_UtilSrcMatchAddEntry
//  997  *
//  998  * @brief       Add a short or extended address to source address table.
//  999  *
// 1000  * @param       pBuf - Buffer contains the data
// 1001  *
// 1002  * @return      void
// 1003  ***************************************************************************************************/
// 1004 static void MT_UtilSrcMatchAddEntry (uint8 *pBuf)
// 1005 {
// 1006   uint8 retValue, cmdId;
// 1007 
// 1008   /* Parse header */
// 1009   cmdId = pBuf[MT_RPC_POS_CMD1];
// 1010   pBuf += MT_RPC_FRAME_HDR_SZ;
// 1011 
// 1012 #ifdef AUTO_PEND
// 1013   uint16 panID;
// 1014   zAddrType_t devAddr;
// 1015 
// 1016   /* Address mode */
// 1017   devAddr.addrMode = *pBuf++;
// 1018 
// 1019   /* Address based on the address mode */
// 1020   MT_UtilSpi2Addr( &devAddr, pBuf);
// 1021   pBuf += Z_EXTADDR_LEN;
// 1022 
// 1023   /* PanID */
// 1024   panID = osal_build_uint16( pBuf );
// 1025 
// 1026   /* Call the routine */
// 1027   retValue =  ZMacSrcMatchAddEntry (&devAddr, panID);
// 1028 #else
// 1029   retValue = ZMacUnsupported;
// 1030 #endif
// 1031 
// 1032   /* Build and send back the response */
// 1033   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
// 1034 }
// 1035 
// 1036 /***************************************************************************************************
// 1037  * @fn          MT_UtilSrcMatchDeleteEntry
// 1038  *
// 1039  * @brief      Delete a short or extended address from source address table.
// 1040  *
// 1041  * @param      pBuf - Buffer contains the data
// 1042  *
// 1043  * @return     void
// 1044  ***************************************************************************************************/
// 1045 static void MT_UtilSrcMatchDeleteEntry (uint8 *pBuf)
// 1046 {
// 1047   uint8 retValue, cmdId;
// 1048 
// 1049   /* Parse header */
// 1050   cmdId = pBuf[MT_RPC_POS_CMD1];
// 1051   pBuf += MT_RPC_FRAME_HDR_SZ;
// 1052 
// 1053 #ifdef AUTO_PEND
// 1054   uint16 panID;
// 1055   zAddrType_t devAddr;
// 1056 
// 1057   /* Address mode */
// 1058   devAddr.addrMode = *pBuf++;
// 1059 
// 1060   /* Address based on the address mode */
// 1061   MT_UtilSpi2Addr( &devAddr, pBuf);
// 1062   pBuf += Z_EXTADDR_LEN;
// 1063 
// 1064   /* PanID */
// 1065   panID = osal_build_uint16( pBuf );
// 1066 
// 1067   /* Call the routine */
// 1068   retValue =  ZMacSrcMatchDeleteEntry (&devAddr, panID);
// 1069 #else
// 1070   retValue = ZMacUnsupported;
// 1071 #endif
// 1072 
// 1073   /* Build and send back the response */
// 1074   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
// 1075 }
// 1076 
// 1077 /***************************************************************************************************
// 1078  * @fn          MT_UtilSrcMatchCheckSrcAddr
// 1079  *
// 1080  * @brief      Check if a short or extended address is in the source address table.
// 1081  *
// 1082  * @param      pBuf - Buffer contains the data
// 1083  *
// 1084  * @return     void
// 1085  ***************************************************************************************************/
// 1086 static void MT_UtilSrcMatchCheckSrcAddr (uint8 *pBuf)
// 1087 {
// 1088   uint8 cmdId;
// 1089   uint8 retArray[2];
// 1090 
// 1091   /* Parse header */
// 1092   cmdId = pBuf[MT_RPC_POS_CMD1];
// 1093   pBuf += MT_RPC_FRAME_HDR_SZ;
// 1094 
// 1095 #if 0  /* Unsupported  */
// 1096   uint16 panID;
// 1097   zAddrType_t devAddr;
// 1098 
// 1099   /* Address mode */
// 1100   devAddr.addrMode = *pBuf++;
// 1101 
// 1102   /* Address based on the address mode */
// 1103   MT_UtilSpi2Addr( &devAddr, pBuf);
// 1104   pBuf += Z_EXTADDR_LEN;
// 1105 
// 1106   /* PanID */
// 1107   panID = osal_build_uint16( pBuf );
// 1108 
// 1109   /* Call the routine */
// 1110   retArray[1] =  ZMacSrcMatchCheckSrcAddr (&devAddr, panID);
// 1111 
// 1112     /* Return failure if the index is invalid */
// 1113   if (retArray[1] == ZMacSrcMatchInvalidIndex )
// 1114   {
// 1115     retArray[0] = ZFailure;
// 1116   }
// 1117   else
// 1118   {
// 1119     retArray[0] = ZSuccess;
// 1120   }
// 1121 #else
// 1122   retArray[0] = ZMacUnsupported;
// 1123   retArray[1] = ZMacSrcMatchInvalidIndex;
// 1124 #endif
// 1125 
// 1126   /* Build and send back the response */
// 1127   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 2, retArray );
// 1128 }
// 1129 
// 1130 /***************************************************************************************************
// 1131  * @fn          MT_UtilSrcMatchAckAllPending
// 1132  *
// 1133  * @brief       Enabled/disable acknowledging all packets with pending bit set
// 1134  *              It is normally enabled when adding new entries to
// 1135  *              the source address table fails due to the table is full, or
// 1136  *              disabled when more entries are deleted and the table has
// 1137  *              empty slots.
// 1138  *
// 1139  * @param       pBuf - Buffer contains the data
// 1140  *
// 1141  * @return      void
// 1142  ***************************************************************************************************/
// 1143 static void MT_UtilSrcMatchAckAllPending (uint8 *pBuf)
// 1144 {
// 1145   uint8 retValue, cmdId;
// 1146 
// 1147   /* Parse header */
// 1148   cmdId = pBuf[MT_RPC_POS_CMD1];
// 1149   pBuf += MT_RPC_FRAME_HDR_SZ;
// 1150 
// 1151 #ifdef AUTO_PEND
// 1152   /* Call the routine */
// 1153   retValue = ZMacSrcMatchAckAllPending(*pBuf);
// 1154 #else
// 1155   retValue = ZMacUnsupported;
// 1156 #endif
// 1157 
// 1158   /* Build and send back the response */
// 1159   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue );
// 1160 }
// 1161 
// 1162 /***************************************************************************************************
// 1163  * @fn          MT_UtilSrcMatchCheckAllPending
// 1164  *
// 1165  * @brief       Check if acknowledging all packets with pending bit set
// 1166  *              is enabled.
// 1167  *
// 1168  * @param       pBuf - Buffer contains the data
// 1169  *
// 1170  * @return      void
// 1171  ***************************************************************************************************/
// 1172 static void MT_UtilSrcMatchCheckAllPending (uint8 *pBuf)
// 1173 {
// 1174   uint8 retArray[2], cmdId;
// 1175 
// 1176   /* Parse header */
// 1177   cmdId = pBuf[MT_RPC_POS_CMD1];
// 1178   pBuf += MT_RPC_FRAME_HDR_SZ;
// 1179 
// 1180 #ifdef AUTO_PEND
// 1181   /* Call the routine */
// 1182   retArray[0] = ZMacSuccess;
// 1183   retArray[1] = ZMacSrcMatchCheckAllPending();
// 1184 #else
// 1185   retArray[0] = ZMacUnsupported;
// 1186   retArray[1] = FALSE;
// 1187 #endif
// 1188 
// 1189   /* Build and send back the response */
// 1190   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 2, retArray );
// 1191 }
// 1192 
// 1193 /***************************************************************************************************
// 1194  * SUPPORT
// 1195  ***************************************************************************************************/
// 1196 
// 1197 #ifdef AUTO_PEND
// 1198 /***************************************************************************************************
// 1199  * @fn      MT_UtilRevExtCpy
// 1200  *
// 1201  * @brief
// 1202  *
// 1203  *   Reverse-copy an extended address.
// 1204  *
// 1205  * @param   pDst - Pointer to data destination
// 1206  * @param   pSrc - Pointer to data source
// 1207  *
// 1208  * @return  void
// 1209  ***************************************************************************************************/
// 1210 static void MT_UtilRevExtCpy( uint8 *pDst, uint8 *pSrc )
// 1211 {
// 1212   int8 i;
// 1213 
// 1214   for ( i = Z_EXTADDR_LEN - 1; i >= 0; i-- )
// 1215   {
// 1216     *pDst++ = pSrc[i];
// 1217   }
// 1218 }
// 1219 
// 1220 /***************************************************************************************************
// 1221  * @fn      MT_UtilSpi2Addr
// 1222  *
// 1223  * @brief   Copy an address from an SPI message to an address struct.  The
// 1224  *          addrMode in pAddr must already be set.
// 1225  *
// 1226  * @param   pDst - Pointer to address struct
// 1227  * @param   pSrc - Pointer SPI message byte array
// 1228  *
// 1229  * @return  void
// 1230  ***************************************************************************************************/
// 1231 static void MT_UtilSpi2Addr( zAddrType_t *pDst, uint8 *pSrc )
// 1232 {
// 1233   if ( pDst->addrMode == Addr16Bit )
// 1234   {
// 1235     pDst->addr.shortAddr = osal_build_uint16( pSrc );
// 1236   }
// 1237   else if ( pDst->addrMode == Addr64Bit )
// 1238   {
// 1239     MT_UtilRevExtCpy( pDst->addr.extAddr, pSrc );
// 1240   }
// 1241 }
// 1242 #endif // AUTO_PEND
// 1243 
// 1244 /***************************************************************************************************
// 1245  * @fn      MT_UtilGpioRead
// 1246  *
// 1247  * @brief   Read values of all GPIOs (P0_0 -P2_4)
// 1248  *
// 1249  * @param   void
// 1250  *
// 1251  * @return  P0, P1, P2, P0DIR, P1DIR, P2DIR
// 1252  ***************************************************************************************************/
// 1253 static void MT_UtilGpioRead(uint8 *pBuf)
// 1254 {
// 1255 #if defined ( HAL_MCU_CC2530 )
// 1256   uint8 rtrn[6] = {P0, P1, P2, P0DIR, P1DIR, P2DIR};
// 1257 #else
// 1258   uint8 rtrn[6] = {0, 0, 0, 0, 0, 0};
// 1259 #endif
// 1260   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), MT_UTIL_GPIO_READ,
// 1261     6, rtrn);
// 1262 }
// 1263 
// 1264 /***************************************************************************************************
// 1265  * @fn      MT_UtilGpioSetDirection
// 1266  *
// 1267  * @brief   Set the direction of a specific GPIO (P0_0 -P2_4)
// 1268  *
// 1269  * @param   port - 0, 1 or 2
// 1270  * @param   bit - 0 - 7
// 1271  * @param   direction - 0 for input, 1 for output
// 1272  *
// 1273  * @return  oldP0DIR, oldP1DIR, oldP2DIR, newP0DIR, newP1DIR, newP2DIR
// 1274  ***************************************************************************************************/
// 1275 static void MT_UtilGpioSetDirection(uint8 *pBuf)
// 1276 {
// 1277 #if defined ( HAL_MCU_CC2530 )
// 1278   uint8 rtrn[6] = {P0DIR, P1DIR, P2DIR, 0, 0, 0};
// 1279   uint8 port = pBuf[MT_RPC_POS_DAT0 + 0];
// 1280   uint8 bit = pBuf[MT_RPC_POS_DAT0 + 1];
// 1281   uint8 direction = pBuf[MT_RPC_POS_DAT0 + 2];
// 1282 
// 1283   if (direction == 0)
// 1284   {
// 1285     switch (port)
// 1286     {
// 1287       case 0:
// 1288         P0DIR &= (~ BV(bit));
// 1289         break;
// 1290       case 1:
// 1291         P1DIR &= (~ BV(bit));
// 1292         break;
// 1293       case 2:
// 1294         P2DIR &= (~ BV(bit));
// 1295         break;
// 1296     }
// 1297   }
// 1298   else
// 1299   {
// 1300     switch (port)
// 1301     {
// 1302       case 0:
// 1303         P0DIR |= BV(bit);
// 1304         break;
// 1305       case 1:
// 1306         P1DIR |= BV(bit);
// 1307         break;
// 1308       case 2:
// 1309         P2DIR |= BV(bit);
// 1310         break;
// 1311     }
// 1312   }
// 1313 
// 1314   rtrn[3] = P0DIR;
// 1315   rtrn[4] = P1DIR;
// 1316   rtrn[5] = P2DIR;
// 1317 #else
// 1318   uint8 rtrn[6] = {0, 0, 0, 0, 0, 0};
// 1319 #endif
// 1320 
// 1321   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), MT_UTIL_GPIO_SET_DIRECTION,
// 1322     6, rtrn);
// 1323 }
// 1324 
// 1325 /***************************************************************************************************
// 1326  * @fn      MT_UtilGpioWrite
// 1327  *
// 1328  * @brief   Write value of a specific GPIO (P0_0 -P2_4)
// 1329  *
// 1330  * @param   port - 0, 1 or 2
// 1331  * @param   bit - 0 - 7
// 1332  * @param   value - 0 or 1
// 1333  *
// 1334  * @return  oldP0, oldP1, oldP2, newP0, newP1, newP2, P0DIR, P1DIR, P2DIR
// 1335  ***************************************************************************************************/
// 1336 static void MT_UtilGpioWrite(uint8 *pBuf)
// 1337 {
// 1338 #if defined ( HAL_MCU_CC2530 )
// 1339   uint8 rtrn[9] = {P0, P1, P2, 0, 0, 0, P0DIR, P1DIR, P2DIR};
// 1340   uint8 port = pBuf[MT_RPC_POS_DAT0 + 0];
// 1341   uint8 bit = pBuf[MT_RPC_POS_DAT0 + 1];
// 1342   uint8 value = pBuf[MT_RPC_POS_DAT0 + 2];
// 1343 
// 1344   if (value == 0)
// 1345   {
// 1346     switch (port)
// 1347     {
// 1348       case 0:
// 1349         P0 &= (~ BV(bit));
// 1350         break;
// 1351       case 1:
// 1352         P1 &= (~ BV(bit));
// 1353         break;
// 1354       case 2:
// 1355         P2 &= (~ BV(bit));
// 1356         break;
// 1357     }
// 1358   }
// 1359   else
// 1360   {
// 1361     switch (port)
// 1362     {
// 1363       case 0:
// 1364         P0 |= BV(bit);
// 1365         break;
// 1366       case 1:
// 1367         P1 |= BV(bit);
// 1368         break;
// 1369       case 2:
// 1370         P2 |= BV(bit);
// 1371         break;
// 1372     }
// 1373   }
// 1374 
// 1375   rtrn[3] = P0;
// 1376   rtrn[4] = P1;
// 1377   rtrn[5] = P2;
// 1378 
// 1379 #else
// 1380   uint8 rtrn[9] = {0, 0, 0, 0, 0, 0, 0, 0, 0};
// 1381 #endif
// 1382 
// 1383   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), MT_UTIL_GPIO_WRITE,
// 1384     9, rtrn);
// 1385 }
// 1386 
// 1387 #if !defined NONWK
// 1388 /**************************************************************************************************
// 1389  * @fn      MT_UtilDataReq
// 1390  *
// 1391  * @brief   Process the MAC Data Request command.
// 1392  *
// 1393  * @param   pBuf - pointer to the received data
// 1394  *
// 1395  * @return  None
// 1396 **************************************************************************************************/
// 1397 static void MT_UtilDataReq(uint8 *pBuf)
// 1398 {
// 1399   uint8 rtrn = NwkPollReq(pBuf[MT_RPC_POS_DAT0]);
// 1400   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), MT_UTIL_DATA_REQ,
// 1401                                                                                1, &rtrn);
// 1402 }
// 1403 
// 1404 /***************************************************************************************************
// 1405  * @fn      MT_UtilAddrMgrEntryLookupExt
// 1406  *
// 1407  * @brief   Proxy the AddrMgrEntryLookupExt() function.
// 1408  *
// 1409  * @param   pBuf - pointer to the received buffer
// 1410  *
// 1411  * @return  void
// 1412  ***************************************************************************************************/
// 1413 static void MT_UtilAddrMgrEntryLookupExt(uint8 *pBuf)
// 1414 {
// 1415   uint8 nwkAddr[2];
// 1416   AddrMgrEntry_t entry;
// 1417   uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
// 1418   pBuf += MT_RPC_FRAME_HDR_SZ;
// 1419 
// 1420   osal_memcpy(entry.extAddr, pBuf, Z_EXTADDR_LEN);
// 1421   (void)AddrMgrEntryLookupExt(&entry);
// 1422 
// 1423   nwkAddr[0] = LO_UINT16(entry.nwkAddr);
// 1424   nwkAddr[1] = HI_UINT16(entry.nwkAddr);
// 1425   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL),
// 1426                                        cmdId, sizeof(uint16), nwkAddr);
// 1427 }
// 1428 
// 1429 /***************************************************************************************************
// 1430  * @fn      MT_UtilAddrMgrEntryLookupNwk
// 1431  *
// 1432  * @brief   Proxy the AddrMgrEntryLookupNwk() function.
// 1433  *
// 1434  * @param   pBuf - pointer to the received buffer
// 1435  *
// 1436  * @return  void
// 1437  ***************************************************************************************************/
// 1438 static void MT_UtilAddrMgrEntryLookupNwk(uint8 *pBuf)
// 1439 {
// 1440   AddrMgrEntry_t entry;
// 1441   uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
// 1442   pBuf += MT_RPC_FRAME_HDR_SZ;
// 1443 
// 1444   entry.nwkAddr = osal_build_uint16( pBuf );
// 1445   (void)AddrMgrEntryLookupNwk(&entry);
// 1446 
// 1447   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL),
// 1448                                        cmdId, Z_EXTADDR_LEN, entry.extAddr);
// 1449 }
// 1450 
// 1451 #if defined MT_SYS_KEY_MANAGEMENT
// 1452 /***************************************************************************************************
// 1453  * @fn      MT_UtilAPSME_LinkKeyDataGet
// 1454  *
// 1455  * @brief   Retrieves APS Link Key data from NV.
// 1456  *
// 1457  * @param   pBuf - pointer to the received buffer
// 1458  *
// 1459  * @return  void
// 1460  ***************************************************************************************************/
// 1461 static void MT_UtilAPSME_LinkKeyDataGet(uint8 *pBuf)
// 1462 {
// 1463   uint8 rsp[MT_APSME_LINKKEY_GET_RSP_LEN];
// 1464   APSME_LinkKeyData_t *pData = NULL;
// 1465   uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
// 1466   uint16 apsLinkKeyNvId;
// 1467   uint32 *apsRxFrmCntr;
// 1468   uint32 *apsTxFrmCntr;
// 1469 
// 1470   pBuf += MT_RPC_FRAME_HDR_SZ;
// 1471 
// 1472   *rsp = APSME_LinkKeyNVIdGet(pBuf, &apsLinkKeyNvId);
// 1473 
// 1474   if (SUCCESS == *rsp)
// 1475   {
// 1476     pData = (APSME_LinkKeyData_t *)osal_mem_alloc(sizeof(APSME_LinkKeyData_t));
// 1477 
// 1478     if (pData != NULL)
// 1479     {
// 1480       // retrieve key from NV
// 1481       if ( osal_nv_read( apsLinkKeyNvId, 0,
// 1482                         sizeof(APSME_LinkKeyData_t), pData) == SUCCESS)
// 1483 
// 1484       {
// 1485         uint8 *ptr = rsp+1;
// 1486         apsRxFrmCntr = &ApsLinkKeyFrmCntr[apsLinkKeyNvId - ZCD_NV_APS_LINK_KEY_DATA_START].rxFrmCntr;
// 1487         apsTxFrmCntr = &ApsLinkKeyFrmCntr[apsLinkKeyNvId - ZCD_NV_APS_LINK_KEY_DATA_START].txFrmCntr;
// 1488 
// 1489         (void)osal_memcpy(ptr, pData->key, SEC_KEY_LEN);
// 1490         ptr += SEC_KEY_LEN;
// 1491         osal_buffer_uint32( ptr, *apsTxFrmCntr );
// 1492         ptr += 4;
// 1493         osal_buffer_uint32( ptr, *apsRxFrmCntr );
// 1494       }
// 1495 
// 1496       // clear copy of key in RAM
// 1497       osal_memset( pData, 0x00, sizeof(APSME_LinkKeyData_t) );
// 1498 
// 1499       osal_mem_free(pData);
// 1500     }
// 1501   }
// 1502   else
// 1503   {
// 1504     // set data key and counters 0xFF
// 1505     osal_memset(&rsp[1], 0xFF, SEC_KEY_LEN + (MT_UTIL_FRM_CTR_LEN * 2));
// 1506   }
// 1507 
// 1508   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId,
// 1509                                        MT_APSME_LINKKEY_GET_RSP_LEN, rsp);
// 1510 
// 1511   // clear key data
// 1512   osal_memset(rsp, 0x00, MT_APSME_LINKKEY_GET_RSP_LEN);
// 1513 
// 1514 }
// 1515 
// 1516 /***************************************************************************************************
// 1517  * @fn      MT_UtilAPSME_LinkKeyNvIdGet
// 1518  *
// 1519  * @brief   Retrieves APS Link Key NV ID from the entry table.
// 1520  *
// 1521  * @param   pBuf - pointer to the received buffer
// 1522  *
// 1523  * @return  void
// 1524  ***************************************************************************************************/
// 1525 static void MT_UtilAPSME_LinkKeyNvIdGet(uint8 *pBuf)
// 1526 {
// 1527   uint8 rsp[MT_APSME_LINKKEY_NV_ID_GET_RSP_LEN];
// 1528   uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
// 1529   uint16 apsLinkKeyNvId;
// 1530 
// 1531   pBuf += MT_RPC_FRAME_HDR_SZ;
// 1532 
// 1533   *rsp = APSME_LinkKeyNVIdGet(pBuf, &apsLinkKeyNvId);
// 1534 
// 1535   if (SUCCESS == *rsp)
// 1536   {
// 1537     rsp[1] = LO_UINT16(apsLinkKeyNvId);
// 1538     rsp[2] = HI_UINT16(apsLinkKeyNvId);
// 1539   }
// 1540   else
// 1541   {
// 1542     // send failure response with invalid NV ID
// 1543     osal_memset(&rsp[1], 0xFF, 2);
// 1544   }
// 1545 
// 1546   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId,
// 1547                                        MT_APSME_LINKKEY_NV_ID_GET_RSP_LEN, rsp);
// 1548 }
// 1549 #endif // MT_SYS_KEY_MANAGEMENT
// 1550 
// 1551 /***************************************************************************************************
// 1552  * @fn      MT_UtilAPSME_RequestKeyCmd
// 1553  *
// 1554  * @brief   Send RequestKey command message to TC for a specific partner Address.
// 1555  *
// 1556  * @param   pBuf  - pointer to the received buffer
// 1557  *
// 1558  * @return  void
// 1559  ***************************************************************************************************/
// 1560 void MT_UtilAPSME_RequestKeyCmd(uint8 *pBuf)
// 1561 {
// 1562   uint8 cmdId;
// 1563   uint8 partnerAddr[Z_EXTADDR_LEN];
// 1564   uint8 retValue;
// 1565 
// 1566   // parse header
// 1567   cmdId = pBuf[MT_RPC_POS_CMD1];
// 1568   pBuf += MT_RPC_FRAME_HDR_SZ;
// 1569 
// 1570   /* PartnerAddress */
// 1571   osal_memcpy(partnerAddr, pBuf, Z_EXTADDR_LEN);
// 1572 
// 1573   retValue = (uint8)ZDSecMgrRequestAppKey(partnerAddr);
// 1574 
// 1575   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, &retValue);
// 1576 }
// 1577 
// 1578 /***************************************************************************************************
// 1579  * @fn      MT_UtilAssocCount
// 1580  *
// 1581  * @brief   Proxy the AssocCount() function.
// 1582  *
// 1583  * @param   pBuf - pointer to the received buffer
// 1584  *
// 1585  * @return  void
// 1586  ***************************************************************************************************/
// 1587 static void MT_UtilAssocCount(uint8 *pBuf)
// 1588 {
// 1589   uint16 cnt;
// 1590   uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
// 1591   pBuf += MT_RPC_FRAME_HDR_SZ;
// 1592 
// 1593   cnt = AssocCount(pBuf[0], pBuf[1]);
// 1594   pBuf[0] = LO_UINT16(cnt);
// 1595   pBuf[1] = HI_UINT16(cnt);
// 1596 
// 1597   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 2, pBuf);
// 1598 }
// 1599 
// 1600 /***************************************************************************************************
// 1601  * @fn      MT_UtilAssocFindDevice
// 1602  *
// 1603  * @brief   Get an associated device by index.
// 1604  *
// 1605  * @param   pBuf - pointer to the received buffer
// 1606  *
// 1607  * @return  void
// 1608  ***************************************************************************************************/
// 1609 static void MT_UtilAssocFindDevice(uint8 *pBuf)
// 1610 {
// 1611   uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
// 1612   uint8 buf[sizeof(associated_devices_t)];
// 1613 
// 1614   packDev_t(buf, AssocFindDevice(pBuf[MT_RPC_FRAME_HDR_SZ]));
// 1615   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId,
// 1616                                        sizeof(associated_devices_t), buf);
// 1617 }
// 1618 
// 1619 /***************************************************************************************************
// 1620  * @fn      MT_UtilAssocGetWithAddress
// 1621  *
// 1622  * @brief   Get an associated device by address.
// 1623  *
// 1624  * @param   pBuf - pointer to the received buffer
// 1625  *
// 1626  * @return  void
// 1627  ***************************************************************************************************/
// 1628 static void MT_UtilAssocGetWithAddress(uint8 *pBuf)
// 1629 {
// 1630   extern associated_devices_t *AssocGetWithAddress(uint8 *extAddr, uint16 shortAddr);
// 1631   uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
// 1632   uint8 buf[sizeof(associated_devices_t)];
// 1633 
// 1634   pBuf += MT_RPC_FRAME_HDR_SZ;
// 1635   packDev_t(buf, AssocGetWithAddress(((AddrMgrExtAddrValid(pBuf)) ? pBuf : NULL),
// 1636                                   BUILD_UINT16(pBuf[Z_EXTADDR_LEN], pBuf[Z_EXTADDR_LEN+1])));
// 1637 
// 1638   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId,
// 1639                                        sizeof(associated_devices_t), buf);
// 1640 }
// 1641 
// 1642 /***************************************************************************************************
// 1643  * @fn      MT_UtilBindAddEntry
// 1644  *
// 1645  * @brief   Add Binding Entry into Local Table.
// 1646  *
// 1647  * @param   pBuf - pointer to the received buffer
// 1648  *
// 1649  * @return  void
// 1650  ***************************************************************************************************/
// 1651 static void MT_UtilBindAddEntry(uint8 *pBuf)
// 1652 {
// 1653   uint8 srcEp;
// 1654   zAddrType_t dstAddr;
// 1655   uint8 dstEp;
// 1656   uint8 numClusterIds;
// 1657   uint16 *clusterIds;
// 1658   uint8 buf[sizeof(BindingEntry_t)];
// 1659   uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
// 1660   pBuf += MT_RPC_FRAME_HDR_SZ;
// 1661 
// 1662   // Initialize the return buffer
// 1663   osal_memset( buf, 0xFF, sizeof(BindingEntry_t) );
// 1664   buf[2] = 0xFE;    // set the default value of INVALID_NODE_ADDR
// 1665   buf[3] = 0xFF;    // set the default value of INVALID_NODE_ADDR
// 1666 
// 1667   srcEp = *pBuf++;
// 1668 
// 1669   // Destination Address mode
// 1670   dstAddr.addrMode = *pBuf++;
// 1671 
// 1672   // Destination Address
// 1673   if ( dstAddr.addrMode == Addr64Bit )
// 1674   {
// 1675     uint8 *ptr; // Use this additional pointer because *pBuf is incremented later for both cases
// 1676 
// 1677     ptr = pBuf;
// 1678     osal_cpyExtAddr( dstAddr.addr.extAddr, ptr );
// 1679   }
// 1680   else
// 1681   {
// 1682     dstAddr.addr.shortAddr = osal_build_uint16( pBuf );
// 1683   }
// 1684   // The short address occupies LSB two bytes
// 1685   pBuf += Z_EXTADDR_LEN;
// 1686 
// 1687   // DstEPInt
// 1688   dstEp = *pBuf++;
// 1689 
// 1690   numClusterIds = *pBuf++;
// 1691 
// 1692   if ( numClusterIds > 0 )
// 1693   {
// 1694     // copy list of clusters
// 1695     clusterIds = (uint16 *)osal_mem_alloc( numClusterIds * sizeof(uint16) );
// 1696     osal_memcpy( clusterIds, pBuf, numClusterIds * sizeof(uint16));
// 1697 
// 1698     if ( clusterIds != NULL )
// 1699     {
// 1700       // The response to MT interface has to be pack into buf
// 1701       packBindEntry_t( buf, bindAddEntry( srcEp, &dstAddr, dstEp, numClusterIds, clusterIds ));
// 1702 
// 1703       osal_mem_free( clusterIds );
// 1704     }
// 1705   }
// 1706 
// 1707   MT_BuildAndSendZToolResponse( ( (uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL ),
// 1708                                 cmdId, sizeof(BindingEntry_t), buf );
// 1709 }
// 1710 
// 1711 /***************************************************************************************************
// 1712  * @fn      packDev_t
// 1713  *
// 1714  * @brief   Pack an associated_devices_t structure into a byte buffer (pack INVALID_NODE_ADDR if
// 1715  *          the pDev parameter is NULL).
// 1716  *
// 1717  * @param   pBuf - pointer to the buffer into which to pack the structure.
// 1718  * @param   pDev - pointer to the structure.
// 1719  *
// 1720  * @return  void
// 1721  ***************************************************************************************************/
// 1722 static void packDev_t(uint8 *pBuf, associated_devices_t *pDev)
// 1723 {
// 1724   if (NULL == pDev)
// 1725   {
// 1726     uint16 rtrn = INVALID_NODE_ADDR;
// 1727     *pBuf++ = LO_UINT16(rtrn);
// 1728     *pBuf++ = HI_UINT16(rtrn);
// 1729   }
// 1730   else
// 1731   {
// 1732     *pBuf++ = LO_UINT16(pDev->shortAddr);
// 1733     *pBuf++ = HI_UINT16(pDev->shortAddr);
// 1734     *pBuf++ = LO_UINT16(pDev->addrIdx);
// 1735     *pBuf++ = HI_UINT16(pDev->addrIdx);
// 1736     *pBuf++ = pDev->nodeRelation;
// 1737     *pBuf++ = pDev->devStatus;
// 1738     *pBuf++ = pDev->assocCnt;
// 1739     *pBuf++ = pDev->age;
// 1740     *pBuf++ = pDev->linkInfo.txCounter;
// 1741     *pBuf++ = pDev->linkInfo.txCost;
// 1742     *pBuf++ = pDev->linkInfo.rxLqi;
// 1743     *pBuf++ = pDev->linkInfo.inKeySeqNum;
// 1744     osal_buffer_uint32( pBuf, pDev->linkInfo.inFrmCntr );
// 1745     *pBuf += 4;
// 1746     *pBuf++ = LO_UINT16(pDev->linkInfo.txFailure);
// 1747     *pBuf++ = HI_UINT16(pDev->linkInfo.txFailure);
// 1748   }
// 1749 }
// 1750 
// 1751 /***************************************************************************************************
// 1752  * @fn      packBindEntry_t
// 1753  *
// 1754  * @brief   Pack a BindingEntry_t structure into a byte buffer (pack INVALID_NODE_ADDR
// 1755  *          as dstIdx if the pBind parameter is NULL).
// 1756  *
// 1757  * @param   pBuf - pointer to the buffer into which to pack the structure.
// 1758  * @param   pBind - pointer to the structure.
// 1759  *
// 1760  * @return  void
// 1761  ***************************************************************************************************/
// 1762 static void packBindEntry_t(uint8 *pBuf, BindingEntry_t *pBind)
// 1763 {
// 1764   if ( NULL == pBind )
// 1765   {
// 1766     uint16 rtrn = INVALID_NODE_ADDR;
// 1767     *pBuf++ = 0xFF;
// 1768     *pBuf++ = 0xFF;
// 1769     *pBuf++ = LO_UINT16(rtrn);
// 1770     *pBuf++ = HI_UINT16(rtrn);
// 1771     *pBuf++ = 0xFF;
// 1772     *pBuf++ = 0xFF;
// 1773 
// 1774   }
// 1775   else
// 1776   {
// 1777     *pBuf++ = pBind->srcEP;
// 1778     *pBuf++ = pBind->dstGroupMode;
// 1779     *pBuf++ = LO_UINT16( pBind->dstIdx );
// 1780     *pBuf++ = HI_UINT16( pBind->dstIdx );
// 1781     *pBuf++ = pBind->dstEP;
// 1782     *pBuf++ = pBind->numClusterIds;
// 1783 
// 1784     osal_memcpy( pBuf, pBind->clusterIdList, pBind->numClusterIds * sizeof(uint16));
// 1785   }
// 1786 }
// 1787 
// 1788 #if defined ZCL_KEY_ESTABLISH
// 1789 /***************************************************************************************************
// 1790  * @fn      MT_UtilzclGeneral_KeyEstablish_InitiateKeyEstablishment
// 1791  *
// 1792  * @brief   Proxy the zclKE_StartDirect() function.
// 1793  *
// 1794  * @param   pBuf - pointer to the received buffer
// 1795  *
// 1796  * @return  void
// 1797  ***************************************************************************************************/
// 1798 static void MT_UtilzclGeneral_KeyEstablish_InitiateKeyEstablishment(uint8 *pBuf)
// 1799 {
// 1800   afAddrType_t partnerAddr;
// 1801   uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
// 1802   pBuf += MT_RPC_FRAME_HDR_SZ;
// 1803 
// 1804   partnerAddr.panId = 0;  // Not an inter-pan message.
// 1805   partnerAddr.endPoint = pBuf[2];
// 1806   partnerAddr.addrMode = afAddr16Bit;
// 1807   partnerAddr.addr.shortAddr = osal_build_uint16( &pBuf[4] );
// 1808 
// 1809   zcl_key_establish_task_id = pBuf[0];
// 1810 
// 1811   *pBuf = zclKE_StartDirect(MT_TaskID, &partnerAddr, pBuf[1], pBuf[3]);
// 1812 
// 1813   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, pBuf);
// 1814 }
// 1815 
// 1816 /***************************************************************************************************
// 1817  * @fn      MT_UtilzclGeneral_KeyEstablishment_ECDSASign
// 1818  *
// 1819  * @brief   Proxy the zclGeneral_KeyEstablishment_ECDSASign() function.
// 1820  *
// 1821  * @param   pBuf - pointer to the received buffer
// 1822  *
// 1823  * @return  void
// 1824  ***************************************************************************************************/
// 1825 static void MT_UtilzclGeneral_KeyEstablishment_ECDSASign(uint8 *pBuf)
// 1826 {
// 1827 #if defined ZCL_KEY_ESTABLISH
// 1828   uint8 *output;
// 1829   uint8 signLen;
// 1830   uint8 cmdId = pBuf[MT_RPC_POS_CMD1];
// 1831   pBuf += MT_RPC_FRAME_HDR_SZ;
// 1832 
// 1833   signLen = zclKE_ECDSASignGetLen(ZCL_KE_SUITE_1);
// 1834 
// 1835   output = osal_mem_alloc(signLen+1);
// 1836 
// 1837   if (NULL == output)
// 1838   {
// 1839     *pBuf = FAILURE;
// 1840     MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId, 1, pBuf);
// 1841   }
// 1842   else
// 1843   {
// 1844     *output = zclKE_ECDSASign(ZCL_KE_SUITE_1, pBuf+1, *pBuf, output+1);
// 1845     MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL), cmdId,
// 1846                                          signLen+1, output);
// 1847     osal_mem_free(output);
// 1848   }
// 1849 #endif
// 1850 }
// 1851 
// 1852 /***************************************************************************************************
// 1853  * @fn      MT_UtilKeyEstablishInd
// 1854  *
// 1855  * @brief   Proxy the ZCL_KEY_ESTABLISH_IND command.
// 1856  *
// 1857  * @param   pInd - Pointer to a zclKE_StatusInd_t structure.
// 1858  *
// 1859  * @return  None
// 1860  ***************************************************************************************************/
// 1861 void MT_UtilKeyEstablishInd(zclKE_StatusInd_t *pInd)
// 1862 {
// 1863   uint8 msg[6];
// 1864 
// 1865   msg[0] = zcl_key_establish_task_id;
// 1866   msg[1] = pInd->hdr.event;
// 1867   msg[2] = pInd->hdr.status;
// 1868   msg[3] = pInd->waitTime;
// 1869   msg[4] = LO_UINT16(pInd->suites);
// 1870   msg[5] = HI_UINT16(pInd->suites);
// 1871 
// 1872   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_AREQ | (uint8)MT_RPC_SYS_UTIL),
// 1873                                        MT_UTIL_ZCL_KEY_ESTABLISH_IND, 6, msg);
// 1874 }
// 1875 #endif
// 1876 
// 1877 /***************************************************************************************************
// 1878  * @fn      MT_UtilSync
// 1879  *
// 1880  * @brief   Process the MT_UTIL_SYNC command
// 1881  *
// 1882  * @param   None
// 1883  *
// 1884  * @return  None
// 1885  ***************************************************************************************************/
// 1886 static void MT_UtilSync(void)
// 1887 {
// 1888  MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_AREQ|(uint8)MT_RPC_SYS_UTIL),MT_UTIL_SYNC_REQ,0,0);
// 1889 }
// 1890 
// 1891 /***************************************************************************************************
// 1892  * @fn          MT_UtilGetDevNwkInfo
// 1893  *
// 1894  * @brief       Handle the Util get device network information.
// 1895  *
// 1896  * @param       pBuf - Pointer to the received message data.
// 1897  *
// 1898  * @return      NULL
// 1899  ***************************************************************************************************/
// 1900 static void MT_UtilGetDevNwkInfo( uint8 *pBuf )
// 1901 {
// 1902   uint8 buf[6];
// 1903   uint8 *pMsg;
// 1904 
// 1905   pMsg = buf;
// 1906 
// 1907   *pMsg++ = LO_UINT16( _NIB.nwkDevAddress );
// 1908   *pMsg++ = HI_UINT16( _NIB.nwkDevAddress );
// 1909   *pMsg++ = LO_UINT16( _NIB.nwkPanId );
// 1910   *pMsg++ = HI_UINT16( _NIB.nwkPanId );
// 1911   *pMsg++ = _NIB.SequenceNum;
// 1912   *pMsg++ = _NIB.nwkLogicalChannel;
// 1913 
// 1914   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL),
// 1915                                        MT_UTIL_GET_DEV_NWK_INFO, 6, buf );
// 1916 }
// 1917 
// 1918 /***************************************************************************************************
// 1919  * @fn          MT_UtiSetDevNwkInfo
// 1920  *
// 1921  * @brief       Handle the Util set device network information.
// 1922  *
// 1923  * @param       pBuf - Pointer to the received message data.
// 1924  *
// 1925  * @return      NULL
// 1926  ***************************************************************************************************/
// 1927 void MT_UtilSetDevNwkInfo( uint8 *pBuf )
// 1928 {
// 1929   uint8 *pMsg;
// 1930   uint8 status = 0;
// 1931   
// 1932   pBuf += MT_RPC_FRAME_HDR_SZ;
// 1933   pMsg = pBuf;
// 1934 
// 1935   _NIB.nwkDevAddress = osal_build_uint16(pMsg);
// 1936   pMsg += 2;
// 1937   _NIB.nwkPanId = osal_build_uint16(pMsg);
// 1938   pMsg += 2;
// 1939   _NIB.SequenceNum = *pMsg++;
// 1940   _NIB.nwkLogicalChannel = *pMsg++;
// 1941 
// 1942   MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_UTIL),
// 1943                                        MT_UTIL_GET_DEV_NWK_INFO, 1, &status );
// 1944 }
// 1945 #endif /* !defined NONWK */
// 1946 #endif /* MT_UTIL_FUNC */
// 1947 /**************************************************************************************************
// 1948  **************************************************************************************************/
// 
//
// 
//
//
//Errors: none
//Warnings: none
