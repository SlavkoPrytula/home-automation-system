###############################################################################
#
# IAR C/C++ Compiler V10.30.1.6000 for 8051               19/Apr/2021  17:31:12
# Copyright 2004-2018 IAR Systems AB.
# Evaluation license - IAR Embedded Workbench for 8051, Evaluation edition 10.30
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Components\stack\zcl\zcl_general.c
#    Command line       =  
#        -f C:\users\slavko\Temp\EW251b.tmp ("C:\Texas Instruments\Z-Stack
#        3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Components\stack\zcl\zcl_general.c" -D BDB_REPORTING -D SECURE=1
#        -D TC_LINKKEY_JOIN -D NV_INIT -D NV_RESTORE -D xPOWER_SAVING -D
#        NWK_AUTO_POLL -D xZTOOL_P1 -D xMT_TASK -D xMT_APP_FUNC -D xMT_SYS_FUNC
#        -D xMT_ZDO_FUNC -D xMT_ZDO_MGMT -D xMT_APP_CNF_FUNC -D
#        LCD_SUPPORTED=DEBUG -D MULTICAST_ENABLED=FALSE -D ZCL_READ -D
#        ZCL_DISCOVER -D ZCL_WRITE -D ZCL_BASIC -D ZCL_IDENTIFY -D ZCL_ON_OFF
#        -D ZCL_SCENES -D ZCL_GROUPS -D ZCL_LEVEL_CTRL -lC "C:\Texas
#        Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\EndDeviceEB\List"
#        -lA "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\EndDeviceEB\List"
#        --diag_suppress Pe001,Pa010 -o "C:\Texas Instruments\Z-Stack
#        3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\EndDeviceEB\Obj"
#        -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data_rom --nr_virtual_regs 16 -f "C:\Texas
#        Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\Tools\CC2530DB\f8wEndev.cfg"
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_TX_DATA_MAX=3
#        -DMAC_CFG_TX_MAX=6 -DMAC_CFG_RX_MAX=3) -f "C:\Texas
#        Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg"
#        (-DZIGBEEPRO -DSECURE=1 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 -DDEFAULT_KEY={0} -DMAC_MAX_FRAME_SIZE=116
#        -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const __code"
#        -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000
#        -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100 -DREJOIN_POLL_RATE=440
#        -DREJOIN_BACKOFF=900000 -DREJOIN_SCAN=900000 -DENABLE_LED4_DISABLE_S1)
#        -f "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\Tools\CC2530DB\f8wZCL.cfg"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\" -I
#        "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\Source\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\Source\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\ZMain\TI2530DB\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\hal\include\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\mac\include\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\mac\high_level\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\single_chip\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\mt\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\osal\include\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\services\saddr\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\services\sdata\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\af\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\bdb\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\gp\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\nwk\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\sapi\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\sec\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\sys\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\zcl\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\zdo\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\zmac\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\zmac\f8w\"
#        -Ohz --require_prototypes)
#    Locale             =  English_USA.1252
#    List file          =  
#        C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\EndDeviceEB\List\zcl_general.lst
#    Object file        =  
#        C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\EndDeviceEB\Obj\zcl_general.r51
#
###############################################################################

C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack 3.0.2\Components\stack\zcl\zcl_general.c
      1          /**************************************************************************************************
      2            Filename:       zcl_general.c
      3            Revised:        $Date: 2010-11-09 15:38:54 -0800 (Tue, 09 Nov 2010) $
      4            Revision:       $Revision: 24374 $
      5          
      6            Description:    Zigbee Cluster Library - General.  This application receives all
      7                            ZCL messages and initially parses them before passing to application.
      8          
      9          
     10            Copyright 2006-2010 Texas Instruments Incorporated. All rights reserved.
     11          
     12            IMPORTANT: Your use of this Software is limited to those specific rights
     13            granted under the terms of a software license agreement between the user
     14            who downloaded the software, his/her employer (which must be your employer)
     15            and Texas Instruments Incorporated (the "License").  You may not use this
     16            Software unless you agree to abide by the terms of the License. The License
     17            limits your use, and you acknowledge, that the Software may not be modified,
     18            copied or distributed unless embedded on a Texas Instruments microcontroller
     19            or used solely and exclusively in conjunction with a Texas Instruments radio
     20            frequency transceiver, which is integrated into your product.  Other than for
     21            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     22            works of, modify, distribute, perform, display or sell this Software and/or
     23            its documentation for any purpose.
     24          
     25            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     26            PROVIDED AS IS WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     27            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     28            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     29            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     30            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     31            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     32            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     33            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     34            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     35            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     36          
     37            Should you have any questions regarding your right to use this Software,
     38            contact Texas Instruments Incorporated at www.TI.com.
     39          **************************************************************************************************/
     40          
     41          /*********************************************************************
     42           * INCLUDES
     43           */
     44          #include "ZComDef.h"
     45          #include "OSAL.h"
     46          #include "OSAL_Nv.h"
     47          #include "zcl.h"
     48          #include "zcl_general.h"
     49          #include "ZDApp.h"
     50          
     51          #if defined ( INTER_PAN )
     52            #include "stub_aps.h"
     53          #endif
     54          
     55          /*********************************************************************
     56           * MACROS
     57           */
     58          #define locationTypeAbsolute( a )          ( (a) & LOCATION_TYPE_ABSOLUTE )
     59          #define locationType2D( a )                ( (a) & LOCATION_TYPE_2_D )
     60          #define locationTypeCoordinateSystem( a )  ( (a) & LOCATION_TYPE_COORDINATE_SYSTEM )
     61          
     62          #ifdef ZCL_SCENES
     63          #define zclGeneral_ScenesRemaingCapacity() ( ZCL_GEN_MAX_SCENES - zclGeneral_CountAllScenes() )
     64          #endif // ZCL_SCENES
     65          
     66          /*********************************************************************
     67           * CONSTANTS
     68           */
     69          
     70          /*********************************************************************
     71           * TYPEDEFS
     72           */
     73          typedef struct zclGenCBRec
     74          {
     75            struct zclGenCBRec        *next;
     76            uint8                     endpoint; // Used to link it into the endpoint descriptor
     77            zclGeneral_AppCallbacks_t *CBs;     // Pointer to Callback function
     78          } zclGenCBRec_t;
     79          
     80          typedef struct zclGenSceneItem
     81          {
     82            struct zclGenSceneItem    *next;
     83            uint8                     endpoint; // Used to link it into the endpoint descriptor
     84            zclGeneral_Scene_t        scene;    // Scene info
     85          } zclGenSceneItem_t;
     86          
     87          typedef struct zclGenAlarmItem
     88          {
     89            struct zclGenAlarmItem    *next;
     90            uint8                     endpoint; // Used to link it into the endpoint descriptor
     91            zclGeneral_Alarm_t        alarm;    // Alarm info
     92          } zclGenAlarmItem_t;
     93          
     94          // Scene NV types
     95          typedef struct
     96          {
     97            uint16                    numRecs;
     98          } nvGenScenesHdr_t;
     99          
    100          typedef struct zclGenSceneNVItem
    101          {
    102            uint8                     endpoint;
    103            zclGeneral_Scene_t        scene;
    104          } zclGenSceneNVItem_t;
    105          
    106          /*********************************************************************
    107           * GLOBAL VARIABLES
    108           */
    109          
    110          /*********************************************************************
    111           * GLOBAL FUNCTIONS
    112           */
    113          
    114          /*********************************************************************
    115           * LOCAL VARIABLES
    116           */
    117          static zclGenCBRec_t *zclGenCBs = (zclGenCBRec_t *)NULL;
    118          static uint8 zclGenPluginRegisted = FALSE;
    119          #ifdef ZCL_SCENES
    120          static zclGenSceneItem_t *zclGenSceneTable = (zclGenSceneItem_t *)NULL;
    121          #endif // ZCL_SCENES
    122          #ifdef ZCL_ALARMS
    123          static zclGenAlarmItem_t *zclGenAlarmTable = (zclGenAlarmItem_t *)NULL;
    124          #endif // ZCL_ALARMS
    125          
    126          /*********************************************************************
    127           * LOCAL FUNCTIONS
    128           */
    129          static ZStatus_t zclGeneral_HdlIncoming( zclIncoming_t *pInMsg );
    130          static ZStatus_t zclGeneral_HdlInSpecificCommands( zclIncoming_t *pInMsg );
    131          static zclGeneral_AppCallbacks_t *zclGeneral_FindCallbacks( uint8 endpoint );
    132          
    133          // Device Configuration and Installation clusters
    134          #ifdef ZCL_BASIC
    135          static ZStatus_t zclGeneral_ProcessInBasic( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    136          #endif // ZCL_BASIC
    137          
    138          #ifdef ZCL_IDENTIFY
    139          static ZStatus_t zclGeneral_ProcessInIdentity( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    140          #endif // ZCL_IDENTIFY
    141          
    142          // Groups and Scenes clusters
    143          #ifdef ZCL_GROUPS
    144          static ZStatus_t zclGeneral_ProcessInGroupsServer( zclIncoming_t *pInMsg );
    145          static ZStatus_t zclGeneral_ProcessInGroupsClient( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    146          static ZStatus_t zclGeneral_AddGroup( uint8 endPoint, aps_Group_t *group, uint8 *pData );
    147          #endif // ZCL_GROUPS
    148          
    149          #ifdef ZCL_SCENES
    150          static ZStatus_t zclGeneral_ProcessInScenesServer( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    151          static ZStatus_t zclGeneral_ProcessInScenesClient( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    152          #endif // ZCL_SCENES
    153          
    154          // On/Off and Level Control Configuration clusters
    155          #ifdef ZCL_ON_OFF
    156          static ZStatus_t zclGeneral_ProcessInOnOff( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    157          #endif // ZCL_ONOFF
    158          
    159          #ifdef ZCL_LEVEL_CTRL
    160          static ZStatus_t zclGeneral_ProcessInLevelControl( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    161          #endif // ZCL_LEVEL_CTRL
    162          
    163          // Alarms cluster
    164          #ifdef ZCL_ALARMS
    165          static ZStatus_t zclGeneral_ProcessInAlarmsServer( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    166          static ZStatus_t zclGeneral_ProcessInAlarmsClient( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    167          #endif // ZCL_ALARMS
    168          
    169          // Location cluster
    170          #ifdef ZCL_LOCATION
    171          static ZStatus_t zclGeneral_ProcessInLocationServer( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    172          static ZStatus_t zclGeneral_ProcessInLocationClient( zclIncoming_t *pInMsg, zclGeneral_AppCallbacks_t *pCBs );
    173          #endif // ZCL_LOCATION
    174          
    175          #ifdef ZCL_SCENES
    176          static uint8 zclGeneral_ScenesInitNV( void );
    177          static void zclGeneral_ScenesSetDefaultNV( void );
    178          static void zclGeneral_ScenesWriteNV( void );
    179          static uint16 zclGeneral_ScenesRestoreFromNV( void );
    180          #endif // ZCL_SCENES
    181          
    182          /*********************************************************************
    183           * @fn      zclGeneral_RegisterCmdCallbacks
    184           *
    185           * @brief   Register an applications command callbacks
    186           *
    187           * @param   endpoint - application's endpoint
    188           * @param   callbacks - pointer to the callback record.
    189           *
    190           * @return  ZMemError if not able to allocate
    191           */
    192          ZStatus_t zclGeneral_RegisterCmdCallbacks( uint8 endpoint, zclGeneral_AppCallbacks_t *callbacks )
    193          {
    194            zclGenCBRec_t *pNewItem;
    195            zclGenCBRec_t *pLoop;
    196          
    197            // Register as a ZCL Plugin
    198            if ( zclGenPluginRegisted == FALSE )
    199            {
    200              zcl_registerPlugin( ZCL_CLUSTER_ID_GEN_BASIC,
    201                                  ZCL_CLUSTER_ID_GEN_MULTISTATE_VALUE_BASIC,
    202                                  zclGeneral_HdlIncoming );
    203          
    204          #ifdef ZCL_SCENES
    205              // Initialize NV items
    206              zclGeneral_ScenesInitNV();
    207          
    208              // Restore the Scene table
    209              zclGeneral_ScenesRestoreFromNV();
    210          #endif // ZCL_SCENES
    211          
    212              zclGenPluginRegisted = TRUE;
    213            }
    214          
    215            // Fill in the new profile list
    216            pNewItem = osal_mem_alloc( sizeof( zclGenCBRec_t ) );
    217            if ( pNewItem == NULL )
    218              return (ZMemError);
    219          
    220            pNewItem->next = (zclGenCBRec_t *)NULL;
    221            pNewItem->endpoint = endpoint;
    222            pNewItem->CBs = callbacks;
    223          
    224            // Find spot in list
    225            if (  zclGenCBs == NULL )
    226            {
    227              zclGenCBs = pNewItem;
    228            }
    229            else
    230            {
    231              // Look for end of list
    232              pLoop = zclGenCBs;
    233              while ( pLoop->next != NULL )
    234                pLoop = pLoop->next;
    235          
    236              // Put new item at end of list
    237              pLoop->next = pNewItem;
    238            }
    239          
    240            return ( ZSuccess );
    241          }
    242          
    243          #ifdef ZCL_IDENTIFY
    244          /*********************************************************************
    245           * @fn      zclGeneral_SendIdentify
    246           *
    247           * @brief   Call to send out an Identify Command
    248           *
    249           * @param   srcEP - Sending application's endpoint
    250           * @param   dstAddr - where you want the message to go
    251           * @param   identifyTime - how long the device will continue to identify itself (in seconds)
    252           * @param   seqNum - identification number for the transaction
    253           *
    254           * @return  ZStatus_t
    255           */
    256          ZStatus_t zclGeneral_SendIdentify( uint8 srcEP, afAddrType_t *dstAddr,
    257                                uint16 identifyTime, uint8 disableDefaultRsp, uint8 seqNum )
    258          {
    259            uint8 buf[2];
    260          
    261            buf[0] = LO_UINT16( identifyTime );
    262            buf[1] = HI_UINT16( identifyTime );
    263          
    264            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_IDENTIFY,
    265                                    COMMAND_IDENTIFY, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    266                                    disableDefaultRsp, 0, seqNum, 2, buf );
    267          }
    268          
    269          /*********************************************************************
    270           * @fn      zclGeneral_SendIdentifyQueryResponse
    271           *
    272           * @brief   Call to send out an Identify Query Response Command
    273           *
    274           * @param   srcEP - Sending application's endpoint
    275           * @param   dstAddr - where you want the message to go
    276           * @param   timeout - how long the device will continue to identify itself (in seconds)
    277           * @param   seqNum - identification number for the transaction
    278           *
    279           * @return  ZStatus_t
    280           */
    281          ZStatus_t zclGeneral_SendIdentifyQueryResponse( uint8 srcEP, afAddrType_t *dstAddr,
    282                                      uint16 timeout, uint8 disableDefaultRsp, uint8 seqNum )
    283          {
    284            uint8 buf[2];
    285          
    286            buf[0] = LO_UINT16( timeout );
    287            buf[1] = HI_UINT16( timeout );
    288          
    289            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_IDENTIFY,
    290                                    COMMAND_IDENTIFY_QUERY_RSP, TRUE,
    291                                    ZCL_FRAME_SERVER_CLIENT_DIR, disableDefaultRsp, 0, seqNum, 2, buf );
    292          }
    293          #endif // ZCL_IDENTIFY
    294          
    295          #ifdef ZCL_GROUPS
    296          /*********************************************************************
    297           * @fn      zclGeneral_SendGroupRequest
    298           *
    299           * @brief   Send a Group Request to a device.  You can also use the
    300           *          appropriate macro.
    301           *
    302           * @param   srcEP - Sending Apps endpoint
    303           * @param   dstAddr - where to send the request
    304           * @param   cmd - one of the following:
    305           *              COMMAND_GROUP_VIEW
    306           *              COMMAND_GROUP_REMOVE
    307           * @param   groupID -
    308           *
    309           * @return  ZStatus_t
    310           */
    311          ZStatus_t zclGeneral_SendGroupRequest( uint8 srcEP, afAddrType_t *dstAddr,
    312                               uint8 cmd, uint16 groupID, uint8 disableDefaultRsp, uint8 seqNum )
    313          {
    314            uint8 buf[2];
    315          
    316            buf[0] = LO_UINT16( groupID );
    317            buf[1] = HI_UINT16( groupID );
    318          
    319            return ( zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
    320                                      cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    321                                      disableDefaultRsp, 0, seqNum, 2, buf ) );
    322          }
    323          
    324          /*********************************************************************
    325           * @fn      zclGeneral_SendAddGroupRequest
    326           *
    327           * @brief   Send the Add Group Request to a device
    328           *
    329           * @param   srcEP - Sending Apps endpoint
    330           * @param   dstAddr - where to send the request
    331           * @param   cmd - one of the following:
    332           *                COMMAND_GROUP_ADD
    333           *                COMMAND_GROUP_ADD_IF_IDENTIFYING
    334           * @param   groupID - pointer to the group structure
    335           * @param   groupName - pointer to Group Name.  This is a Zigbee
    336           *          string data type, so the first byte is the length of the
    337           *          name (in bytes), then the name.
    338           *
    339           * @return  ZStatus_t
    340           */
    341          ZStatus_t zclGeneral_SendAddGroupRequest( uint8 srcEP, afAddrType_t *dstAddr,
    342                                                    uint8 cmd, uint16 groupID, uint8 *groupName,
    343                                                    uint8 disableDefaultRsp, uint8 seqNum )
    344          {
    345            uint8 *buf;
    346            uint8 *pBuf;
    347            uint8 len;
    348            ZStatus_t status;
    349          
    350            len = 2;    // Group ID
    351            len += groupName[0] + 1;  // String + 1 for length
    352          
    353            buf = osal_mem_alloc( len );
    354            if ( buf )
    355            {
    356              pBuf = buf;
    357              *pBuf++ = LO_UINT16( groupID );
    358              *pBuf++ = HI_UINT16( groupID );
    359              *pBuf++ = groupName[0]; // string length
    360              osal_memcpy( pBuf, &(groupName[1]), groupName[0] );
    361          
    362              status = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
    363                                        cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    364                                        disableDefaultRsp, 0, seqNum, len, buf );
    365              osal_mem_free( buf );
    366            }
    367            else
    368              status = ZMemError;
    369          
    370            return ( status );
    371          }
    372          
    373          /*********************************************************************
    374           * @fn      zclGeneral_SendGroupGetMembershipRequest
    375           *
    376           * @brief   Send a Get Group Membership (Resposne) Command to a device
    377           *
    378           * @param   srcEP - Sending Apps endpoint
    379           * @param   dstAddr - where to send the request
    380           * @param   cmd - one of the following:
    381           *                COMMAND_GROUP_GET_MEMBERSHIP
    382           *                COMMAND_GROUP_GET_MEMBERSHIP_RSP
    383           * @param   groupID - pointer to the group structure
    384           * @param   groupName - pointer to Group Name.  This is a Zigbee
    385           *          string data type, so the first byte is the length of the
    386           *          name (in bytes), then the name.
    387           *
    388           * @return  ZStatus_t
    389           */
    390          ZStatus_t zclGeneral_SendGroupGetMembershipRequest( uint8 srcEP, afAddrType_t *dstAddr,
    391                                        uint8 cmd, uint8 rspCmd, uint8 direction, uint8 capacity,
    392                                        uint8 grpCnt, uint16 *grpList, uint8 disableDefaultRsp, uint8 seqNum )
    393          {
    394            uint8 *buf;
    395            uint8 *pBuf;
    396            uint8 len = 0;
    397            uint8 i;
    398            ZStatus_t status;
    399          
    400            if ( rspCmd )
    401              len++;  // Capacity
    402          
    403            len++;  // Group Count
    404            len += sizeof ( uint16 ) * grpCnt;  // Group List
    405          
    406            buf = osal_mem_alloc( len );
    407            if ( buf )
    408            {
    409              pBuf = buf;
    410              if ( rspCmd )
    411                *pBuf++ = capacity;
    412          
    413              *pBuf++ = grpCnt;
    414              for ( i = 0; i < grpCnt; i++ )
    415              {
    416                *pBuf++ = LO_UINT16( grpList[i] );
    417                *pBuf++ = HI_UINT16( grpList[i] );
    418              }
    419          
    420              status = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
    421                                        cmd, TRUE, direction,
    422                                        disableDefaultRsp, 0, seqNum, len, buf );
    423              osal_mem_free( buf );
    424            }
    425            else
    426              status = ZMemError;
    427          
    428            return ( status );
    429          }
    430          
    431          /*********************************************************************
    432           * @fn      zclGeneral_SendGroupResponse
    433           *
    434           * @brief   Send Group Response (not Group View Response)
    435           *
    436           * @param   srcEP - Sending application's endpoint
    437           * @param   dstAddr - where you want the message to go
    438           * @param   cmd - either COMMAND_GROUP_ADD_RSP or COMMAND_GROUP_REMOVE_RSP
    439           * @param   status - group command status
    440           * @param   groupID - what group
    441           *
    442           * @return  ZStatus_t
    443           */
    444          ZStatus_t zclGeneral_SendGroupResponse( uint8 srcEP, afAddrType_t *dstAddr,
    445                                                  uint8 cmd, uint8 status, uint16 groupID,
    446                                                  uint8 disableDefaultRsp, uint8 seqNum )
    447          {
    448            uint8 buf[3];
    449          
    450            buf[0] = status;
    451            buf[1] = LO_UINT16( groupID );
    452            buf[2] = HI_UINT16( groupID );
    453          
    454            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
    455                                    cmd, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
    456                                    disableDefaultRsp, 0, seqNum, 3, buf );
    457          }
    458          
    459          /*********************************************************************
    460           * @fn      zclGeneral_SendGroupViewResponse
    461           *
    462           * @brief   Call to send Group Response Command
    463           *
    464           * @param   srcEP - Sending application's endpoint
    465           * @param   dstAddr - where you want the message to go
    466           * @param   cmd - either COMMAND_GROUP_ADD_RSP or COMMAND_GROUP_REMOVE_RSP
    467           * @param   status - group command status
    468           * @param   grp - group info
    469           *
    470           * @return  ZStatus_t
    471           */
    472          ZStatus_t zclGeneral_SendGroupViewResponse( uint8 srcEP, afAddrType_t *dstAddr,
    473                           uint8 status, aps_Group_t *grp, uint8 disableDefaultRsp, uint8 seqNum )
    474          {
    475            uint8 *buf;
    476            uint8 len;
    477            ZStatus_t stat;
    478          
    479            len = 1 + 2; // Status + Group ID
    480          
    481            if ( status == ZCL_STATUS_SUCCESS )
    482              len += grp->name[0] + 1;  // String + 1 for length
    483          
    484            buf = osal_mem_alloc( len );
    485            if ( buf )
    486            {
    487              buf[0] = status;
    488              buf[1] = LO_UINT16( grp->ID );
    489              buf[2] = HI_UINT16( grp->ID );
    490          
    491              if ( status == ZCL_STATUS_SUCCESS )
    492              {
    493                buf[3] = grp->name[0]; // string length
    494                osal_memcpy( &buf[4], (&grp->name[1]), grp->name[0] );
    495              }
    496          
    497              stat = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_GROUPS,
    498                                      COMMAND_GROUP_VIEW_RSP, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
    499                                      disableDefaultRsp, 0, seqNum, len, buf );
    500              osal_mem_free( buf );
    501            }
    502            else
    503              stat = ZMemError;
    504          
    505            return ( stat );
    506          }
    507          #endif // ZCL_GROUPS
    508          
    509          #ifdef ZCL_SCENES
    510          /*********************************************************************
    511           * @fn      zclGeneral_SendAddScene
    512           *
    513           * @brief   Send the Add Scene Request to a device
    514           *
    515           * @param   srcEP - Sending Apps endpoint
    516           * @param   dstAddr - where to send the request
    517           * @param   scene - pointer to the scene structure
    518           *
    519           * @return  ZStatus_t
    520           */
    521          ZStatus_t zclGeneral_SendAddScene( uint8 srcEP, afAddrType_t *dstAddr,
                           ^
Error[Pe079]: expected a type specifier

  ZStatus_t zclGeneral_SendAddScene( uint8 srcEP, afAddrType_t *dstAddr,
            ^
"C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack 3.0.2\Components\stack\zcl\zcl_general.c",521  Error[Pe079]: 
          expected a type specifier

  ZStatus_t zclGeneral_SendAddScene( uint8 srcEP, afAddrType_t *dstAddr,
            ^
"C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack 3.0.2\Components\stack\zcl\zcl_general.c",521  Error[Pe079]: 
          expected a type specifier

  ZStatus_t zclGeneral_SendAddScene( uint8 srcEP, afAddrType_t *dstAddr,
            ^
"C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack 3.0.2\Components\stack\zcl\zcl_general.c",521  Error[Pe079]: 
          expected a type specifier

  ZStatus_t zclGeneral_SendAddScene( uint8 srcEP, afAddrType_t *dstAddr,
            ^
"C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack 3.0.2\Components\stack\zcl\zcl_general.c",521  Error[Pe079]: 
          expected a type specifier

  ZStatus_t zclGeneral_SendAddScene( uint8 srcEP, afAddrType_t *dstAddr,
            ^
"C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack 3.0.2\Components\stack\zcl\zcl_general.c",521  Error[Pe079]: 
          expected a type specifier

  ZStatus_t zclGeneral_SendAddScene( uint8 srcEP, afAddrType_t *dstAddr,
            ^
"C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack 3.0.2\Components\stack\zcl\zcl_general.c",521  Error[Pe147]: 
          declaration is incompatible with "uint8
          zclGeneral_SendAddSceneRequest(<error-type>, <error-type>,
          <error-type>, <error-type>, <error-type>, <error-type>)" (declared at
          line 521)

  ZStatus_t zclGeneral_SendAddScene( uint8 srcEP, afAddrType_t *dstAddr,
            ^
"C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack 3.0.2\Components\stack\zcl\zcl_general.c",521  Error[Pe141]: 
          unnamed prototyped parameters not allowed when body is present
    522                                zclGeneral_Scene_t *scene, uint8 disableDefaultRsp, uint8 seqNum )
    523          {
    524            uint8 *buf;
    525            uint8 *pBuf;
    526            uint8 len;
    527            ZStatus_t status;
    528          
    529            len = 2 + 1 + 2;    // Group ID + Scene ID + transition time
    530            len += scene->name[0] + 1; // String + 1 for length
                          ^
Error[Pe020]: identifier "scene" is undefined
    531          
    532            // Add something for the extension field length
    533            len += scene->extLen;
    534          
    535            buf = osal_mem_alloc( len );
    536            if ( buf )
    537            {
    538              pBuf = buf;
    539              *pBuf++ = LO_UINT16( scene->groupID );
    540              *pBuf++ = HI_UINT16( scene->groupID );
    541              *pBuf++ = scene->ID;
    542              *pBuf++ = LO_UINT16( scene->transTime );
    543              *pBuf++ = HI_UINT16( scene->transTime );
    544              *pBuf++ = scene->name[0]; // string length
    545              osal_memcpy( pBuf, &(scene->name[1]), scene->name[0] );
    546              pBuf += scene->name[0]; // move pass name
    547          
    548              // Add the extension fields
    549              if ( scene->extLen > 0 )
    550                osal_memcpy( pBuf, scene->extField, scene->extLen );
    551          
    552              status = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
                                               ^
Error[Pe020]: identifier "srcEP" is undefined

      status = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
                                       ^
"C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack 3.0.2\Components\stack\zcl\zcl_general.c",552  Error[Pe020]: 
          identifier "dstAddr" is undefined
    553                                        COMMAND_SCENE_ADD, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    554                                        disableDefaultRsp, 0, seqNum, len, buf );
                                               ^
Error[Pe020]: identifier "disableDefaultRsp" is undefined

                                disableDefaultRsp, 0, seqNum, len, buf );
                                                      ^
"C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack 3.0.2\Components\stack\zcl\zcl_general.c",554  Error[Pe020]: 
          identifier "seqNum" is undefined
    555              osal_mem_free( buf );
    556            }
    557            else
    558              status = ZMemError;
    559          
    560            return ( status );
    561          }
    562          
    563          /*********************************************************************
    564           * @fn      zclGeneral_SendSceneRequest
    565           *
    566           * @brief   Send a Scene Request to a device.  You can also use the
    567           *          appropriate macro.
    568           *
    569           * @param   srcEP - Sending Apps endpoint
    570           * @param   dstAddr - where to send the request
    571           * @param   cmd - one of the following:
    572           *              COMMAND_SCENE_VIEW
    573           *              COMMAND_SCENE_REMOVE
    574           *              COMMAND_SCENE_REMOVE_ALL
    575           *              COMMAND_SCENE_STORE
    576           *              COMMAND_SCENE_RECALL
    577           *              COMMAND_SCENE_GET_MEMBERSHIP
    578           * @param   groupID - group ID
    579           * @param   sceneID - scene ID (not applicable to COMMAND_SCENE_REMOVE_ALL and
    580           *                    COMMAND_SCENE_GET_MEMBERSHIP)
    581           * @return  ZStatus_t
    582           */
    583          ZStatus_t zclGeneral_SendSceneRequest( uint8 srcEP, afAddrType_t *dstAddr,
    584                                                 uint8 cmd, uint16 groupID, uint8 sceneID,
    585                                                 uint8 disableDefaultRsp, uint8 seqNum )
    586          {
    587            uint8 buf[3];
    588            uint8 len = 2;
    589          
    590            buf[0] = LO_UINT16( groupID );
    591            buf[1] = HI_UINT16( groupID );
    592          
    593            if ( cmd != COMMAND_SCENE_REMOVE_ALL && cmd != COMMAND_SCENE_GET_MEMBERSHIP )
    594            {
    595              buf[2] = sceneID;
    596              len++;
    597            }
    598          
    599            return ( zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
    600                                      cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    601                                      disableDefaultRsp, 0, seqNum, len, buf ) );
    602          }
    603          
    604          /*********************************************************************
    605           * @fn      zclGeneral_SendSceneResponse
    606           *
    607           * @brief   Send Group Response (not Group View Response)
    608           *
    609           * @param   srcEP - Sending application's endpoint
    610           * @param   dstAddr - where you want the message to go
    611           * @param   cmd - either COMMAND_SCENE_ADD_RSP, COMMAND_SCENE_REMOVE_RSP
    612           *                COMMAND_SCENE_STORE_RSP, or COMMAND_SCENE_REMOVE_ALL_RSP
    613           * @param   status - scene command status
    614           * @param   groupID - what group
    615           * @param   sceneID - what scene (not applicable to COMMAND_SCENE_REMOVE_ALL_RSP)
    616           *
    617           * @return  ZStatus_t
    618           */
    619          ZStatus_t zclGeneral_SendSceneResponse( uint8 srcEP, afAddrType_t *dstAddr,
    620                                            uint8 cmd, uint8 status, uint16 groupID,
    621                                            uint8 sceneID, uint8 disableDefaultRsp, uint8 seqNum )
    622          {
    623            uint8 buf[4];
    624            uint8 len = 1 + 2; // Status + Group ID
    625          
    626            buf[0] = status;
    627            buf[1] = LO_UINT16( groupID );
    628            buf[2] = HI_UINT16( groupID );
    629          
    630            if ( cmd != COMMAND_SCENE_REMOVE_ALL_RSP )
    631            {
    632              buf[3] = sceneID;
    633              len++;
    634            }
    635          
    636            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
    637                                    cmd, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
    638                                    disableDefaultRsp, 0, seqNum, len, buf );
    639          }
    640          
    641          /*********************************************************************
    642           * @fn      zclGeneral_SendSceneViewResponse
    643           *
    644           * @brief   Call to send Scene Response Command
    645           *
    646           * @param   srcEP - Sending application's endpoint
    647           * @param   dstAddr - where you want the message to go
    648           * @param   status - scene command status
    649           * @param   scene - scene info
    650           *
    651           * @return  ZStatus_t
    652           */
    653          ZStatus_t zclGeneral_SendSceneViewResponse( uint8 srcEP, afAddrType_t *dstAddr,
                           ^
Error[Pe079]: expected a type specifier

  ZStatus_t zclGeneral_SendSceneViewResponse( uint8 srcEP, afAddrType_t *dstAddr,
            ^
"C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack 3.0.2\Components\stack\zcl\zcl_general.c",653  Error[Pe079]: 
          expected a type specifier

  ZStatus_t zclGeneral_SendSceneViewResponse( uint8 srcEP, afAddrType_t *dstAddr,
            ^
"C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack 3.0.2\Components\stack\zcl\zcl_general.c",653  Error[Pe079]: 
          expected a type specifier

  ZStatus_t zclGeneral_SendSceneViewResponse( uint8 srcEP, afAddrType_t *dstAddr,
            ^
"C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack 3.0.2\Components\stack\zcl\zcl_general.c",653  Error[Pe079]: 
          expected a type specifier

  ZStatus_t zclGeneral_SendSceneViewResponse( uint8 srcEP, afAddrType_t *dstAddr,
            ^
"C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack 3.0.2\Components\stack\zcl\zcl_general.c",653  Error[Pe079]: 
          expected a type specifier

  ZStatus_t zclGeneral_SendSceneViewResponse( uint8 srcEP, afAddrType_t *dstAddr,
            ^
"C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack 3.0.2\Components\stack\zcl\zcl_general.c",653  Error[Pe079]: 
          expected a type specifier

  ZStatus_t zclGeneral_SendSceneViewResponse( uint8 srcEP, afAddrType_t *dstAddr,
            ^
"C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack 3.0.2\Components\stack\zcl\zcl_general.c",653  Error[Pe079]: 
          expected a type specifier

  ZStatus_t zclGeneral_SendSceneViewResponse( uint8 srcEP, afAddrType_t *dstAddr,
            ^
"C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack 3.0.2\Components\stack\zcl\zcl_general.c",653  Error[Pe147]: 
          declaration is incompatible with "uint8
          zclGeneral_SendSceneViewRsp(<error-type>, <error-type>, <error-type>,
          <error-type>, <error-type>, <error-type>, <error-type>)" (declared at
          line 653)

  ZStatus_t zclGeneral_SendSceneViewResponse( uint8 srcEP, afAddrType_t *dstAddr,
            ^
"C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack 3.0.2\Components\stack\zcl\zcl_general.c",653  Error[Pe141]: 
          unnamed prototyped parameters not allowed when body is present
    654                                                 uint8 status, zclGeneral_Scene_t *scene,
    655                                                 uint8 disableDefaultRsp, uint8 seqNum )
    656          {
    657            uint8 *buf;
    658            uint8 *pBuf;
    659            uint8 len = 1 + 2 + 1; // Status + Group ID + Scene ID
    660            ZStatus_t stat;
    661          
    662            if ( status == ZCL_STATUS_SUCCESS )
                        ^
Error[Pe020]: identifier "status" is undefined
    663            {
    664              len += 2; // Transition Time
    665              len += scene->name[0] + 1; // string + 1 for length
                            ^
Error[Pe020]: identifier "scene" is undefined
    666          
    667              // Add something for the extension field length
    668              len += scene->extLen;
    669            }
    670          
    671            buf = osal_mem_alloc( len );
    672            if ( buf )
    673            {
    674              pBuf = buf;
    675              *pBuf++ = status;
                               ^
Error[Pe020]: identifier "status" is undefined
    676              *pBuf++ = LO_UINT16( scene->groupID );
                                          ^
Error[Pe020]: identifier "scene" is undefined
    677              *pBuf++ = HI_UINT16( scene->groupID );
    678              *pBuf++ = scene->ID;
    679              if ( status == ZCL_STATUS_SUCCESS )
    680              {
    681                *pBuf++ = LO_UINT16( scene->transTime );
    682                *pBuf++ = HI_UINT16( scene->transTime );
    683                *pBuf++ = scene->name[0]; // string length
    684                if ( scene->name[0] != 0 )
    685                {
    686                  osal_memcpy( pBuf, &(scene->name[1]), scene->name[0] );
    687                  pBuf += scene->name[0]; // move pass name
    688                }
    689          
    690                // Add the extension fields
    691                if ( scene->extLen > 0 )
    692                  osal_memcpy( pBuf, scene->extField, scene->extLen );
    693              }
    694          
    695              stat = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
                                             ^
Error[Pe020]: identifier "srcEP" is undefined

      stat = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
                                     ^
"C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack 3.0.2\Components\stack\zcl\zcl_general.c",695  Error[Pe020]: 
          identifier "dstAddr" is undefined
    696                                      COMMAND_SCENE_VIEW_RSP, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
    697                                      disableDefaultRsp, 0, seqNum, len, buf );
                                             ^
Error[Pe020]: identifier "disableDefaultRsp" is undefined

                              disableDefaultRsp, 0, seqNum, len, buf );
                                                    ^
"C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack 3.0.2\Components\stack\zcl\zcl_general.c",697  Error[Pe020]: 
          identifier "seqNum" is undefined
    698              osal_mem_free( buf );
    699            }
    700            else
    701              stat = ZMemError;
    702          
    703            return ( stat );
    704          }
    705          
    706          /*********************************************************************
    707           * @fn      zclGeneral_SendSceneGetMembershipResponse
    708           *
    709           * @brief   Call to send Scene Get Membership Response Command
    710           *
    711           * @param   srcEP - Sending application's endpoint
    712           * @param   dstAddr - where you want the message to go
    713           * @param   status - scene command status
    714           * @param   capacity - remaining capacity of the scene table
    715           * @param   sceneCnt - number of scenes in the scene list
    716           * @param   sceneList - list of scene IDs
    717           * @param   groupID - group ID that scene belongs to
    718           * @param   seqNum - sequence number
    719           *
    720           * @return  ZStatus_t
    721           */
    722          ZStatus_t zclGeneral_SendSceneGetMembershipResponse( uint8 srcEP, afAddrType_t *dstAddr,
    723                                 uint8 status, uint8 capacity, uint8 sceneCnt, uint8 *sceneList,
    724                                 uint16 groupID, uint8 disableDefaultRsp, uint8 seqNum )
    725          {
    726            uint8 *buf;
    727            uint8 *pBuf;
    728            uint8 len = 1 + 1 + 2; // Status + Capacity + Group ID;
    729            uint8 i;
    730            ZStatus_t stat;
    731          
    732            if ( status == ZCL_STATUS_SUCCESS )
    733            {
    734              len++; // Scene Count
    735              len += sceneCnt; // Scene List (Scene ID is a single octet)
    736            }
    737          
    738            buf = osal_mem_alloc( len );
    739            if ( buf )
    740            {
    741              pBuf = buf;
    742              *pBuf++ = status;
    743              *pBuf++ = capacity;
    744              *pBuf++ = LO_UINT16( groupID );
    745              *pBuf++ = HI_UINT16( groupID );
    746              if ( status == ZCL_STATUS_SUCCESS )
    747              {
    748                *pBuf++ = sceneCnt;
    749                for ( i = 0; i < sceneCnt; i++ )
    750                  *pBuf++ = sceneList[i];
    751              }
    752          
    753              stat = zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_SCENES,
    754                                      COMMAND_SCENE_GET_MEMBERSHIP_RSP, TRUE,
    755                                      ZCL_FRAME_SERVER_CLIENT_DIR, disableDefaultRsp, 0, seqNum, len, buf );
    756              osal_mem_free( buf );
    757            }
    758            else
    759              stat = ZMemError;
    760          
    761            return ( stat );
    762          }
    763          #endif // ZCL_SCENES
    764          
    765          #ifdef ZCL_LEVEL_CTRL
    766          /*********************************************************************
    767           * @fn      zclGeneral_SendLevelControlMoveToLevelRequest
    768           *
    769           * @brief   Call to send out a Level Control Request. You can also use
    770           *          the appropriate macro.
    771           *
    772           * @param   srcEP - Sending application's endpoint
    773           * @param   dstAddr - where you want the message to go
    774           * @param   cmd - one of the following:
    775           *              COMMAND_LEVEL_MOVE_TO_LEVEL or
    776           *              COMMAND_LEVEL_MOVE_TO_LEVEL_WITH_ON_OFF
    777           * @param   level - what level to move to
    778           * @param   transitionTime - how long to take to get to the level (in seconds)
    779           *
    780           * @return  ZStatus_t
    781           */
    782          ZStatus_t zclGeneral_SendLevelControlMoveToLevelRequest( uint8 srcEP, afAddrType_t *dstAddr,
    783                                                                   uint8 cmd, uint8 level, uint16 transTime,
    784                                                                   uint8 disableDefaultRsp, uint8 seqNum )
    785          {
    786            uint8 buf[3];
    787          
    788            buf[0] = level;
    789            buf[1] = LO_UINT16( transTime );
    790            buf[2] = HI_UINT16( transTime );
    791          
    792            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL,
    793                                    cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    794                                    disableDefaultRsp, 0, seqNum, 3, buf );
    795          }
    796          
    797          /*********************************************************************
    798           * @fn      zclGeneral_SendLevelControlMoveRequest
    799           *
    800           * @brief   Call to send out a Level Control Request. You can also use
    801           *          the appropriate macro.
    802           *
    803           * @param   srcEP - Sending application's endpoint
    804           * @param   dstAddr - where you want the message to go
    805           * @param   cmd - one of the following:
    806           *              COMMAND_LEVEL_MOVE or
    807           *              COMMAND_LEVEL_MOVE_WITH_ON_OFF
    808           * @param   moveMode - LEVEL_MOVE_UP or
    809           *                     LEVEL_MOVE_DOWN
    810           * @param   rate - number of steps to take per second
    811           *
    812           * @return  ZStatus_t
    813           */
    814          ZStatus_t zclGeneral_SendLevelControlMoveRequest( uint8 srcEP, afAddrType_t *dstAddr,
    815                                                            uint8 cmd, uint8 moveMode, uint8 rate,
    816                                                            uint8 disableDefaultRsp, uint8 seqNum )
    817          {
    818            uint8 buf[2];
    819          
    820            buf[0] = moveMode;
    821            buf[1] = rate;
    822          
    823            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL,
    824                                    cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    825                                    disableDefaultRsp, 0, seqNum, 2, buf );
    826          }
    827          
    828          /*********************************************************************
    829           * @fn      zclGeneral_SendLevelControlStepRequest
    830           *
    831           * @brief   Call to send out a Level Control Request. You can also use
    832           *          the appropriate macro.
    833           *
    834           * @param   srcEP - Sending application's endpoint
    835           * @param   dstAddr - where you want the message to go
    836           * @param   cmd - one of the following:
    837           *              COMMAND_LEVEL_STEP
    838           *              COMMAND_LEVEL_STEP_WITH_ON_OFF
    839           * @param   stepMode - LEVEL_STEP_UP or
    840           *                     LEVEL_STEP_DOWN
    841           * @param   amount - number of levels to step
    842           * @param   transitionTime - time, in 1/10ths of a second, to take to perform the step
    843           *
    844           * @return  ZStatus_t
    845           */
    846          ZStatus_t zclGeneral_SendLevelControlStepRequest( uint8 srcEP, afAddrType_t *dstAddr,
    847                                   uint8 cmd, uint8 stepMode, uint8 stepSize, uint16 transTime,
    848                                   uint8 disableDefaultRsp, uint8 seqNum )
    849          {
    850            uint8 buf[4];
    851          
    852            buf[0] = stepMode;
    853            buf[1] = stepSize;
    854            buf[2] = LO_UINT16( transTime );
    855            buf[3] = HI_UINT16( transTime );
    856          
    857            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL,
    858                                    cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    859                                    disableDefaultRsp, 0, seqNum, 4, buf );
    860          }
    861          #endif // ZCL_LEVEL_CTRL
    862          
    863          #ifdef ZCL_ALARMS
    864          /*********************************************************************
    865           * @fn      zclGeneral_SendAlarmRequest
    866           *
    867           * @brief   Call to send out an Alarm Request Command
    868           *
    869           * @param   srcEP - Sending application's endpoint
    870           * @param   dstAddr - where you want the message to go
    871           * @param   cmd - either COMMAND_ALARMS_RESET or COMMAND_ALARMS_ALARM
    872           * @param   alarmCode - code for the cause of the alarm
    873           * @param   clusterID - cluster whose attribute generate the alarm
    874           *
    875           * @return  ZStatus_t
    876           */
    877          ZStatus_t zclGeneral_SendAlarmRequest( uint8 srcEP, afAddrType_t *dstAddr,
    878                                                 uint8 cmd, uint8 alarmCode, uint16 clusterID,
    879                                                 uint8 disableDefaultRsp, uint8 seqNum )
    880          {
    881            uint8 buf[3];
    882          
    883            buf[0] = alarmCode;
    884            buf[1] = LO_UINT16( clusterID );
    885            buf[2] = HI_UINT16( clusterID );
    886          
    887            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ALARMS,
    888                                    cmd, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    889                                    disableDefaultRsp, 0, seqNum, 3, buf );
    890          }
    891          
    892          /*********************************************************************
    893           * @fn      zclGeneral_SendAlarmGetRespnose
    894           *
    895           * @brief   Call to send out an Alarm Get Response Command
    896           *
    897           * @param   srcEP - Sending application's endpoint
    898           * @param   dstAddr - where you want the message to go
    899           * @param   status - SUCCESS or NOT_FOUND
    900           * @param   alarmCode - code for the cause of the alarm
    901           * @param   clusterID - cluster whose attribute generate the alarm
    902           * @param   timeStamp - time at which the alarm occured
    903           *
    904           * @return  ZStatus_t
    905           */
    906          ZStatus_t zclGeneral_SendAlarmGetRespnose( uint8 srcEP, afAddrType_t *dstAddr,
    907                                        uint8 status, uint8 alarmCode, uint16 clusterID,
    908                                        uint32 timeStamp, uint8 disableDefaultRsp, uint8 seqNum )
    909          {
    910            uint8 buf[8];
    911            uint8 len = 1; // Status
    912          
    913            buf[0] = status;
    914            if ( status == ZCL_STATUS_SUCCESS )
    915            {
    916              len += 1 + 2 + 4; // Alarm code + Cluster ID + Time stamp
    917              buf[1] = alarmCode;
    918              buf[2] = LO_UINT16( clusterID );
    919              buf[3] = HI_UINT16( clusterID );
    920              osal_buffer_uint32( &buf[4], timeStamp );
    921            }
    922          
    923            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_ALARMS,
    924                                    COMMAND_ALARMS_GET_RSP, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
    925                                    disableDefaultRsp, 0, seqNum, len, buf );
    926          }
    927          #endif // ZCL_ALARMS
    928          
    929          #ifdef ZCL_LOCATION
    930          /*********************************************************************
    931           * @fn      zclGeneral_SendLocationSetAbsolute
    932           *
    933           * @brief   Call to send out a Set Absolute Location Command
    934           *
    935           * @param   srcEP - Sending application's endpoint
    936           * @param   dstAddr - where you want the message to go
    937           * @param   absLoc - absolute location info
    938           *
    939           * @return  ZStatus_t
    940           */
    941          ZStatus_t zclGeneral_SendLocationSetAbsolute( uint8 srcEP, afAddrType_t *dstAddr,
    942                                                        zclLocationAbsolute_t *absLoc,
    943                                                        uint8 disableDefaultRsp, uint8 seqNum )
    944          {
    945             uint8 buf[10]; // 5 fields (2 octects each)
    946          
    947             buf[0] = LO_UINT16( absLoc->coordinate1 );
    948             buf[1] = HI_UINT16( absLoc->coordinate1 );
    949             buf[2] = LO_UINT16( absLoc->coordinate2 );
    950             buf[3] = HI_UINT16( absLoc->coordinate2 );
    951             buf[4] = LO_UINT16( absLoc->coordinate3 );
    952             buf[5] = HI_UINT16( absLoc->coordinate3 );
    953             buf[6] = LO_UINT16( absLoc->power );
    954             buf[7] = HI_UINT16( absLoc->power );
    955             buf[8] = LO_UINT16( absLoc->pathLossExponent );
    956             buf[9] = HI_UINT16( absLoc->pathLossExponent );
    957          
    958             return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
    959                                     COMMAND_LOCATION_SET_ABSOLUTE, TRUE,
    960                                     ZCL_FRAME_CLIENT_SERVER_DIR, disableDefaultRsp, 0, seqNum, 10, buf );
    961          }
    962          
    963          /*********************************************************************
    964           * @fn      zclGeneral_SendLocationSetDevCfg
    965           *
    966           * @brief   Call to send out a Set Device Configuration Command
    967           *
    968           * @param   srcEP - Sending application's endpoint
    969           * @param   dstAddr - where you want the message to go
    970           * @param   devCfg - device configuration info
    971           *
    972           * @return  ZStatus_t
    973           */
    974          ZStatus_t zclGeneral_SendLocationSetDevCfg( uint8 srcEP, afAddrType_t *dstAddr,
    975                                                      zclLocationDevCfg_t *devCfg,
    976                                                      uint8 disableDefaultRsp, uint8 seqNum )
    977          {
    978             uint8 buf[9];  // 4 fields (2 octects each) + 1 field with 1 octect
    979          
    980             buf[0] = LO_UINT16( devCfg->power );
    981             buf[1] = HI_UINT16( devCfg->power );
    982             buf[2] = LO_UINT16( devCfg->pathLossExponent );
    983             buf[3] = HI_UINT16( devCfg->pathLossExponent );
    984             buf[4] = LO_UINT16( devCfg->calcPeriod );
    985             buf[5] = HI_UINT16( devCfg->calcPeriod );
    986             buf[6] = devCfg->numMeasurements;
    987             buf[7] = LO_UINT16( devCfg->reportPeriod );
    988             buf[8] = HI_UINT16( devCfg->reportPeriod );
    989          
    990             return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
    991                                     COMMAND_LOCATION_SET_DEV_CFG, TRUE,
    992                                     ZCL_FRAME_CLIENT_SERVER_DIR, disableDefaultRsp, 0, seqNum, 9, buf );
    993          }
    994          
    995          /*********************************************************************
    996           * @fn      zclGeneral_SendLocationGetDevCfg
    997           *
    998           * @brief   Call to send out a Get Device Configuration Command
    999           *
   1000           * @param   srcEP - Sending application's endpoint
   1001           * @param   dstAddr - where you want the message to go
   1002           * @param   targetAddr - device for which location parameters are being requested
   1003           *
   1004           * @return  ZStatus_t
   1005           */
   1006          ZStatus_t zclGeneral_SendLocationGetDevCfg( uint8 srcEP, afAddrType_t *dstAddr,
   1007                                 uint8 *targetAddr, uint8 disableDefaultRsp, uint8 seqNum )
   1008          {
   1009            uint8 buf[8];
   1010          
   1011            osal_cpyExtAddr( buf, targetAddr );
   1012          
   1013            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
   1014                                    COMMAND_LOCATION_GET_DEV_CFG, TRUE,
   1015                                    ZCL_FRAME_CLIENT_SERVER_DIR, disableDefaultRsp, 0, seqNum, 8, buf );
   1016          }
   1017          
   1018          /*********************************************************************
   1019           * @fn      zclGeneral_SendLocationGetData
   1020           *
   1021           * @brief   Call to send out a Get Location Data Command
   1022           *
   1023           * @param   srcEP - Sending application's endpoint
   1024           * @param   dstAddr - where you want the message to go
   1025           * @param   locaData - location information and channel parameters that are requested.
   1026           *
   1027           * @return  ZStatus_t
   1028           */
   1029          ZStatus_t zclGeneral_SendLocationGetData( uint8 srcEP, afAddrType_t *dstAddr,
   1030                                                    zclLocationGetData_t *locData,
   1031                                                    uint8 disableDefaultRsp, uint8 seqNum )
   1032          {
   1033            uint8 buf[10]; // bitmap (1) + number responses (1) + IEEE Address (8)
   1034            uint8 *pBuf = buf;
   1035            uint8 len = 2; // bitmap + number responses
   1036          
   1037            *pBuf  = locData->absoluteOnly;
   1038            *pBuf |= locData->recalculate << 1;
   1039            *pBuf |= locData->brdcastIndicator << 2;
   1040            *pBuf |= locData->brdcastResponse << 3;
   1041            *pBuf |= locData->compactResponse << 4;
   1042            pBuf++;  // move past the bitmap field
   1043          
   1044            *pBuf++ = locData->numResponses;
   1045          
   1046            if ( locData->brdcastIndicator == 0 )
   1047            {
   1048              osal_cpyExtAddr( pBuf, locData->targetAddr );
   1049              len += 8; // ieee addr
   1050            }
   1051          
   1052            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
   1053                                    COMMAND_LOCATION_GET_DATA, TRUE,
   1054                                    ZCL_FRAME_CLIENT_SERVER_DIR, disableDefaultRsp, 0, seqNum, len, buf );
   1055          }
   1056          
   1057          /*********************************************************************
   1058           * @fn      zclGeneral_SendLocationDevCfgResponse
   1059           *
   1060           * @brief   Call to send out a Device Configuration Response Command
   1061           *
   1062           * @param   srcEP - Sending application's endpoint
   1063           * @param   dstAddr - where you want the message to go
   1064           * @param   devCfg - device's location parameters that are requested
   1065           *
   1066           * @return  ZStatus_t
   1067           */
   1068          ZStatus_t zclGeneral_SendLocationDevCfgResponse( uint8 srcEP, afAddrType_t *dstAddr,
   1069                                                           zclLocationDevCfgRsp_t *devCfg,
   1070                                                           uint8 disableDefaultRsp, uint8 seqNum )
   1071          {
   1072            uint8 buf[10]; // 4 fields (2 octects each) + 2 fields (1 octect each)
   1073            uint8 len = 1; // Status
   1074          
   1075            buf[0] = devCfg->status;
   1076            if ( devCfg->status == ZCL_STATUS_SUCCESS )
   1077            {
   1078              buf[1] = LO_UINT16( devCfg->data.power );
   1079              buf[2] = HI_UINT16( devCfg->data.power );
   1080              buf[3] = LO_UINT16( devCfg->data.pathLossExponent );
   1081              buf[4] = HI_UINT16( devCfg->data.pathLossExponent );
   1082              buf[5] = LO_UINT16( devCfg->data.calcPeriod );
   1083              buf[6] = HI_UINT16( devCfg->data.calcPeriod );
   1084              buf[7] = devCfg->data.numMeasurements;
   1085              buf[8] = LO_UINT16( devCfg->data.reportPeriod );
   1086              buf[9] = HI_UINT16( devCfg->data.reportPeriod );
   1087              len += 9;
   1088            }
   1089          
   1090            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
   1091                                    COMMAND_LOCATION_DEV_CFG_RSP, TRUE,
   1092                                    ZCL_FRAME_SERVER_CLIENT_DIR, disableDefaultRsp, 0, seqNum, len, buf );
   1093          }
   1094          
   1095          /*********************************************************************
   1096           * @fn      zclGeneral_SendLocationData
   1097           *
   1098           * @brief   Call to send out location data
   1099           *
   1100           * @param   srcEP - Sending application's endpoint
   1101           * @param   dstAddr - where you want the message to go
   1102           * @param   status - indicates whether response to request was successful or not
   1103           * @param   locData - location information and channel parameters being sent
   1104           *
   1105           * @return  ZStatus_t
   1106           */
   1107          ZStatus_t zclGeneral_SendLocationData( uint8 srcEP, afAddrType_t *dstAddr, uint8 cmd,
   1108                                                 uint8 status, zclLocationData_t *locData,
   1109                                                 uint8 disableDefaultRsp, uint8 seqNum )
   1110          {
   1111            uint8 buf[16];
   1112            uint8 *pBuf = buf;
   1113            uint8 len = 0;
   1114          
   1115            if ( cmd == COMMAND_LOCATION_DATA_RSP )
   1116            {
   1117              // Only response command includes a status field
   1118              *pBuf++ = status;
   1119              len++;
   1120            }
   1121          
   1122            if ( cmd != COMMAND_LOCATION_DATA_RSP || status == ZCL_STATUS_SUCCESS )
   1123            {
   1124              // Notification or Response with successful status
   1125              *pBuf++ = locData->type;
   1126              *pBuf++ = LO_UINT16( locData->absLoc.coordinate1 );
   1127              *pBuf++ = HI_UINT16( locData->absLoc.coordinate1 );
   1128              *pBuf++ = LO_UINT16( locData->absLoc.coordinate2 );
   1129              *pBuf++ = HI_UINT16( locData->absLoc.coordinate2 );
   1130              len += 5;
   1131          
   1132              if ( locationType2D(locData->type) == 0 )
   1133              {
   1134                // 2D location doesn't have coordinate 3
   1135                *pBuf++ = LO_UINT16( locData->absLoc.coordinate3 );
   1136                *pBuf++ = HI_UINT16( locData->absLoc.coordinate3 );
   1137                len += 2;
   1138              }
   1139          
   1140              if ( cmd != COMMAND_LOCATION_COMPACT_DATA_NOTIF )
   1141              {
   1142                // Compact notification doesn't include these fields
   1143                *pBuf++ = LO_UINT16( locData->absLoc.power );
   1144                *pBuf++ = HI_UINT16( locData->absLoc.power );
   1145                *pBuf++ = LO_UINT16( locData->absLoc.pathLossExponent );
   1146                *pBuf++ = HI_UINT16( locData->absLoc.pathLossExponent );
   1147                len += 4;
   1148              }
   1149          
   1150              if ( locationTypeAbsolute(locData->type) == 0 )
   1151              {
   1152                // Absolute location doesn't include these fields
   1153                if ( cmd != COMMAND_LOCATION_COMPACT_DATA_NOTIF )
   1154                {
   1155                  // Compact notification doesn't include this field
   1156                  *pBuf++ = locData->calcLoc.locationMethod;
   1157                  len++;
   1158                }
   1159          
   1160                *pBuf++ = locData->calcLoc.qualityMeasure;
   1161                *pBuf++ = LO_UINT16( locData->calcLoc.locationAge );
   1162                *pBuf++ = HI_UINT16( locData->calcLoc.locationAge );
   1163                len += 3;
   1164              }
   1165            }
   1166          
   1167            return zcl_SendCommand( srcEP, dstAddr, ZCL_CLUSTER_ID_GEN_LOCATION,
   1168                                    cmd, TRUE, ZCL_FRAME_SERVER_CLIENT_DIR,
   1169                                    disableDefaultRsp, 0, seqNum, len, buf );
   1170          }
   1171          #endif // ZCL_LOCATION
   1172          
   1173          /*********************************************************************
   1174           * @fn      zclGeneral_FindCallbacks
   1175           *
   1176           * @brief   Find the callbacks for an endpoint
   1177           *
   1178           * @param   endpoint - endpoint to find the application callbacks for
   1179           *
   1180           * @return  pointer to the callbacks
   1181           */
   1182          static zclGeneral_AppCallbacks_t *zclGeneral_FindCallbacks( uint8 endpoint )
   1183          {
   1184            zclGenCBRec_t *pCBs;
   1185          
   1186            pCBs = zclGenCBs;
   1187            while ( pCBs )
   1188            {
   1189              if ( pCBs->endpoint == endpoint )
   1190                return ( pCBs->CBs );
   1191              pCBs = pCBs->next;
   1192            }
   1193            return ( (zclGeneral_AppCallbacks_t *)NULL );
   1194          }
   1195          
   1196          /*********************************************************************
   1197           * @fn      zclGeneral_HdlIncoming
   1198           *
   1199           * @brief   Callback from ZCL to process incoming Commands specific
   1200           *          to this cluster library or Profile commands for attributes
   1201           *          that aren't in the attribute list
   1202           *
   1203           *
   1204           * @param   pInMsg - pointer to the incoming message
   1205           *
   1206           * @return  ZStatus_t
   1207           */
   1208          static ZStatus_t zclGeneral_HdlIncoming( zclIncoming_t *pInMsg )
   1209          {
   1210            ZStatus_t stat = ZSuccess;
   1211          
   1212          #if defined ( INTER_PAN )
   1213            if ( StubAPS_InterPan( pInMsg->msg->srcAddr.panId, pInMsg->msg->srcAddr.endPoint ) )
   1214              return ( stat ); // Cluster not supported thru Inter-PAN
   1215          #endif
   1216            if ( zcl_ClusterCmd( pInMsg->hdr.fc.type ) )
   1217            {
   1218              // Is this a manufacturer specific command?
   1219              if ( pInMsg->hdr.fc.manuSpecific == 0 )
   1220              {
   1221                stat = zclGeneral_HdlInSpecificCommands( pInMsg );
   1222              }
   1223              else
   1224              {
   1225                // We don't support any manufacturer specific command.
   1226                stat = ZFailure;
   1227              }
   1228            }
   1229            else
   1230            {
   1231              // Handle all the normal (Read, Write...) commands -- should never get here
   1232              stat = ZFailure;
   1233            }
   1234            return ( stat );
   1235          }
   1236          
   1237          /*********************************************************************
   1238           * @fn      zclGeneral_HdlInSpecificCommands
   1239           *
   1240           * @brief   Callback from ZCL to process incoming Commands specific
   1241           *          to this cluster library
   1242          
   1243           * @param   pInMsg - pointer to the incoming message
   1244           *
   1245           * @return  ZStatus_t
   1246           */
   1247          static ZStatus_t zclGeneral_HdlInSpecificCommands( zclIncoming_t *pInMsg )
   1248          {
   1249            ZStatus_t stat;
   1250            zclGeneral_AppCallbacks_t *pCBs;
   1251          
   1252            // make sure endpoint exists
   1253            pCBs = zclGeneral_FindCallbacks( pInMsg->msg->endPoint );
   1254            if ( pCBs == NULL )
   1255              return ( ZFailure );
   1256          
   1257            switch ( pInMsg->msg->clusterId )
   1258            {
   1259          #ifdef ZCL_BASIC
   1260              case ZCL_CLUSTER_ID_GEN_BASIC:
   1261                stat = zclGeneral_ProcessInBasic( pInMsg, pCBs );
   1262                break;
   1263          #endif // ZCL_BASIC
   1264          
   1265          #ifdef ZCL_IDENTIFY
   1266              case ZCL_CLUSTER_ID_GEN_IDENTIFY:
   1267                stat = zclGeneral_ProcessInIdentity( pInMsg, pCBs );
   1268                break;
   1269          #endif // ZCL_IDENTIFY
   1270          
   1271          #ifdef ZCL_GROUPS
   1272              case ZCL_CLUSTER_ID_GEN_GROUPS:
   1273                if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   1274                  stat = zclGeneral_ProcessInGroupsServer( pInMsg );
   1275                else
   1276                  stat = zclGeneral_ProcessInGroupsClient( pInMsg, pCBs );
   1277                break;
   1278          #endif // ZCL_GROUPS
   1279          
   1280          #ifdef ZCL_SCENES
   1281              case ZCL_CLUSTER_ID_GEN_SCENES:
   1282                if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   1283                  stat = zclGeneral_ProcessInScenesServer( pInMsg, pCBs );
   1284                else
   1285                  stat = zclGeneral_ProcessInScenesClient( pInMsg, pCBs );
   1286                break;
   1287          #endif // ZCL_SCENES
   1288          
   1289          #ifdef ZCL_ON_OFF
   1290              case ZCL_CLUSTER_ID_GEN_ON_OFF:
   1291                stat = zclGeneral_ProcessInOnOff( pInMsg, pCBs );
   1292                break;
   1293          #endif // ZCL_ON_OFF
   1294          
   1295          #ifdef ZCL_LEVEL_CTRL
   1296              case ZCL_CLUSTER_ID_GEN_LEVEL_CONTROL:
   1297                stat = zclGeneral_ProcessInLevelControl( pInMsg, pCBs );
   1298                break;
   1299          #endif // ZCL_LEVEL_CTRL
   1300          
   1301          #ifdef ZCL_ALARMS
   1302              case ZCL_CLUSTER_ID_GEN_ALARMS:
   1303                if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   1304                  stat = zclGeneral_ProcessInAlarmsServer( pInMsg, pCBs );
   1305                else
   1306                  stat = zclGeneral_ProcessInAlarmsClient( pInMsg, pCBs );
   1307                break;
   1308          #endif // ZCL_ALARMS
   1309          
   1310          #ifdef ZCL_LOCATION
   1311              case ZCL_CLUSTER_ID_GEN_LOCATION:
   1312                if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   1313                  stat = zclGeneral_ProcessInLocationServer( pInMsg, pCBs );
   1314                else
   1315                  stat = zclGeneral_ProcessInLocationClient( pInMsg, pCBs );
   1316                break;
   1317          #endif // ZCL_LOCATION
   1318          
   1319              case ZCL_CLUSTER_ID_GEN_POWER_CFG:
   1320              case ZCL_CLUSTER_ID_GEN_DEVICE_TEMP_CONFIG:
   1321              case ZCL_CLUSTER_ID_GEN_ON_OFF_SWITCH_CONFIG:
   1322              case ZCL_CLUSTER_ID_GEN_TIME:
   1323              default:
   1324                stat = ZFailure;
   1325                break;
   1326            }
   1327          
   1328            return ( stat );
   1329          }
   1330          
   1331          #ifdef ZCL_BASIC
   1332          /*********************************************************************
   1333           * @fn      zclGeneral_ProcessInBasic
   1334           *
   1335           * @brief   Process in the received Basic Command.
   1336           *
   1337           * @param   pInMsg - pointer to the incoming message
   1338           *
   1339           * @return  ZStatus_t
   1340           */
   1341          static ZStatus_t zclGeneral_ProcessInBasic( zclIncoming_t *pInMsg,
   1342                                                      zclGeneral_AppCallbacks_t *pCBs )
   1343          {
   1344            if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   1345            {
   1346              if ( pInMsg->hdr.commandID > COMMAND_BASIC_RESET_FACT_DEFAULT )
   1347                return ( ZFailure );   // Error ignore the command
   1348          
   1349              if ( pCBs->pfnBasicReset )
   1350                pCBs->pfnBasicReset();
   1351            }
   1352            // no Client command
   1353          
   1354            return ( ZSuccess );
   1355          }
   1356          #endif // ZCL_BASIC
   1357          
   1358          #ifdef ZCL_IDENTIFY
   1359          /*********************************************************************
   1360           * @fn      zclGeneral_ProcessInIdentity
   1361           *
   1362           * @brief   Process in the received Identity Command.
   1363           *
   1364           * @param   pInMsg - pointer to the incoming message
   1365           *
   1366           * @return  ZStatus_t
   1367           */
   1368          static ZStatus_t zclGeneral_ProcessInIdentity( zclIncoming_t *pInMsg,
   1369                                                         zclGeneral_AppCallbacks_t *pCBs )
   1370          {
   1371            if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   1372            {
   1373              if ( pInMsg->hdr.commandID > COMMAND_IDENTIFY_QUERY )
   1374                return ( ZFailure );   // Error ignore the command
   1375          
   1376              if ( pInMsg->hdr.commandID == COMMAND_IDENTIFY )
   1377              {
   1378                if ( pCBs->pfnIdentify )
                                  ^
Error[Pe136]: struct "<unnamed>" has no field "pfnIdentify"
   1379                {
   1380                  zclIdentify_t cmd;
   1381          
   1382                  cmd.srcAddr = &(pInMsg->msg->srcAddr);
   1383                  cmd.identifyTime = BUILD_UINT16( pInMsg->pData[0], pInMsg->pData[1] );
   1384          
   1385                  pCBs->pfnIdentify( &cmd );
                               ^
Error[Pe136]: struct "<unnamed>" has no field "pfnIdentify"
   1386                }
   1387              }
   1388              else
   1389              {
   1390                zclAttrRec_t attrRec;
   1391                uint16 identifyTime = 0;
   1392          
   1393                // Retrieve Identify Time
   1394                if ( zclFindAttrRec( pInMsg->msg->endPoint, pInMsg->msg->clusterId, ATTRID_IDENTIFY_TIME, &attrRec ) )
   1395                  zclReadAttrData( (uint8 *)&identifyTime, &attrRec, NULL );
   1396          
   1397                // Is device identifying itself?
   1398                if ( identifyTime > 0 )
   1399                {
   1400                  zclGeneral_SendIdentifyQueryResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   1401                                                        identifyTime, true, pInMsg->hdr.transSeqNum );
   1402                }
   1403          
   1404                return ( ZCL_STATUS_CMD_HAS_RSP );
   1405              }
   1406            }
   1407            else // Client Command
   1408            {
   1409              if ( pInMsg->hdr.commandID > COMMAND_IDENTIFY_QUERY_RSP )
   1410                return ( ZFailure );   // Error ignore the command
   1411          
   1412              if ( pCBs->pfnIdentifyQueryRsp )
                                ^
Error[Pe136]: struct "<unnamed>" has no field "pfnIdentifyQueryRsp"
   1413              {
   1414                zclIdentifyQueryRsp_t rsp;
   1415          
   1416                rsp.srcAddr = &(pInMsg->msg->srcAddr);
   1417                rsp.timeout = BUILD_UINT16( pInMsg->pData[0], pInMsg->pData[1] );
   1418          
   1419                pCBs->pfnIdentifyQueryRsp( &rsp );
                             ^
Error[Pe136]: struct "<unnamed>" has no field "pfnIdentifyQueryRsp"
   1420              }
   1421            }
   1422          
   1423            return ( ZSuccess );
   1424          }
   1425          #endif // ZCL_IDENTIFY
   1426          
   1427          #ifdef ZCL_GROUPS
   1428          
   1429          /*********************************************************************
   1430           * @fn      zclGeneral_AddGroup
   1431           *
   1432           * @brief   Add a Group.
   1433           *
   1434           * @param   endPoint - application endpoint
   1435           * @param   group - group to be added
   1436           * @param   pData - pointer to the group info
   1437           *
   1438           * @return  ZStatus_t
   1439           */
   1440          static ZStatus_t zclGeneral_AddGroup( uint8 endPoint, aps_Group_t *group, uint8 *pData )
   1441          {
   1442            zclAttrRec_t attrRec;
   1443            uint8 nameLen;
   1444            uint8 nameSupport = FALSE;
   1445          
   1446            pData += 2;   // Move past group ID
   1447            nameLen = *pData++;
   1448          
   1449            // Retrieve Name Support attribute
   1450            if ( zclFindAttrRec( endPoint, ZCL_CLUSTER_ID_GEN_GROUPS, ATTRID_GROUP_NAME_SUPPORT, &attrRec ) )
   1451               zclReadAttrData( &nameSupport, &attrRec, NULL );
   1452          
   1453            if ( nameSupport )
   1454            {
   1455              if ( nameLen > (APS_GROUP_NAME_LEN-1) )
   1456                 nameLen = (APS_GROUP_NAME_LEN-1);
   1457              group->name[0] = nameLen;
   1458              osal_memcpy( &(group->name[1]), pData, nameLen );
   1459            }
   1460          
   1461            return ( aps_AddGroup( endPoint, group ) );
   1462          }
   1463          
   1464          /*********************************************************************
   1465           * @fn      zclGeneral_ProcessInGroupsServer
   1466           *
   1467           * @brief   Process in the received Groups Command.
   1468           *
   1469           * @param   pInMsg - pointer to the incoming message
   1470           *
   1471           * @return  ZStatus_t
   1472           */
   1473          static ZStatus_t zclGeneral_ProcessInGroupsServer( zclIncoming_t *pInMsg )
   1474          {
   1475            zclAttrRec_t attrRec;
   1476            aps_Group_t group;
   1477            aps_Group_t *pGroup;
   1478            uint8 *pData;
   1479            uint8 status;
   1480            uint8 grpCnt;
   1481            uint8 grpRspCnt = 0;
   1482            uint16 *grpList;
   1483            uint16 identifyTime = 0;
   1484            uint8 i;
   1485            ZStatus_t stat = ZSuccess;
   1486          
   1487            osal_memset( (uint8*)&group, 0, sizeof( aps_Group_t ) );
   1488          
   1489            pData = pInMsg->pData;
   1490            group.ID = BUILD_UINT16( pData[0], pData[1] );
   1491            switch ( pInMsg->hdr.commandID )
   1492            {
   1493              case COMMAND_GROUP_ADD:
   1494                status = zclGeneral_AddGroup( pInMsg->msg->endPoint, &group, pData );
   1495                if ( status != ZSuccess )
   1496                {
   1497                  if ( status == ZApsDuplicateEntry )
   1498                    status = ZCL_STATUS_DUPLICATE_EXISTS;
   1499                  else
   1500                    status = ZCL_STATUS_INSUFFICIENT_SPACE;
   1501                }
   1502          
   1503                zclGeneral_SendGroupAddResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   1504                                                 status, group.ID, true, pInMsg->hdr.transSeqNum );
   1505                stat = ZCL_STATUS_CMD_HAS_RSP;
   1506                break;
   1507          
   1508              case COMMAND_GROUP_VIEW:
   1509                pGroup = aps_FindGroup( pInMsg->msg->endPoint, group.ID );
   1510                if ( pGroup )
   1511                {
   1512                  status = ZCL_STATUS_SUCCESS;
   1513                }
   1514                else
   1515                {
   1516                  // Group not found
   1517                  status = ZCL_STATUS_NOT_FOUND;
   1518                  pGroup = &group;
   1519                }
   1520                zclGeneral_SendGroupViewResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   1521                                                  status, pGroup, true, pInMsg->hdr.transSeqNum );
   1522                stat = ZCL_STATUS_CMD_HAS_RSP;
   1523                break;
   1524          
   1525              case COMMAND_GROUP_GET_MEMBERSHIP:
   1526                grpCnt = *pData++;
   1527                  
   1528                // Allocate space for the group list
   1529                grpList = osal_mem_alloc( sizeof( uint16 ) * APS_MAX_GROUPS );
   1530                if ( grpList != NULL )
   1531                {
   1532                  if ( grpCnt == 0 )
   1533                  {
   1534                    // Find out all the groups of which the endpoint is a member.
   1535                    grpRspCnt = aps_FindAllGroupsForEndpoint( pInMsg->msg->endPoint, grpList );
   1536                  }
   1537                  else
   1538                  {
   1539                    // Find out the groups (in the list) of which the endpoint is a member.
   1540                    for ( i = 0; i < grpCnt; i++ )
   1541                    {
   1542                      group.ID = BUILD_UINT16( pData[0], pData[1] );
   1543                      pData += 2;
   1544          
   1545                      if ( aps_FindGroup( pInMsg->msg->endPoint, group.ID ) )
   1546                        grpList[grpRspCnt++] = group.ID;
   1547                    }
   1548                  }
   1549                
   1550                  if ( grpCnt == 0 ||  grpRspCnt != 0 )
   1551                  {
   1552                    zclGeneral_SendGroupGetMembershipResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr, 
   1553                                                               aps_GroupsRemaingCapacity(), grpRspCnt, 
   1554                                                               grpList, true, pInMsg->hdr.transSeqNum );
   1555                  }
   1556          
   1557                  osal_mem_free( grpList );
   1558                }
   1559                else
   1560                {
   1561                  // Couldn't allocate space for the group list -- send a Default Response command back.
   1562                  zclDefaultRspCmd_t defaultRspCmd;
   1563                  
   1564                  defaultRspCmd.commandID = pInMsg->hdr.commandID;
   1565                  defaultRspCmd.statusCode = ZCL_STATUS_INSUFFICIENT_SPACE;
   1566                  zcl_SendDefaultRspCmd( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
   1567                                         pInMsg->msg->clusterId, &defaultRspCmd,
   1568                                         ZCL_FRAME_SERVER_CLIENT_DIR, true, 0, pInMsg->hdr.transSeqNum );
   1569                }
   1570          
   1571                stat = ZCL_STATUS_CMD_HAS_RSP;
   1572                break;
   1573          
   1574              case COMMAND_GROUP_REMOVE:
   1575                if ( aps_RemoveGroup( pInMsg->msg->endPoint, group.ID ) )
   1576                  status = ZCL_STATUS_SUCCESS;
   1577                else
   1578                  status = ZCL_STATUS_NOT_FOUND;
   1579                zclGeneral_SendGroupRemoveResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   1580                                                    status, group.ID, true, pInMsg->hdr.transSeqNum );
   1581                stat = ZCL_STATUS_CMD_HAS_RSP;
   1582                break;
   1583          
   1584              case COMMAND_GROUP_REMOVE_ALL:
   1585                aps_RemoveAllGroup( pInMsg->msg->endPoint );
   1586                break;
   1587          
   1588              case COMMAND_GROUP_ADD_IF_IDENTIFYING:
   1589                // Retrieve Identify Time
   1590                if ( zclFindAttrRec( pInMsg->msg->endPoint, ZCL_CLUSTER_ID_GEN_IDENTIFY, ATTRID_IDENTIFY_TIME, &attrRec ) )
   1591                  zclReadAttrData( (uint8 *)&identifyTime, &attrRec, NULL );
   1592          
   1593                // Is device identifying itself?
   1594                if ( identifyTime > 0 )
   1595                  zclGeneral_AddGroup( pInMsg->msg->endPoint, &group, pData );
   1596                break;
   1597          
   1598              default:
   1599                stat = ZFailure;
   1600                break;
   1601            }
   1602          
   1603            return ( stat );
   1604          }
   1605          
   1606          /*********************************************************************
   1607           * @fn      zclGeneral_ProcessInGroupsClient
   1608           *
   1609           * @brief   Process in the received Groups Command.
   1610           *
   1611           * @param   pInMsg - pointer to the incoming message
   1612           *
   1613           * @return  ZStatus_t
   1614           */
   1615          static ZStatus_t zclGeneral_ProcessInGroupsClient( zclIncoming_t *pInMsg,
   1616                                                             zclGeneral_AppCallbacks_t *pCBs )
   1617          {
   1618            aps_Group_t group;
   1619            uint8 *pData = pInMsg->pData;
   1620            uint8 grpCnt;
   1621            uint8 nameLen;
   1622            zclGroupRsp_t rsp;
   1623            uint8 i;
   1624            ZStatus_t stat = ZSuccess;
   1625          
   1626            osal_memset( (uint8*)&group, 0, sizeof( aps_Group_t ) );
   1627            osal_memset( (uint8*)&rsp, 0, sizeof( zclGroupRsp_t ) );
   1628          
   1629            switch ( pInMsg->hdr.commandID )
   1630            {
   1631              case COMMAND_GROUP_ADD_RSP:
   1632              case COMMAND_GROUP_VIEW_RSP:
   1633              case COMMAND_GROUP_REMOVE_RSP:
   1634                rsp.status = *pData++;
   1635                group.ID = BUILD_UINT16( pData[0], pData[1] );
   1636          
   1637                if ( rsp.status == ZCL_STATUS_SUCCESS && pInMsg->hdr.commandID == COMMAND_GROUP_VIEW_RSP )
   1638                {
   1639                  pData += 2;   // Move past ID
   1640                  nameLen = *pData++;
   1641                  if ( nameLen > (APS_GROUP_NAME_LEN-1) )
   1642                    nameLen = (APS_GROUP_NAME_LEN-1);
   1643                  group.name[0] = nameLen;
   1644                  osal_memcpy( &(group.name[1]), pData, nameLen );
   1645                  rsp.grpName = group.name;
   1646                }
   1647          
   1648                if ( pCBs->pfnGroupRsp )
   1649                {
   1650                  rsp.srcAddr = &(pInMsg->msg->srcAddr);
   1651                  rsp.cmdID = pInMsg->hdr.commandID;
   1652                  rsp.grpCnt = 1;
   1653                  rsp.grpList = &group.ID;
   1654                  rsp.capacity = 0;
   1655          
   1656                  pCBs->pfnGroupRsp( &rsp );
   1657                }
   1658                break;
   1659          
   1660              case COMMAND_GROUP_GET_MEMBERSHIP_RSP:
   1661                {
   1662                  uint16 *grpList = NULL;
   1663                  rsp.capacity = *pData++;
   1664                  grpCnt = *pData++;
   1665            
   1666                  if ( grpCnt > 0 )
   1667                  {
   1668                    // Allocate space for the group list
   1669                    grpList = osal_mem_alloc( sizeof( uint16 ) * grpCnt );
   1670                    if ( grpList != NULL )
   1671                    {
   1672                      rsp.grpCnt = grpCnt;
   1673                      for ( i = 0; i < grpCnt; i++ )
   1674                      {
   1675                        grpList[i] = BUILD_UINT16( pData[0], pData[1] );
   1676                        pData += 2;
   1677                      }
   1678                    }
   1679                  }
   1680            
   1681                  if ( pCBs->pfnGroupRsp )
   1682                  {
   1683                    rsp.srcAddr = &(pInMsg->msg->srcAddr);
   1684                    rsp.cmdID = pInMsg->hdr.commandID;
   1685                    rsp.grpList = grpList;
   1686            
   1687                    pCBs->pfnGroupRsp( &rsp );
   1688                  }
   1689                  
   1690                  if ( grpList != NULL )
   1691                  {
   1692                    osal_mem_free( grpList );
   1693                  }
   1694                }
   1695                break;
   1696          
   1697              default:
   1698                stat = ZFailure;
   1699                break;
   1700            }
   1701          
   1702            return ( stat );
   1703          }
   1704          #endif // ZCL_GROUPS
   1705          
   1706          #ifdef ZCL_SCENES
   1707          /*********************************************************************
   1708           * @fn      zclGeneral_AddScene
   1709           *
   1710           * @brief   Add a scene for an endpoint
   1711           *
   1712           * @param   endpoint -
   1713           * @param   scene - new scene item
   1714           *
   1715           * @return  ZStatus_t
   1716           */
   1717          ZStatus_t zclGeneral_AddScene( uint8 endpoint, zclGeneral_Scene_t *scene )
   1718          {
   1719            zclGenSceneItem_t *pNewItem;
   1720            zclGenSceneItem_t *pLoop;
   1721          
   1722            // Fill in the new profile list
   1723            pNewItem = osal_mem_alloc( sizeof( zclGenSceneItem_t ) );
   1724            if ( pNewItem == NULL )
   1725              return ( ZMemError );
   1726          
   1727            // Fill in the plugin record.
   1728            pNewItem->next = (zclGenSceneItem_t *)NULL;
   1729            pNewItem->endpoint = endpoint;
   1730            osal_memcpy( (uint8*)&(pNewItem->scene), (uint8*)scene, sizeof ( zclGeneral_Scene_t ));
   1731          
   1732            // Find spot in list
   1733            if (  zclGenSceneTable == NULL )
   1734            {
   1735              zclGenSceneTable = pNewItem;
   1736            }
   1737            else
   1738            {
   1739              // Look for end of list
   1740              pLoop = zclGenSceneTable;
   1741              while ( pLoop->next != NULL )
   1742                pLoop = pLoop->next;
   1743          
   1744              // Put new item at end of list
   1745              pLoop->next = pNewItem;
   1746            }
   1747          
   1748            // Update NV
   1749            zclGeneral_ScenesWriteNV();
   1750          
   1751            return ( ZSuccess );
   1752          }
   1753          
   1754          /*********************************************************************
   1755           * @fn      zclGeneral_FindScene
   1756           *
   1757           * @brief   Find a scene with endpoint and sceneID
   1758           *
   1759           * @param   endpoint -
   1760           * @param   groupID - what group the scene belongs to
   1761           * @param   sceneID - ID to look for scene
   1762           *
   1763           * @return  a pointer to the scene information, NULL if not found
   1764           */
   1765          zclGeneral_Scene_t *zclGeneral_FindScene( uint8 endpoint, uint16 groupID, uint8 sceneID )
   1766          {
   1767            zclGenSceneItem_t *pLoop;
   1768          
   1769            // Look for end of list
   1770            pLoop = zclGenSceneTable;
   1771            while ( pLoop )
   1772            {
   1773              if ( (pLoop->endpoint == endpoint || endpoint == 0xFF)
   1774                  && pLoop->scene.groupID == groupID && pLoop->scene.ID == sceneID )
   1775              {
   1776                return ( &(pLoop->scene) );
   1777              }
   1778              pLoop = pLoop->next;
   1779            }
   1780          
   1781            return ( (zclGeneral_Scene_t *)NULL );
   1782          }
   1783          
   1784          /*********************************************************************
   1785           * @fn      aps_FindAllScensForGroup
   1786           *
   1787           * @brief   Find all the scenes with groupID
   1788           *
   1789           * @param   endpoint - endpoint to look for
   1790           * @param   sceneList - List to hold scene IDs (should hold APS_MAX_SCENES entries)
   1791           *
   1792           * @return  number of scenes copied to sceneList
   1793           */
   1794          uint8 zclGeneral_FindAllScenesForGroup( uint8 endpoint, uint16 groupID, uint8 *sceneList )
   1795          {
   1796            zclGenSceneItem_t *pLoop;
   1797            uint8 cnt = 0;
   1798          
   1799            // Look for end of list
   1800            pLoop = zclGenSceneTable;
   1801            while ( pLoop )
   1802            {
   1803              if ( pLoop->endpoint == endpoint && pLoop->scene.groupID == groupID )
   1804                sceneList[cnt++] = pLoop->scene.ID;
   1805              pLoop = pLoop->next;
   1806            }
   1807            return ( cnt );
   1808          }
   1809          
   1810          /*********************************************************************
   1811           * @fn      zclGeneral_RemoveScene
   1812           *
   1813           * @brief   Remove a scene with endpoint and sceneID
   1814           *
   1815           * @param   endpoint -
   1816           * @param   groupID - what group the scene belongs to
   1817           * @param   sceneID - ID to look for scene
   1818           *
   1819           * @return  TRUE if removed, FALSE if not found
   1820           */
   1821          uint8 zclGeneral_RemoveScene( uint8 endpoint, uint16 groupID, uint8 sceneID )
   1822          {
   1823            zclGenSceneItem_t *pLoop;
   1824            zclGenSceneItem_t *pPrev;
   1825          
   1826            // Look for end of list
   1827            pLoop = zclGenSceneTable;
   1828            pPrev = NULL;
   1829            while ( pLoop )
   1830            {
   1831              if ( pLoop->endpoint == endpoint
   1832                  && pLoop->scene.groupID == groupID && pLoop->scene.ID == sceneID )
   1833              {
   1834                if ( pPrev == NULL )
   1835                  zclGenSceneTable = pLoop->next;
   1836                else
   1837                  pPrev->next = pLoop->next;
   1838          
   1839                // Free the memory
   1840                osal_mem_free( pLoop );
   1841          
   1842                // Update NV
   1843                zclGeneral_ScenesWriteNV();
   1844          
   1845                return ( TRUE );
   1846              }
   1847              pPrev = pLoop;
   1848              pLoop = pLoop->next;
   1849            }
   1850          
   1851            return ( FALSE );
   1852          }
   1853          
   1854          /*********************************************************************
   1855           * @fn      zclGeneral_RemoveAllScenes
   1856           *
   1857           * @brief   Remove all scenes with endpoint and group Id
   1858           *
   1859           * @param   endpoint -
   1860           * @param   groupID - ID to look for group
   1861           *
   1862           * @return  none
   1863           */
   1864          void zclGeneral_RemoveAllScenes( uint8 endpoint, uint16 groupID )
   1865          {
   1866            zclGenSceneItem_t *pLoop;
   1867            zclGenSceneItem_t *pPrev;
   1868            zclGenSceneItem_t *pNext;
   1869          
   1870            // Look for end of list
   1871            pLoop = zclGenSceneTable;
   1872            pPrev = NULL;
   1873            while ( pLoop )
   1874            {
   1875              if ( pLoop->endpoint == endpoint && pLoop->scene.groupID == groupID )
   1876              {
   1877                if ( pPrev == NULL )
   1878                  zclGenSceneTable = pLoop->next;
   1879                else
   1880                  pPrev->next = pLoop->next;
   1881                pNext = pLoop->next;
   1882          
   1883                // Free the memory
   1884                osal_mem_free( pLoop );
   1885                pLoop = pNext;
   1886              }
   1887              else
   1888              {
   1889                pPrev = pLoop;
   1890                pLoop = pLoop->next;
   1891              }
   1892            }
   1893          
   1894            // Update NV
   1895            zclGeneral_ScenesWriteNV();
   1896          }
   1897          
   1898          /*********************************************************************
   1899           * @fn      zclGeneral_CountScenes
   1900           *
   1901           * @brief   Count the number of scenes for an endpoint
   1902           *
   1903           * @param   endpoint -
   1904           *
   1905           * @return  number of scenes assigned to an endpoint
   1906           */
   1907          uint8 zclGeneral_CountScenes( uint8 endpoint )
   1908          {
   1909            zclGenSceneItem_t *pLoop;
   1910            uint8 cnt = 0;
   1911          
   1912            // Look for end of list
   1913            pLoop = zclGenSceneTable;
   1914            while ( pLoop )
   1915            {
   1916              if ( pLoop->endpoint == endpoint  )
   1917                cnt++;
   1918              pLoop = pLoop->next;
   1919            }
   1920            return ( cnt );
   1921          }
   1922          
   1923          /*********************************************************************
   1924           * @fn      zclGeneral_CountAllScenes
   1925           *
   1926           * @brief   Count the total number of scenes
   1927           *
   1928           * @param   none
   1929           *
   1930           * @return  number of scenes
   1931           */
   1932          uint8 zclGeneral_CountAllScenes( void )
   1933          {
   1934            zclGenSceneItem_t *pLoop;
   1935            uint8 cnt = 0;
   1936          
   1937            // Look for end of list
   1938            pLoop = zclGenSceneTable;
   1939            while ( pLoop )
   1940            {
   1941              cnt++;
   1942              pLoop = pLoop->next;
   1943            }
   1944            return ( cnt );
   1945          }
   1946          
   1947          /*********************************************************************
   1948           * @fn      zclGeneral_ProcessInScenesServer
   1949           *
   1950           * @brief   Process in the received Scenes Command.
   1951           *
   1952           * @param   pInMsg - pointer to the incoming message
   1953           *
   1954           * @return  ZStatus_t
   1955           */
   1956          static ZStatus_t zclGeneral_ProcessInScenesServer( zclIncoming_t *pInMsg,
   1957                                                             zclGeneral_AppCallbacks_t *pCBs )
   1958          {
   1959            zclAttrRec_t attrRec;
   1960            zclGeneral_Scene_t scene;
   1961            zclGeneral_Scene_t *pScene;
   1962            uint8 *pData = pInMsg->pData;
   1963            uint8 nameLen;
   1964            uint8 status;
   1965            uint8 sceneCnt = 0;
   1966            uint8 *sceneList = NULL;
   1967            uint8 sendRsp = FALSE;
   1968            uint8 nameSupport = FALSE;
   1969            ZStatus_t stat = ZSuccess;
   1970          
   1971            osal_memset( (uint8*)&scene, 0, sizeof( zclGeneral_Scene_t ) );
   1972          
   1973            scene.groupID = BUILD_UINT16( pData[0], pData[1] );
   1974            pData += 2;   // Move past group ID
   1975            scene.ID = *pData++;
   1976          
   1977            switch ( pInMsg->hdr.commandID )
   1978            {
   1979              case COMMAND_SCENE_ADD:
   1980                // Parse the rest of the incoming message
   1981                scene.transTime = BUILD_UINT16( pData[0], pData[1] );
   1982                pData += 2;
   1983                nameLen= *pData++; // Name length
   1984          
   1985                // Retrieve Name Support attribute
   1986                if ( zclFindAttrRec( pInMsg->msg->endPoint, ZCL_CLUSTER_ID_GEN_SCENES, ATTRID_SCENES_NAME_SUPPORT, &attrRec ) )
   1987                  zclReadAttrData( &nameSupport, &attrRec, NULL );
   1988          
   1989                if ( nameSupport )
   1990                {
   1991                  if ( nameLen > (ZCL_GEN_SCENE_NAME_LEN-1) )
   1992                    nameLen = (ZCL_GEN_SCENE_NAME_LEN-1);
   1993                  scene.name[0] = nameLen;
   1994                  osal_memcpy( &(scene.name[1]), pData, nameLen );
   1995                }
   1996          
   1997                pData += nameLen; // move pass name
   1998          
   1999                scene.extLen = pInMsg->pDataLen - ( (uint16)( pData - pInMsg->pData ) );
   2000                if ( scene.extLen > 0 )
   2001                {
   2002                  // Copy the extention field(s)
   2003                  if ( scene.extLen > ZCL_GEN_SCENE_EXT_LEN )
   2004                    scene.extLen = ZCL_GEN_SCENE_EXT_LEN;
   2005                  osal_memcpy( scene.extField, pData, scene.extLen );
   2006                }
   2007          
   2008                if ( scene.groupID == 0x0000 ||
   2009                     aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) != NULL )
   2010                {
   2011                  // Either the Scene doesn't belong to a Group (Group ID = 0x0000) or it
   2012                  // does and the corresponding Group exits
   2013                  pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, scene.groupID, scene.ID );
   2014                  if ( pScene || ( zclGeneral_CountAllScenes() < ZCL_GEN_MAX_SCENES ) )
   2015                  {
   2016                    status = ZCL_STATUS_SUCCESS;
   2017                    if ( pScene != NULL )
   2018                    {
   2019                      // The Scene already exists so update it
   2020                      pScene->transTime = scene.transTime;
   2021                      osal_memcpy( pScene->name, scene.name, ZCL_GEN_SCENE_NAME_LEN );
   2022          
   2023                      // Use the new extention field(s)
   2024                      osal_memcpy( pScene->extField, scene.extField, scene.extLen );
   2025                      pScene->extLen = scene.extLen;
   2026          
   2027                      // Update NV
   2028                      zclGeneral_ScenesWriteNV();
   2029                    }
   2030                    else
   2031                    {
   2032                      // The Scene doesn't exist so add it
   2033                      zclGeneral_AddScene( pInMsg->msg->endPoint, &scene );
   2034                    }
   2035                  }
   2036                  else
   2037                    status = ZCL_STATUS_INSUFFICIENT_SPACE; // The Scene Table is full
   2038                }
   2039                else
   2040                  status = ZCL_STATUS_INVALID_FIELD; // The Group is not in the Group Table
   2041          
   2042                zclGeneral_SendSceneAddResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2043                                                 status, scene.groupID, scene.ID,
   2044                                                 true, pInMsg->hdr.transSeqNum );
   2045                stat = ZCL_STATUS_CMD_HAS_RSP;
   2046                break;
   2047          
   2048              case COMMAND_SCENE_VIEW:
   2049                pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, scene.groupID, scene.ID );
   2050                if ( pScene != NULL )
   2051                {
   2052                  status = ZCL_STATUS_SUCCESS;
   2053                }
   2054                else
   2055                {
   2056                  // Scene not found
   2057                  if ( scene.groupID != 0x0000 &&
   2058                       aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) == NULL )
   2059                  {
   2060                    status = ZCL_STATUS_INVALID_FIELD; // The Group is not in the Group Table
   2061                  }
   2062                  else
   2063                    status = ZCL_STATUS_NOT_FOUND;
   2064                  pScene = &scene;
   2065                }
   2066                zclGeneral_SendSceneViewResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2067                                                  status, pScene, true, pInMsg->hdr.transSeqNum );
   2068                stat = ZCL_STATUS_CMD_HAS_RSP;
   2069                break;
   2070          
   2071              case COMMAND_SCENE_REMOVE:
   2072                if ( zclGeneral_RemoveScene( pInMsg->msg->endPoint, scene.groupID, scene.ID ) )
   2073                {
   2074                  status = ZCL_STATUS_SUCCESS;
   2075                }
   2076                else
   2077                {
   2078                  // Scene not found
   2079                  if ( aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) == NULL )
   2080                  {
   2081                    // The Group is not in the Group Table
   2082                    status = ZCL_STATUS_INVALID_FIELD;
   2083                  }
   2084                  else
   2085                    status = ZCL_STATUS_NOT_FOUND;
   2086                }
   2087          
   2088                if ( UNICAST_MSG( pInMsg->msg ) )
   2089                {
   2090                  // Addressed to this device (not to a group) - send a response back
   2091                  zclGeneral_SendSceneRemoveResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2092                                                      status, scene.groupID,
   2093                                                      scene.ID, true, pInMsg->hdr.transSeqNum );
   2094                }
   2095                stat = ZCL_STATUS_CMD_HAS_RSP;
   2096                break;
   2097          
   2098              case COMMAND_SCENE_REMOVE_ALL:
   2099                if ( scene.groupID == 0x0000 ||
   2100                     aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) != NULL )
   2101                {
   2102                  zclGeneral_RemoveAllScenes( pInMsg->msg->endPoint, scene.groupID );
   2103                  status = ZCL_STATUS_SUCCESS;
   2104                }
   2105                else
   2106                  status = ZCL_STATUS_INVALID_FIELD;
   2107          
   2108                if ( UNICAST_MSG( pInMsg->msg ) )
   2109                {
   2110                  // Addressed to this device (not to a group) - send a response back
   2111                  zclGeneral_SendSceneRemoveAllResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2112                                                         status, scene.groupID, true, pInMsg->hdr.transSeqNum );
   2113                }
   2114                stat = ZCL_STATUS_CMD_HAS_RSP;
   2115                break;
   2116          
   2117              case COMMAND_SCENE_STORE:
   2118                if ( scene.groupID == 0x0000 ||
   2119                     aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) != NULL )
   2120                {
   2121                  // Either the Scene doesn't belong to a Group (Group ID = 0x0000) or it
   2122                  // does and the corresponding Group exits
   2123                  pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, scene.groupID, scene.ID );
   2124                  if ( pScene || ( zclGeneral_CountAllScenes() < ZCL_GEN_MAX_SCENES ) )
   2125                  {
   2126                    uint8 sceneChanged = FALSE;
   2127          
   2128                    status = ZCL_STATUS_SUCCESS;
   2129                    if ( pScene == NULL )
   2130                    {
   2131                      // Haven't been added yet
   2132                      pScene = &scene;
   2133                    }
   2134          
   2135                    if ( pCBs->pfnSceneStoreReq )
   2136                    {
   2137                      zclSceneReq_t req;
   2138          
   2139                      req.srcAddr = &(pInMsg->msg->srcAddr);
   2140                      req.scene = pScene;
   2141          
   2142                      // Get the latest Scene info
   2143                      if ( pCBs->pfnSceneStoreReq( &req ) )
   2144                        sceneChanged = TRUE;
   2145                    }
   2146          
   2147                    if ( pScene == &scene )
   2148                    {
   2149                      // The Scene doesn't exist so add it
   2150                      zclGeneral_AddScene( pInMsg->msg->endPoint, &scene );
   2151                    }
   2152                    else if ( sceneChanged )
   2153                    {
   2154                      // The Scene already exists so update only NV
   2155                      zclGeneral_ScenesWriteNV();
   2156                    }
   2157                  }
   2158                  else
   2159                    status = ZCL_STATUS_INSUFFICIENT_SPACE; // The Scene Table is full
   2160                }
   2161                else
   2162                  status = ZCL_STATUS_INVALID_FIELD; // The Group is not in the Group Table
   2163          
   2164                if ( UNICAST_MSG( pInMsg->msg ) )
   2165                {
   2166                  // Addressed to this device (not to a group) - send a response back
   2167                  zclGeneral_SendSceneStoreResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2168                                                     status, scene.groupID, scene.ID,
   2169                                                     true, pInMsg->hdr.transSeqNum );
   2170                }
   2171                stat = ZCL_STATUS_CMD_HAS_RSP;
   2172                break;
   2173          
   2174              case COMMAND_SCENE_RECALL:
   2175                pScene = zclGeneral_FindScene( pInMsg->msg->endPoint, scene.groupID, scene.ID );
   2176                if ( pScene && pCBs->pfnSceneRecallReq )
   2177                {
   2178                  zclSceneReq_t req;
   2179          
   2180                  req.srcAddr = &(pInMsg->msg->srcAddr);
   2181                  req.scene = pScene;
   2182          
   2183                  pCBs->pfnSceneRecallReq( &req );
   2184                }
   2185                // No response
   2186                break;
   2187          
   2188              case COMMAND_SCENE_GET_MEMBERSHIP:
   2189                // Find all the Scenes corresponding to the Group ID
   2190                if ( scene.groupID == 0x0000 ||
   2191                     aps_FindGroup( pInMsg->msg->endPoint, scene.groupID ) != NULL )
   2192                {
   2193                  // Allocate space for the scene list
   2194                  sceneList = osal_mem_alloc( ZCL_GEN_MAX_SCENES );
   2195                  if ( sceneList != NULL )
   2196                  {
   2197                    sceneCnt = zclGeneral_FindAllScenesForGroup( pInMsg->msg->endPoint, 
   2198                                                                 scene.groupID, sceneList ); 
   2199                    status = ZCL_STATUS_SUCCESS;
   2200                    if ( UNICAST_MSG( pInMsg->msg ) )
   2201                    {
   2202                      // Addressed only to this device - send a response back
   2203                      sendRsp = TRUE;
   2204                    }
   2205                    else
   2206                    {
   2207                      // Addressed to the Group - ONLY send a response if an entry within the 
   2208                      // Scene Table corresponds to the Group ID
   2209                      if ( sceneCnt != 0 )
   2210                        sendRsp = TRUE;
   2211                    }
   2212                  }
   2213                  else
   2214                  {
   2215                    // Couldn't allocate space for the scene list!
   2216                    status = ZCL_STATUS_INSUFFICIENT_SPACE;
   2217                    sendRsp = TRUE;
   2218                  }
   2219                }
   2220                else
   2221                {
   2222                  // The Group is not in the Group Table - send a response back
   2223                  status = ZCL_STATUS_INVALID_FIELD;
   2224                  sendRsp = TRUE;
   2225                }
   2226          
   2227                if ( sendRsp )
   2228                {
   2229                  zclGeneral_SendSceneGetMembershipResponse( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2230                                              status, zclGeneral_ScenesRemaingCapacity(), sceneCnt, sceneList,
   2231                                              scene.groupID, true, pInMsg->hdr.transSeqNum );
   2232                }
   2233                
   2234                if ( sceneList != NULL )
   2235                  osal_mem_free( sceneList );
   2236                
   2237                stat = ZCL_STATUS_CMD_HAS_RSP;
   2238                break;
   2239          
   2240              default:
   2241                stat = ZFailure;
   2242              break;
   2243            }
   2244          
   2245            return ( stat );
   2246          }
   2247          
   2248          /*********************************************************************
   2249           * @fn      zclGeneral_ProcessInScenesClient
   2250           *
   2251           * @brief   Process in the received Scenes Command.
   2252           *
   2253           * @param   pInMsg - pointer to the incoming message
   2254           *
   2255           * @return  ZStatus_t
   2256           */
   2257          static ZStatus_t zclGeneral_ProcessInScenesClient( zclIncoming_t *pInMsg,
   2258                                                             zclGeneral_AppCallbacks_t *pCBs )
   2259          {
   2260            zclGeneral_Scene_t scene;
   2261            uint8 *pData = pInMsg->pData;
   2262            uint8 nameLen;
   2263            zclSceneRsp_t rsp;
   2264            uint8 i;
   2265            ZStatus_t stat = ZSuccess;
   2266          
   2267            osal_memset( (uint8*)&scene, 0, sizeof( zclGeneral_Scene_t ) );
   2268            osal_memset( (uint8*)&rsp, 0, sizeof( zclSceneRsp_t ) );
   2269          
   2270            // Get the status field first
   2271            rsp.status = *pData++;
   2272          
   2273            if ( pInMsg->hdr.commandID == COMMAND_SCENE_GET_MEMBERSHIP_RSP )
   2274              rsp.capacity = *pData++;
   2275          
   2276            scene.groupID = BUILD_UINT16( pData[0], pData[1] );
   2277            pData += 2;   // Move past group ID
   2278          
   2279            switch ( pInMsg->hdr.commandID )
   2280            {
   2281              case COMMAND_SCENE_VIEW_RSP:
   2282                // Parse the rest of the incoming message
   2283                scene.ID = *pData++; // Not applicable to Remove All Response command
   2284                scene.transTime = BUILD_UINT16( pData[0], pData[1] );
   2285                pData += 2;
   2286                nameLen = *pData++; // Name length
   2287                if ( nameLen > (ZCL_GEN_SCENE_NAME_LEN-1) )
   2288                  nameLen = (ZCL_GEN_SCENE_NAME_LEN-1);
   2289                scene.name[0] = nameLen;
   2290                osal_memcpy( &(scene.name[1]), pData, nameLen );
   2291                pData += nameLen; // move pass name
   2292          
   2293                //*** Do something with the extension field(s)
   2294          
   2295                // Fall through to callback - break is left off intentionally
   2296          
   2297              case COMMAND_SCENE_ADD_RSP:
   2298              case COMMAND_SCENE_REMOVE_RSP:
   2299              case COMMAND_SCENE_REMOVE_ALL_RSP:
   2300              case COMMAND_SCENE_STORE_RSP:
   2301                if ( pCBs->pfnSceneRsp )
   2302                {
   2303                  rsp.srcAddr = &(pInMsg->msg->srcAddr);
   2304                  rsp.cmdID = pInMsg->hdr.commandID;
   2305                  rsp.scene = &scene;
   2306          
   2307                  pCBs->pfnSceneRsp( &rsp );
   2308                }
   2309                break;
   2310          
   2311              case COMMAND_SCENE_GET_MEMBERSHIP_RSP:
   2312                {
   2313                  uint8 *sceneList = NULL;
   2314                  
   2315                  if ( rsp.status == ZCL_STATUS_SUCCESS )
   2316                  {
   2317                    uint8 sceneCnt = *pData++;
   2318                    
   2319                    if ( sceneCnt > 0 )
   2320                    {
   2321                      // Allocate space for the scene list
   2322                      sceneList = osal_mem_alloc( sceneCnt );
   2323                      if ( sceneList != NULL )
   2324                      {
   2325                        rsp.sceneCnt = sceneCnt;
   2326                        for ( i = 0; i < sceneCnt; i++ )
   2327                          sceneList[i] = *pData++;
   2328                      }
   2329                    }
   2330                  }
   2331            
   2332                  if ( pCBs->pfnSceneRsp )
   2333                  {
   2334                    rsp.srcAddr = &(pInMsg->msg->srcAddr);
   2335                    rsp.cmdID = pInMsg->hdr.commandID;
   2336                    rsp.sceneList = sceneList;
   2337                    rsp.scene = &scene;
   2338            
   2339                    pCBs->pfnSceneRsp( &rsp);
   2340                  }
   2341                  
   2342                  if ( sceneList != NULL )
   2343                  {
   2344                    osal_mem_free( sceneList );
   2345                  }
   2346                }
   2347                break;
   2348          
   2349              default:
   2350                stat = ZFailure;
   2351                break;
   2352            }
   2353          
   2354            return ( stat );
   2355          }
   2356          #endif // ZCL_SCENES
   2357          
   2358          #ifdef ZCL_ON_OFF
   2359          /*********************************************************************
   2360           * @fn      zclGeneral_ProcessInCmdOnOff
   2361           *
   2362           * @brief   Process in the received On/Off Command.
   2363           *
   2364           * @param   pInMsg - pointer to the incoming message
   2365           *
   2366           * @return  ZStatus_t
   2367           */
   2368          static ZStatus_t zclGeneral_ProcessInOnOff( zclIncoming_t *pInMsg,
   2369                                                      zclGeneral_AppCallbacks_t *pCBs )
   2370          {
   2371            if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   2372            {
   2373              if ( pInMsg->hdr.commandID > COMMAND_TOGGLE )
   2374                return ( ZFailure );   // Error ignore the command
   2375          
   2376              if ( pCBs->pfnOnOff )
   2377                pCBs->pfnOnOff( pInMsg->hdr.commandID );
   2378            }
   2379            // no Client command
   2380          
   2381            return ( ZSuccess );
   2382          }
   2383          #endif // ZCL_ON_OFF
   2384          
   2385          #ifdef ZCL_LEVEL_CTRL
   2386          /*********************************************************************
   2387           * @fn      zclGeneral_ProcessInLevelControl
   2388           *
   2389           * @brief   Process in the received Level Control Command.
   2390           *
   2391           * @param   pInMsg - pointer to the incoming message
   2392           *
   2393           * @return  ZStatus_t
   2394           */
   2395          static ZStatus_t zclGeneral_ProcessInLevelControl( zclIncoming_t *pInMsg,
   2396                                                             zclGeneral_AppCallbacks_t *pCBs )
   2397          {
   2398            uint8 withOnOff = FALSE;
   2399            ZStatus_t stat = ZSuccess;
   2400          
   2401            if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
   2402            {
   2403              switch ( pInMsg->hdr.commandID )
   2404              {
   2405                case COMMAND_LEVEL_MOVE_TO_LEVEL_WITH_ON_OFF:
   2406                  withOnOff = TRUE;
   2407                  // fall through
   2408                case COMMAND_LEVEL_MOVE_TO_LEVEL:
   2409                  if ( pCBs->pfnLevelControlMoveToLevel )
   2410                  {
   2411                    zclLCMoveToLevel_t cmd;
   2412          
   2413                    cmd.level = pInMsg->pData[0];
   2414                    cmd.transitionTime = BUILD_UINT16( pInMsg->pData[1], pInMsg->pData[2] );
   2415                    cmd.withOnOff = withOnOff;
   2416          
   2417                    pCBs->pfnLevelControlMoveToLevel( &cmd );
   2418                  }
   2419                  break;
   2420          
   2421                case COMMAND_LEVEL_MOVE_WITH_ON_OFF:
   2422                  withOnOff = TRUE;
   2423                  // fall through
   2424                case COMMAND_LEVEL_MOVE:
   2425                  if ( pCBs->pfnLevelControlMove )
   2426                  {
   2427                    zclLCMove_t cmd;
   2428          
   2429                    cmd.moveMode = pInMsg->pData[0];
   2430                    cmd.rate = pInMsg->pData[1];
   2431                    cmd.withOnOff = withOnOff;
   2432          
   2433                    pCBs->pfnLevelControlMove( &cmd );
   2434                  }
   2435                  break;
   2436          
   2437                case COMMAND_LEVEL_STEP_WITH_ON_OFF:
   2438                  withOnOff = TRUE;
   2439                  // fall through
   2440                case COMMAND_LEVEL_STEP:
   2441                  if ( pCBs->pfnLevelControlStep )
   2442                  {
   2443                    zclLCStep_t cmd;
   2444          
   2445                    cmd.stepMode = pInMsg->pData[0];
   2446                    cmd.amount =  pInMsg->pData[1];
   2447                    cmd.transitionTime = BUILD_UINT16( pInMsg->pData[2], pInMsg->pData[3] );
   2448                    cmd.withOnOff = withOnOff;
   2449          
   2450                    pCBs->pfnLevelControlStep( &cmd );
   2451                  }
   2452                  break;
   2453          
   2454                case COMMAND_LEVEL_STOP:
   2455                case COMMAND_LEVEL_STOP_WITH_ON_OFF:
   2456                  // Both Stop commands are identical
   2457                  if ( pCBs->pfnLevelControlStop )
   2458                  {
   2459                    pCBs->pfnLevelControlStop();
   2460                  }
   2461                  break;
   2462          
   2463                default:
   2464                  stat = ZFailure;
   2465                  break;
   2466              }
   2467            }
   2468            // no Client command
   2469          
   2470            return ( stat );
   2471          }
   2472          #endif // ZCL_LEVEL_CTRL
   2473          
   2474          #ifdef ZCL_ALARMS
   2475          /*********************************************************************
   2476           * @fn      zclGeneral_AddAlarm
   2477           *
   2478           * @brief   Add an alarm for a cluster
   2479           *
   2480           * @param   endpoint -
   2481           * @param   alarm - new alarm item
   2482           *
   2483           * @return  ZStatus_t
   2484           */
   2485          ZStatus_t zclGeneral_AddAlarm( uint8 endpoint, zclGeneral_Alarm_t *alarm )
   2486          {
   2487            zclGenAlarmItem_t *pNewItem;
   2488            zclGenAlarmItem_t *pLoop;
   2489          
   2490            // Fill in the new profile list
   2491            pNewItem = osal_mem_alloc( sizeof( zclGenAlarmItem_t ) );
   2492            if ( pNewItem == NULL )
   2493              return ( ZMemError );
   2494          
   2495            // Fill in the plugin record.
   2496            pNewItem->next = (zclGenAlarmItem_t *)NULL;
   2497            pNewItem->endpoint =  endpoint;
   2498            osal_memcpy( (uint8*)(&pNewItem->alarm), (uint8*)alarm, sizeof ( zclGeneral_Alarm_t ) );
   2499          
   2500            // Find spot in list
   2501            if (  zclGenAlarmTable == NULL )
   2502            {
   2503              zclGenAlarmTable = pNewItem;
   2504            }
   2505            else
   2506            {
   2507              // Look for end of list
   2508              pLoop = zclGenAlarmTable;
   2509              while ( pLoop->next != NULL )
   2510                pLoop = pLoop->next;
   2511          
   2512              // Put new item at end of list
   2513              pLoop->next = pNewItem;
   2514            }
   2515          
   2516            return ( ZSuccess );
   2517          }
   2518          
   2519          /*********************************************************************
   2520           * @fn      zclGeneral_FindAlarm
   2521           *
   2522           * @brief   Find an alarm with alarmCode and clusterID
   2523           *
   2524           * @param   endpoint -
   2525           * @param   groupID - what group the scene belongs to
   2526           * @param   sceneID - ID to look for scene
   2527           *
   2528           * @return  a pointer to the alarm information, NULL if not found
   2529           */
   2530          zclGeneral_Alarm_t *zclGeneral_FindAlarm( uint8 endpoint, uint8 alarmCode, uint16 clusterID )
   2531          {
   2532            zclGenAlarmItem_t *pLoop;
   2533          
   2534            // Look for the alarm
   2535            pLoop = zclGenAlarmTable;
   2536            while ( pLoop )
   2537            {
   2538              if ( pLoop->endpoint == endpoint &&
   2539                   pLoop->alarm.code == alarmCode && pLoop->alarm.clusterID == clusterID )
   2540              {
   2541                return ( &(pLoop->alarm) );
   2542              }
   2543              pLoop = pLoop->next;
   2544            }
   2545          
   2546            return ( (zclGeneral_Alarm_t *)NULL );
   2547          }
   2548          
   2549          /*********************************************************************
   2550           * @fn      zclGeneral_FindEarliestAlarm
   2551           *
   2552           * @brief   Find an alarm with the earliest timestamp
   2553           *
   2554           * @param   endpoint -
   2555           *
   2556           * @return  a pointer to the alarm information, NULL if not found
   2557           */
   2558          zclGeneral_Alarm_t *zclGeneral_FindEarliestAlarm( uint8 endpoint )
   2559          {
   2560            zclGenAlarmItem_t *pLoop;
   2561            zclGenAlarmItem_t earliestAlarm;
   2562            zclGenAlarmItem_t *pEarliestAlarm = &earliestAlarm;
   2563          
   2564            pEarliestAlarm->alarm.timeStamp = 0xFFFFFFFF;
   2565          
   2566            // Look for alarm with earliest time
   2567            pLoop = zclGenAlarmTable;
   2568            while ( pLoop )
   2569            {
   2570              if ( pLoop->endpoint == endpoint &&
   2571                   pLoop->alarm.timeStamp < pEarliestAlarm->alarm.timeStamp )
   2572              {
   2573                pEarliestAlarm = pLoop;
   2574              }
   2575              pLoop = pLoop->next;
   2576            }
   2577          
   2578            if ( pEarliestAlarm->alarm.timeStamp != 0xFFFFFFFF )
   2579              return ( &(pEarliestAlarm->alarm) );
   2580          
   2581            // No alarm
   2582            return ( (zclGeneral_Alarm_t *)NULL );
   2583          }
   2584          
   2585          /*********************************************************************
   2586           * @fn      zclGeneral_ResetAlarm
   2587           *
   2588           * @brief   Remove a scene with endpoint and sceneID
   2589           *
   2590           * @param   endpoint -
   2591           * @param   alarmCode -
   2592           * @param   clusterID -
   2593           *
   2594           * @return  TRUE if removed, FALSE if not found
   2595           */
   2596          void zclGeneral_ResetAlarm( uint8 endpoint, uint8 alarmCode, uint16 clusterID )
   2597          {
   2598            zclGenAlarmItem_t *pLoop;
   2599            zclGenAlarmItem_t *pPrev;
   2600          
   2601            // Look for end of list
   2602            pLoop = zclGenAlarmTable;
   2603            pPrev = NULL;
   2604            while ( pLoop )
   2605            {
   2606              if ( pLoop->endpoint == endpoint &&
   2607                   pLoop->alarm.code == alarmCode && pLoop->alarm.clusterID == clusterID )
   2608              {
   2609                if ( pPrev == NULL )
   2610                  zclGenAlarmTable = pLoop->next;
   2611                else
   2612                  pPrev->next = pLoop->next;
   2613          
   2614                // Free the memory
   2615                osal_mem_free( pLoop );
   2616          
   2617                // Notify the Application so that if the alarm condition still active then
   2618                // a new notification will be generated, and a new alarm record will be
   2619                // added to the alarm log
   2620                // zclGeneral_NotifyReset( alarmCode, clusterID ); // callback function?
   2621                return;
   2622              }
   2623              pPrev = pLoop;
   2624              pLoop = pLoop->next;
   2625            }
   2626          }
   2627          
   2628          /*********************************************************************
   2629           * @fn      zclGeneral_ResetAllAlarms
   2630           *
   2631           * @brief   Remove all alarms with endpoint
   2632           *
   2633           * @param   endpoint -
   2634           * @param   notifyApp -
   2635           *
   2636           * @return  none
   2637           */
   2638          void zclGeneral_ResetAllAlarms( uint8 endpoint, uint8 notifyApp )
   2639          {
   2640            zclGenAlarmItem_t *pLoop;
   2641            zclGenAlarmItem_t *pPrev;
   2642            zclGenAlarmItem_t *pNext;
   2643          
   2644            // Look for end of list
   2645            pLoop = zclGenAlarmTable;
   2646            pPrev = NULL;
   2647            while ( pLoop )
   2648            {
   2649              if (  pLoop->endpoint == endpoint )
   2650              {
   2651                if ( pPrev == NULL )
   2652                  zclGenAlarmTable = pLoop->next;
   2653                else
   2654                  pPrev->next = pLoop->next;
   2655          
   2656                pNext = pLoop->next;
   2657          
   2658                // Free the memory
   2659                osal_mem_free( pLoop );
   2660          
   2661                pLoop = pNext;
   2662              }
   2663              else
   2664              {
   2665                pPrev = pLoop;
   2666                pLoop = pLoop->next;
   2667              }
   2668            }
   2669          
   2670            if ( notifyApp )
   2671            {
   2672              // Notify the Application so that if any alarm conditions still active then
   2673              // a new notification will be generated, and a new alarm record will be
   2674              // added to the alarm log
   2675              // zclGeneral_NotifyResetAll(); // callback function?
   2676            }
   2677          }
   2678          
   2679          /*********************************************************************
   2680           * @fn      zclGeneral_ProcessInAlarmsServer
   2681           *
   2682           * @brief   Process in the received Alarms Command.
   2683           *
   2684           * @param   pInMsg - pointer to the incoming message
   2685           *
   2686           * @return  ZStatus_t
   2687           */
   2688          static ZStatus_t zclGeneral_ProcessInAlarmsServer( zclIncoming_t *pInMsg,
   2689                                                             zclGeneral_AppCallbacks_t *pCBs )
   2690          {
   2691            zclGeneral_Alarm_t *pAlarm;
   2692            uint8 *pData = pInMsg->pData;
   2693            ZStatus_t stat = ZSuccess;
   2694          
   2695            switch ( pInMsg->hdr.commandID )
   2696            {
   2697              case COMMAND_ALARMS_RESET:
   2698                zclGeneral_ResetAlarm( pInMsg->msg->endPoint, pData[0],
   2699                                       BUILD_UINT16( pData[1], pData[2] ) );
   2700                break;
   2701          
   2702              case COMMAND_ALARMS_RESET_ALL:
   2703                zclGeneral_ResetAllAlarms( pInMsg->msg->endPoint, TRUE );
   2704                break;
   2705          
   2706              case COMMAND_ALARMS_GET:
   2707                pAlarm = zclGeneral_FindEarliestAlarm( pInMsg->msg->endPoint );
   2708                if ( pAlarm )
   2709                {
   2710                  // Send a response back
   2711                  zclGeneral_SendAlarmGetRespnose( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2712                                                   ZCL_STATUS_SUCCESS, pAlarm->code,
   2713                                                   pAlarm->clusterID, pAlarm->timeStamp,
   2714                                                   true, pInMsg->hdr.transSeqNum );
   2715                  // Remove the entry from the Alarm table
   2716                  zclGeneral_ResetAlarm( pInMsg->msg->endPoint, pAlarm->code, pAlarm->clusterID );
   2717                }
   2718                else
   2719                {
   2720                  // Send a response back
   2721                  zclGeneral_SendAlarmGetRespnose( pInMsg->msg->endPoint, &pInMsg->msg->srcAddr,
   2722                                                   ZCL_STATUS_NOT_FOUND, 0, 0, 0,
   2723                                                   true, pInMsg->hdr.transSeqNum );
   2724                }
   2725                stat = ZCL_STATUS_CMD_HAS_RSP;
   2726                break;
   2727          
   2728              case COMMAND_ALARMS_RESET_LOG:
   2729                zclGeneral_ResetAllAlarms( pInMsg->msg->endPoint, FALSE );
   2730                break;
   2731          
   2732              default:
   2733                stat = ZFailure;
   2734                break;
   2735            }
   2736          
   2737            return ( stat );
   2738          }
   2739          
   2740          /*********************************************************************
   2741           * @fn      zclGeneral_ProcessInAlarmsClient
   2742           *
   2743           * @brief   Process in the received Alarms Command.
   2744           *
   2745           * @param   pInMsg - pointer to the incoming message
   2746           *
   2747           * @return  ZStatus_t
   2748           */
   2749          static ZStatus_t zclGeneral_ProcessInAlarmsClient( zclIncoming_t *pInMsg,
   2750                                                             zclGeneral_AppCallbacks_t *pCBs )
   2751          {
   2752            uint8 *pData = pInMsg->pData;
   2753            zclAlarm_t alarm;
   2754            ZStatus_t stat = ZSuccess;
   2755          
   2756            osal_memset( (uint8*)&alarm, 0, sizeof( zclAlarm_t ) );
   2757          
   2758            switch ( pInMsg->hdr.commandID )
   2759            {
   2760              case COMMAND_ALARMS_ALARM:
   2761                if ( pCBs->pfnAlarm )
   2762                {
   2763                  alarm.srcAddr = &(pInMsg->msg->srcAddr);
   2764                  alarm.cmdID = pInMsg->hdr.commandID;
   2765                  alarm.status = *pData++;
   2766                  alarm.alarmCode = *pData++;
   2767                  alarm.clusterID = BUILD_UINT16( pData[0], pData[1] );
   2768                  pData += 2;
   2769                  alarm.timeStamp = osal_build_uint32( pData, 4 );
   2770          
   2771                  pCBs->pfnAlarm( &alarm );
   2772                }
   2773                break;
   2774          
   2775              case COMMAND_ALARMS_GET_RSP:
   2776                if ( pCBs->pfnAlarm )
   2777                {
   2778                  alarm.srcAddr = &(pInMsg->msg->srcAddr);
   2779                  alarm.cmdID = pInMsg->hdr.commandID;
   2780                  alarm.alarmCode = *pData++;
   2781                  alarm.clusterID = BUILD_UINT16( pData[0], pData[1] );
   2782          
   2783                  pCBs->pfnAlarm( &alarm );
   2784                }
   2785                break;
   2786          
   2787              default:
   2788                stat = ZFailure;
   2789                break;
   2790            }
   2791          
   2792            return ( stat );
   2793          }
   2794          #endif // ZCL_ALARMS
   2795          
   2796          #ifdef ZCL_LOCATION
   2797          /*********************************************************************
   2798           * @fn      zclGeneral_ProcessInLocationServer
   2799           *
   2800           * @brief   Process in the received Location Command.
   2801           *
   2802           * @param   pInMsg - pointer to the incoming message
   2803           *
   2804           * @return  ZStatus_t
   2805           */
   2806          static ZStatus_t zclGeneral_ProcessInLocationServer( zclIncoming_t *pInMsg,
   2807                                                               zclGeneral_AppCallbacks_t *pCBs )
   2808          {
   2809            uint8 *pData = pInMsg->pData;
   2810            zclLocation_t cmd;
   2811            ZStatus_t stat = ZSuccess;
   2812          
   2813            osal_memset( (uint8*)&cmd, 0, sizeof( zclLocation_t ) );
   2814          
   2815            switch ( pInMsg->hdr.commandID )
   2816            {
   2817              case COMMAND_LOCATION_SET_ABSOLUTE:
   2818                cmd.un.absLoc.coordinate1 = BUILD_UINT16( pData[0], pData[1] );
   2819                pData += 2;
   2820                cmd.un.absLoc.coordinate2 = BUILD_UINT16( pData[0], pData[1] );
   2821                pData += 2;
   2822                cmd.un.absLoc.coordinate3 = BUILD_UINT16( pData[0], pData[1] );
   2823                pData += 2;
   2824                cmd.un.absLoc.power = BUILD_UINT16( pData[0], pData[1] );
   2825                pData += 2;
   2826                cmd.un.absLoc.pathLossExponent = BUILD_UINT16( pData[0], pData[1] );
   2827          
   2828                if ( pCBs->pfnLocation )
   2829                {
   2830                  cmd.srcAddr = &(pInMsg->msg->srcAddr);
   2831                  cmd.cmdID = pInMsg->hdr.commandID;
   2832          
   2833                  // Update the absolute location info
   2834                  pCBs->pfnLocation( &cmd );
   2835                }
   2836                break;
   2837          
   2838              case COMMAND_LOCATION_SET_DEV_CFG:
   2839                cmd.un.devCfg.power = BUILD_UINT16( pData[0], pData[1] );
   2840                pData += 2;
   2841                cmd.un.devCfg.pathLossExponent = BUILD_UINT16( pData[0], pData[1] );
   2842                pData += 2;
   2843                cmd.un.devCfg.calcPeriod = BUILD_UINT16( pData[0], pData[1] );
   2844                pData += 2;
   2845                cmd.un.devCfg.numMeasurements = *pData++;
   2846                cmd.un.devCfg.reportPeriod = BUILD_UINT16( pData[0], pData[1] );
   2847          
   2848                if ( pCBs->pfnLocation )
   2849                {
   2850                  cmd.srcAddr = &(pInMsg->msg->srcAddr);
   2851                  cmd.cmdID = pInMsg->hdr.commandID;
   2852          
   2853                  // Update the device configuration info
   2854                  pCBs->pfnLocation( &cmd );
   2855                }
   2856                break;
   2857          
   2858              case COMMAND_LOCATION_GET_DEV_CFG:
   2859                cmd.un.ieeeAddr = pData;
   2860          
   2861                if ( pCBs->pfnLocation )
   2862                {
   2863                  cmd.srcAddr = &(pInMsg->msg->srcAddr);
   2864                  cmd.cmdID = pInMsg->hdr.commandID;
   2865                  cmd.seqNum = pInMsg->hdr.transSeqNum;
   2866          
   2867                  // Retreive the Device Configuration
   2868                  pCBs->pfnLocation( &cmd );
   2869                }
   2870                stat = ZCL_STATUS_CMD_HAS_RSP;
   2871                break;
   2872          
   2873              case COMMAND_LOCATION_GET_DATA:
   2874                cmd.un.loc.bitmap.locByte = *pData++;
   2875                cmd.un.loc.numResponses = *pData++;
   2876          
   2877                if ( cmd.un.loc.brdcastResponse == 0 ) // command is sent as a unicast
   2878                  osal_cpyExtAddr( cmd.un.loc.targetAddr, pData );
   2879          
   2880                if ( pCBs->pfnLocation )
   2881                {
   2882                  cmd.srcAddr = &(pInMsg->msg->srcAddr);
   2883                  cmd.cmdID = pInMsg->hdr.commandID;
   2884                  cmd.seqNum = pInMsg->hdr.transSeqNum;
   2885          
   2886                  // Retreive the Location Data
   2887                  pCBs->pfnLocation( &cmd );
   2888                }
   2889                stat = ZCL_STATUS_CMD_HAS_RSP;
   2890                break;
   2891          
   2892              default:
   2893                stat = ZFailure;
   2894                break;
   2895            }
   2896          
   2897            return ( stat );
   2898          }
   2899          
   2900          /*********************************************************************
   2901           * @fn      zclGeneral_ProcessInLocationDataRsp
   2902           *
   2903           * @brief   Process in the received Location Command.
   2904           *
   2905           * @param   pInMsg - pointer to the incoming message
   2906           *
   2907           * @return  ZStatus_t
   2908           */
   2909          static void zclGeneral_ProcessInLocationDataRsp( zclIncoming_t *pInMsg,
   2910                                                           zclGeneral_AppCallbacks_t *pCBs )
   2911          {
   2912            uint8 *pData = pInMsg->pData;
   2913            zclLocationRsp_t rsp;
   2914          
   2915            osal_memset( (uint8*)&rsp, 0, sizeof( zclLocationRsp_t ) );
   2916          
   2917            if ( pCBs->pfnLocationRsp )
   2918            {
   2919              if ( pInMsg->hdr.commandID == COMMAND_LOCATION_DATA_RSP )
   2920                rsp.un.loc.status = *pData++;
   2921          
   2922              if ( pInMsg->hdr.commandID != COMMAND_LOCATION_DATA_RSP ||
   2923                   rsp.un.loc.status == ZCL_STATUS_SUCCESS )
   2924              {
   2925                rsp.un.loc.data.type = *pData++;
   2926                rsp.un.loc.data.absLoc.coordinate1 = BUILD_UINT16( pData[0], pData[1] );
   2927                pData += 2;
   2928                rsp.un.loc.data.absLoc.coordinate2 = BUILD_UINT16( pData[0], pData[1] );
   2929                pData += 2;
   2930          
   2931                if ( locationType2D( rsp.un.loc.data.type ) == 0 )
   2932                {
   2933                  rsp.un.loc.data.absLoc.coordinate3 = BUILD_UINT16( pData[0], pData[1] );
   2934                  pData += 2;
   2935                }
   2936          
   2937                if ( pInMsg->hdr.commandID != COMMAND_LOCATION_COMPACT_DATA_NOTIF )
   2938                {
   2939                  rsp.un.loc.data.absLoc.power = BUILD_UINT16( pData[0], pData[1] );
   2940                  pData += 2;
   2941                  rsp.un.loc.data.absLoc.pathLossExponent = BUILD_UINT16( pData[0], pData[1] );
   2942                  pData += 2;
   2943                }
   2944          
   2945                if ( locationTypeAbsolute( rsp.un.loc.data.type ) == 0 )
   2946                {
   2947                  if ( pInMsg->hdr.commandID != COMMAND_LOCATION_COMPACT_DATA_NOTIF )
   2948                    rsp.un.loc.data.calcLoc.locationMethod = *pData++;
   2949          
   2950                  rsp.un.loc.data.calcLoc.qualityMeasure = *pData++;
   2951                  rsp.un.loc.data.calcLoc.locationAge = BUILD_UINT16( pData[0], pData[1] );
   2952                }
   2953              }
   2954          
   2955              rsp.srcAddr = &(pInMsg->msg->srcAddr);
   2956              rsp.cmdID = pInMsg->hdr.commandID;
   2957          
   2958              // Notify the Application
   2959              pCBs->pfnLocationRsp( &rsp );
   2960            }
   2961          }
   2962          
   2963          /*********************************************************************
   2964           * @fn      zclGeneral_ProcessInLocationClient
   2965           *
   2966           * @brief   Process in the received Location Command.
   2967           *
   2968           * @param   pInMsg - pointer to the incoming message
   2969           *
   2970           * @return  ZStatus_t
   2971           */
   2972          static ZStatus_t zclGeneral_ProcessInLocationClient( zclIncoming_t *pInMsg,
   2973                                                               zclGeneral_AppCallbacks_t *pCBs )
   2974          {
   2975            uint8 *pData = pInMsg->pData;
   2976            zclLocationRsp_t rsp;
   2977            ZStatus_t stat = ZSuccess;
   2978          
   2979            osal_memset( (uint8*)&rsp, 0, sizeof( zclLocationRsp_t ) );
   2980          
   2981            switch ( pInMsg->hdr.commandID )
   2982            {
   2983              case COMMAND_LOCATION_DEV_CFG_RSP:
   2984                if ( pCBs->pfnLocationRsp )
   2985                {
   2986                  rsp.un.devCfg.status = *pData++;
   2987                  if ( rsp.un.devCfg.status == ZCL_STATUS_SUCCESS )
   2988                  {
   2989                    rsp.un.devCfg.data.power = BUILD_UINT16( pData[0], pData[1] );
   2990                    pData += 2;
   2991                    rsp.un.devCfg.data.pathLossExponent = BUILD_UINT16( pData[0], pData[1] );
   2992                    pData += 2;
   2993                    rsp.un.devCfg.data.calcPeriod = BUILD_UINT16( pData[0], pData[1] );
   2994                    pData += 2;
   2995                    rsp.un.devCfg.data.numMeasurements = *pData++;
   2996                    rsp.un.devCfg.data.reportPeriod = BUILD_UINT16( pData[0], pData[1] );
   2997          
   2998                    rsp.srcAddr = &(pInMsg->msg->srcAddr);
   2999                    rsp.cmdID = pInMsg->hdr.commandID;
   3000          
   3001                    // Notify the Application
   3002                    pCBs->pfnLocationRsp( &rsp );
   3003                  }
   3004                }
   3005                break;
   3006          
   3007              case COMMAND_LOCATION_DATA_RSP:
   3008              case COMMAND_LOCATION_DATA_NOTIF:
   3009              case COMMAND_LOCATION_COMPACT_DATA_NOTIF:
   3010                zclGeneral_ProcessInLocationDataRsp( pInMsg, pCBs );
   3011                break;
   3012          
   3013              case COMMAND_LOCATION_RSSI_PING:
   3014                if ( pCBs->pfnLocationRsp )
   3015                {
   3016                  rsp.un.locationType = *pData;
   3017          
   3018                  rsp.srcAddr = &(pInMsg->msg->srcAddr);
   3019                  rsp.cmdID = pInMsg->hdr.commandID;
   3020          
   3021                  // Notify the Application
   3022                  pCBs->pfnLocationRsp( &rsp );
   3023                }
   3024                break;
   3025          
   3026              default:
   3027                stat = ZFailure;
   3028                break;
   3029            }
   3030          
   3031            return ( stat );
   3032          }
   3033          #endif // ZCL_LOCATION
   3034          
   3035          #ifdef ZCL_SCENES
   3036          /*********************************************************************
   3037           * @fn      zclGeneral_ScenesInitNV
   3038           *
   3039           * @brief   Initialize the NV Scene Table Items
   3040           *
   3041           * @param   none
   3042           *
   3043           * @return  number of scenes
   3044           */
   3045          static uint8 zclGeneral_ScenesInitNV( void )
   3046          {
   3047            uint8  status;
   3048            uint16 size;
   3049          
   3050            size = (uint16)((sizeof ( nvGenScenesHdr_t ))
   3051                            + ( sizeof( zclGenSceneNVItem_t ) * ZCL_GEN_MAX_SCENES ));
   3052          
   3053            status = osal_nv_item_init( ZCD_NV_SCENE_TABLE, size, NULL );
   3054          
   3055            if ( status != ZSUCCESS )
   3056            {
   3057              zclGeneral_ScenesSetDefaultNV();
   3058            }
   3059          
   3060            return status;
   3061          }
   3062          
   3063          /*********************************************************************
   3064           * @fn          zclGeneral_ScenesSetDefaultNV
   3065           *
   3066           * @brief       Write the defaults to NV
   3067           *
   3068           * @param       none
   3069           *
   3070           * @return      none
   3071           */
   3072          static void zclGeneral_ScenesSetDefaultNV( void )
   3073          {
   3074            nvGenScenesHdr_t hdr;
   3075          
   3076            // Initialize the header
   3077            hdr.numRecs = 0;
   3078          
   3079            // Save off the header
   3080            osal_nv_write( ZCD_NV_SCENE_TABLE, 0, sizeof( nvGenScenesHdr_t ), &hdr );
   3081          }
   3082          
   3083          /*********************************************************************
   3084           * @fn          zclGeneral_ScenesWriteNV
   3085           *
   3086           * @brief       Save the Scene Table in NV
   3087           *
   3088           * @param       none
   3089           *
   3090           * @return      none
   3091           */
   3092          static void zclGeneral_ScenesWriteNV( void )
   3093          {
   3094            nvGenScenesHdr_t hdr;
   3095            zclGenSceneItem_t *pLoop;
   3096            zclGenSceneNVItem_t item;
   3097          
   3098            hdr.numRecs = 0;
   3099          
   3100            // Look for end of list
   3101            pLoop = zclGenSceneTable;
   3102            while ( pLoop )
   3103            {
   3104              // Build the record
   3105              item.endpoint = pLoop->endpoint;
   3106              osal_memcpy( &(item.scene), &(pLoop->scene), sizeof ( zclGeneral_Scene_t ) );
   3107          
   3108              // Save the record to NV
   3109              osal_nv_write( ZCD_NV_SCENE_TABLE,
   3110                      (uint16)((sizeof( nvGenScenesHdr_t )) + (hdr.numRecs * sizeof ( zclGenSceneNVItem_t ))),
   3111                              sizeof ( zclGenSceneNVItem_t ), &item );
   3112          
   3113              hdr.numRecs++;
   3114          
   3115              pLoop = pLoop->next;
   3116            }
   3117          
   3118            // Save off the header
   3119            osal_nv_write( ZCD_NV_SCENE_TABLE, 0, sizeof( nvGenScenesHdr_t ), &hdr );
   3120          }
   3121          
   3122          /*********************************************************************
   3123           * @fn          zclGeneral_ScenesRestoreFromNV
   3124           *
   3125           * @brief       Restore the Scene table from NV
   3126           *
   3127           * @param       none
   3128           *
   3129           * @return      Number of entries restored
   3130           */
   3131          static uint16 zclGeneral_ScenesRestoreFromNV( void )
   3132          {
   3133            uint16 x;
   3134            nvGenScenesHdr_t hdr;
   3135          
   3136            zclGenSceneNVItem_t item;
   3137            uint16 numAdded = 0;
   3138          
   3139            if ( osal_nv_read( ZCD_NV_SCENE_TABLE, 0, sizeof(nvGenScenesHdr_t), &hdr ) == ZSuccess )
   3140            {
   3141              // Read in the device list
   3142              for ( x = 0; x < hdr.numRecs; x++ )
   3143              {
   3144                if ( osal_nv_read( ZCD_NV_SCENE_TABLE,
   3145                          (uint16)(sizeof(nvGenScenesHdr_t) + (x * sizeof ( zclGenSceneNVItem_t ))),
   3146                                            sizeof ( zclGenSceneNVItem_t ), &item ) == ZSUCCESS )
   3147                {
   3148                  // Add the scene
   3149                  if ( zclGeneral_AddScene( item.endpoint, &(item.scene) ) == ZSuccess )
   3150                  {
   3151                    numAdded++;
   3152                  }
   3153                }
   3154              }
   3155            }
   3156          
   3157            return ( numAdded );
   3158          }
   3159          #endif // ZCL_SCENES
   3160          
   3161          /***************************************************************************
   3162          ****************************************************************************/

Errors: 34
Warnings: none
