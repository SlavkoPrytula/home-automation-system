///////////////////////////////////////////////////////////////////////////////
//
// IAR C/C++ Compiler V10.30.1.6000 for 8051              20/Apr/2021  00:42:36
// Copyright 2004-2018 IAR Systems AB.
// Evaluation license - IAR Embedded Workbench for 8051, Evaluation edition 10.30
//
//    Core               =  plain
//    Code model         =  banked
//    Data model         =  large
//    Calling convention =  xdata reentrant
//    Constant location  =  data_rom
//    Dptr setup         =  1,16
//                          
//    Source file        =  
//        C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
//        3.0.2\Z-Stack 3.0.2\Components\stack\GP\gp_common.c
//    Command line       =  
//        -f C:\users\slavko\Temp\EW3f0b.tmp ("C:\Texas Instruments\Z-Stack
//        3.0.2-20210417T211827Z-001\Z-Stack 3.0.2\Z-Stack
//        3.0.2\Components\stack\GP\gp_common.c" -D BDB_REPORTING -D SECURE=1
//        -D TC_LINKKEY_JOIN -D NV_INIT -D NV_RESTORE -D xPOWER_SAVING -D
//        NWK_AUTO_POLL -D xZTOOL_P1 -D xMT_TASK -D xMT_APP_FUNC -D
//        xMT_SYS_FUNC -D xMT_ZDO_FUNC -D xMT_ZDO_MGMT -D xMT_APP_CNF_FUNC -D
//        LCD_SUPPORTED=DEBUG -D MULTICAST_ENABLED=FALSE -D ZCL_READ -D
//        ZCL_DISCOVER -D ZCL_WRITE -D ZCL_BASIC -D ZCL_IDENTIFY -D ZCL_ON_OFF
//        -D ZCL_SCENES -D ZCL_GROUPS -D ZCL_LEVEL_CTRL -lC "C:\Texas
//        Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack 3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\EndDeviceEB\List"
//        -lA "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
//        3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\EndDeviceEB\List"
//        --diag_suppress Pe001,Pa010 -o "C:\Texas Instruments\Z-Stack
//        3.0.2-20210417T211827Z-001\Z-Stack 3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\EndDeviceEB\Obj"
//        -e --debug --core=plain --dptr=16,1 --data_model=large
//        --code_model=banked --calling_convention=xdata_reentrant
//        --place_constants=data_rom --nr_virtual_regs 16 -f "C:\Texas
//        Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack 3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\Tools\CC2530DB\f8wEndev.cfg"
//        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_TX_DATA_MAX=3
//        -DMAC_CFG_TX_MAX=6 -DMAC_CFG_RX_MAX=3) -f "C:\Texas
//        Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack 3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg"
//        (-DZIGBEEPRO -DSECURE=1 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
//        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
//        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
//        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
//        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
//        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
//        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
//        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
//        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
//        -DMAX_BINDING_CLUSTER_IDS=4 -DDEFAULT_KEY={0}
//        -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
//        "-DCONST=const __code" -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE
//        -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100
//        -DREJOIN_POLL_RATE=440 -DREJOIN_BACKOFF=900000 -DREJOIN_SCAN=900000
//        -DENABLE_LED4_DISABLE_S1) -f "C:\Texas Instruments\Z-Stack
//        3.0.2-20210417T211827Z-001\Z-Stack 3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\Tools\CC2530DB\f8wZCL.cfg"
//        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
//        3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\" -I
//        "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
//        3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\Source\"
//        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
//        3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\Source\"
//        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
//        3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\ZMain\TI2530DB\"
//        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
//        3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\hal\include\"
//        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
//        3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\"
//        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
//        3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\mac\include\"
//        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
//        3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\mac\high_level\"
//        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
//        3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\"
//        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
//        3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\single_chip\"
//        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
//        3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\mt\"
//        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
//        3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\osal\include\"
//        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
//        3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\services\saddr\"
//        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
//        3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\services\sdata\"
//        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
//        3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\af\"
//        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
//        3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\bdb\"
//        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
//        3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\gp\"
//        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
//        3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\nwk\"
//        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
//        3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\sapi\"
//        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
//        3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\sec\"
//        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
//        3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\sys\"
//        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
//        3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\zcl\"
//        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
//        3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\zdo\"
//        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
//        3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\zmac\"
//        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
//        3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\zmac\f8w\"
//        -Ohz --require_prototypes)
//    Locale             =  English_USA.1252
//    List file          =  
//        C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
//        3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\EndDeviceEB\List\gp_common.s51
//
///////////////////////////////////////////////////////////////////////////////

        NAME gp_common

        RTMODEL "__SystemLibrary", "CLib"
        RTMODEL "__calling_convention", "xdata_reentrant"
        RTMODEL "__code_model", "banked"
        RTMODEL "__core", "plain"
        RTMODEL "__data_model", "large"
        RTMODEL "__dptr_size", "16"
        RTMODEL "__extended_stack", "disabled"
        RTMODEL "__location_for_constants", "data"
        RTMODEL "__number_of_dptrs", "1"
        RTMODEL "__register_banks", "*"
        RTMODEL "__rt_version", "1"

        RSEG DOVERLAY:DATA:NOROOT(0)
        RSEG IOVERLAY:IDATA:NOROOT(0)
        RSEG ISTACK:IDATA:NOROOT(0)
        RSEG PSTACK:XDATA:NOROOT(0)
        RSEG XSTACK:XDATA:NOROOT(0)


        END
// C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack 3.0.2\Z-Stack 3.0.2\Components\stack\GP\gp_common.c
//    1 /**************************************************************************************************
//    2   Filename:       gp_common.c
//    3   Revised:        $Date: 2016-02-25 11:51:49 -0700 (Thu, 25 Feb 2016) $
//    4   Revision:       $Revision: - $
//    5 
//    6   Description:    This file contains the implementation of the cGP stub.
//    7 
//    8 
//    9   Copyright 2006-2015 Texas Instruments Incorporated. All rights reserved.
//   10 
//   11   IMPORTANT: Your use of this Software is limited to those specific rights
//   12   granted under the terms of a software license agreement between the user
//   13   who downloaded the software, his/her employer (which must be your employer)
//   14   and Texas Instruments Incorporated (the "License").  You may not use this
//   15   Software unless you agree to abide by the terms of the License. The License
//   16   limits your use, and you acknowledge, that the Software may not be modified,
//   17   copied or distributed unless embedded on a Texas Instruments microcontroller
//   18   or used solely and exclusively in conjunction with a Texas Instruments radio
//   19   frequency transceiver, which is integrated into your product.  Other than for
//   20   the foregoing purpose, you may not use, reproduce, copy, prepare derivative
//   21   works of, modify, distribute, perform, display or sell this Software and/or
//   22   its documentation for any purpose.
//   23 
//   24   YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
//   25   PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
//   26   INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
//   27   NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
//   28   TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
//   29   NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
//   30   LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
//   31   INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
//   32   OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
//   33   OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
//   34   (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
//   35 
//   36   Should you have any questions regarding your right to use this Software,
//   37   contact Texas Instruments Incorporated at www.TI.com.
//   38 **************************************************************************************************/
//   39 
//   40 /*********************************************************************
//   41  * INCLUDES
//   42  */
//   43 
//   44 #include "ZGlobals.h"
//   45 #include "ZComDef.h"
//   46 #include "zcl_general.h"
//   47 #include "AF.h"
//   48 #include "gp_common.h"
//   49 #include "gp_interface.h"
//   50 #include "zcl_green_power.h"
//   51 #include "OSAL.h"
//   52 #include "dGP_stub.h"
//   53 #include "mac_api.h"
//   54 #include "ZDSecMgr.h"
//   55 #include "bdb.h"
//   56 
//   57 #if !defined (DISABLE_GREENPOWER_BASIC_PROXY) && (ZG_BUILD_RTR_TYPE)
//   58 
//   59  /*********************************************************************
//   60  * MACROS
//   61  */ 
//   62 
//   63    
//   64  /*********************************************************************
//   65  * CONSTANTS
//   66  */
//   67 
//   68 #define PGG_COMMISSIONING_WINDOW   180  //180 seconds by defaut
//   69 
//   70 
//   71 #ifdef GP_SHARED_KEY
//   72   CONFIG_ITEM uint8 zgpSharedKey[SEC_KEY_LEN] = GP_SHARED_KEY;
//   73 #else
//   74   CONFIG_ITEM uint8 zgpSharedKey[SEC_KEY_LEN] = {0xFF};
//   75 #endif
//   76 
//   77 /*********************************************************************
//   78  * TYPEDEFS
//   79  */
//   80    
//   81  /*********************************************************************
//   82  * GLOBAL VARIABLES
//   83  */
//   84 
//   85 
//   86 uint8  zclGp_gppMaxProxyTableEntries = GPP_MAX_PROXY_TABLE_ENTRIES;
//   87 uint8 *pZclGp_ProxyTableEntries = NULL;
//   88 uint8  zclGp_gppNotificationRetryNumber = GPP_NOTIFICATION_RETRY_NUMBER;
//   89 uint8  zclGp_gppNotificationRetryTimer = GPP_NOTIFICATION_RETRY_TIMER;
//   90 uint8  zclGp_gppMaxSearchCounter = GPP_MAX_SEARCH_COUNTER;
//   91 uint8 *pZclGp_gppBlockedGPDID = NULL;
//   92 
//   93 /**********************************************************************************
//   94 ZigBee PRO Green Power feature specification
//   95 Basic functionality set
//   96 Version 1.0
//   97 
//   98 Table 42 – Format of the gppFunctionality attribute
//   99 ----------------------------------------------------------------------------------
//  100 Indication   | Functionality                                        | Basic Proxy
//  101 -------------|------------------------------------------------------|-------------
//  102 b0           | GP feature                                           | 0b1
//  103 b1           | Direct communication (reception of GPDF via GP stub) | 0b1
//  104 b2           | Derived groupcast communication                      | 0b1
//  105 b3           | Pre-commissioned groupcast communication             | 0b1
//  106 b4           | Full unicast communication                           | 0b0
//  107 b5           | Lightweight unicast communication                    | 0b1
//  108 b6           | Reserved                                             | 0b0
//  109 b7           | Bidirectional operation                              | 0b0
//  110 b8           | Proxy Table maintenance (active and passive,         | 0b0
//  111              | for GPD mobility and GPP robustness)                 |
//  112 b9           | Reserved                                             | 0b0
//  113 b10          | GP commissioning                                     | 0b1
//  114 b11          | CT-based commissioning                               | 0b1
//  115 b12          | Maintenance of GPD (deliver channel/key              | 0b0
//  116              | during operation)                                    | 
//  117 b13          | gpdSecurityLevel  = 0b00                             | 0b1
//  118 b14          | Deprecated: gpdSe curityLevel = 0b01                 | 0b0
//  119 b15          | gpdSecurityLevel  = 0b10                             | 0b1
//  120 b16          | gpdSecurityLevel  = 0b11                             | 0b1
//  121 b17          | Reserved                                             | 0b0
//  122 b18          | Reserved                                             | 0b0
//  123 b19          | GPD IEEE address                                     | 0b1
//  124 b20 – b23    | Reserved                                             | 0b0
//  125 ----------------------------------------------------------------------------------
//  126 ***********************************************************************************/
//  127 
//  128 //                                          b0-b7       b8-b15      b16-23
//  129 //                                        0b00101111  0b10101100  0b00001001
//  130 uint8  zclGp_gppFunctionality[3] =       {   0x2F,      0xAC,        0x09};
//  131 uint8  zclGp_gppActiveFunctionality[3] = {   0x2F,      0xAC,        0x09};
//  132 
//  133 uint8  zclGp_gpSharedSecurityKeyType = GP_SHARED_SEC_KEY_TYPE;
//  134 uint8  zclGp_gpSharedSecurityKey[SEC_KEY_LEN] = GP_SHARED_KEY;
//  135 uint8  zclGp_gpLinkKey[SEC_KEY_LEN] = GP_LINK_LEY;
//  136 uint16 zclGp_clusterRevision = GP_CLUSTER_REVISION;
//  137 
//  138 static gpCommissioningMode_t  pfnCommissioningMode = NULL;
//  139 static gpChangeChannelReq_t   pfnChangeChannelReq = NULL;
//  140 static gpChangeChannelReq_t   pfnChangeChannelReqForBDB = NULL;
//  141 
//  142 
//  143 uint8 gp_commissioningOptions = 0;           //Commissioning Options from the ommissioningMode command
//  144 uint16 gp_commissioningUnicastAddress = 0;   //address of the device to which send the notifications
//  145 
//  146 uint8  zgGP_InCommissioningMode = FALSE;     // Global flag that states if in commissioning mode or in operational mode.
//  147 uint16 gp_commissionerAddress = 0xFFFF;      //Address to which send the notifications during commissioning mode
//  148 byte   gp_tempLogicalChannel = 0;            //Holder of the operational nwk channel
//  149 
//  150 
//  151 
//  152   
//  153 
//  154 /*********************************************************************
//  155  * ATTRIBUTE DEFINITIONS - Uses REAL cluster IDs
//  156  */
//  157 CONST zclAttrRec_t zclGp_Attrs[] =
//  158 {
//  159   // *** Green Power Proxy Cluster Attributes ***
//  160   {
//  161     ZCL_CLUSTER_ID_GREEN_POWER,
//  162     {  // Attribute record
//  163       ATTRID_GP_GPP_MAX_PROXY_TABLE_ENTRIES,
//  164       ZCL_DATATYPE_UINT8,
//  165       ACCESS_CONTROL_READ | ACCESS_CLIENT,
//  166       (void *)&zclGp_gppMaxProxyTableEntries
//  167     }
//  168   },
//  169   {
//  170     ZCL_CLUSTER_ID_GREEN_POWER,
//  171     {  // Attribute record
//  172       ATTRID_GP_PROXY_TABLE,
//  173       ZCL_DATATYPE_LONG_OCTET_STR,
//  174       ACCESS_CONTROL_READ | ACCESS_CLIENT,
//  175       NULL // Use application's callback to Read this attribute
//  176     }
//  177   },
//  178   {
//  179     ZCL_CLUSTER_ID_GREEN_POWER,
//  180     {  // Attribute record
//  181       ATTRID_GP_GPP_NOTIFICATION_RETRY_NUMBER,
//  182       ZCL_DATATYPE_UINT8,
//  183       ACCESS_CONTROL_READ | ACCESS_CONTROL_WRITE | ACCESS_CLIENT,
//  184       (void *)&zclGp_gppNotificationRetryNumber
//  185     }
//  186   },
//  187   {
//  188     ZCL_CLUSTER_ID_GREEN_POWER,
//  189     {  // Attribute record
//  190       ATTRID_GP_GPP_NOTIFICATION_RETRY_TIMER,
//  191       ZCL_DATATYPE_UINT8,
//  192       ACCESS_CONTROL_READ | ACCESS_CONTROL_WRITE | ACCESS_CLIENT,
//  193       (void *)&zclGp_gppNotificationRetryTimer
//  194     }
//  195   },
//  196   {
//  197     ZCL_CLUSTER_ID_GREEN_POWER,
//  198     {  // Attribute record
//  199       ATTRID_GP_GPP_MAX_SEARCH_COUNTER,
//  200       ZCL_DATATYPE_UINT8,
//  201       ACCESS_CONTROL_READ | ACCESS_CONTROL_WRITE | ACCESS_CLIENT,
//  202       (void *)&zclGp_gppMaxSearchCounter
//  203     }
//  204   },
//  205   {
//  206     ZCL_CLUSTER_ID_GREEN_POWER,
//  207     {  // Attribute record
//  208       ATTRID_GP_GPP_BLOCKED_GPD_ID,
//  209       ZCL_DATATYPE_LONG_OCTET_STR,
//  210       ACCESS_CONTROL_READ | ACCESS_CLIENT,
//  211       (void *)&pZclGp_gppBlockedGPDID
//  212     }
//  213   },
//  214   {
//  215     ZCL_CLUSTER_ID_GREEN_POWER,
//  216     {  // Attribute record
//  217       ATTRID_GP_GPP_FUNCTIONALITY,
//  218       ZCL_DATATYPE_BITMAP24,
//  219       ACCESS_CONTROL_READ | ACCESS_CLIENT,
//  220       (void *)&zclGp_gppFunctionality
//  221     }
//  222   },
//  223   {
//  224     ZCL_CLUSTER_ID_GREEN_POWER,
//  225     {  // Attribute record
//  226       ATTRID_GP_GPP_ACTIVE_FUNCTIONALITY,
//  227       ZCL_DATATYPE_BITMAP24,
//  228       ACCESS_CONTROL_READ | ACCESS_CLIENT,
//  229       (void *)&zclGp_gppActiveFunctionality
//  230     }
//  231   },
//  232   {
//  233     ZCL_CLUSTER_ID_GREEN_POWER,
//  234     {  // Attribute record
//  235       ATTRID_GP_SHARED_SEC_KEY_TYPE,
//  236       ZCL_DATATYPE_BITMAP8,
//  237       ACCESS_CONTROL_READ | ACCESS_CONTROL_WRITE | ACCESS_CLIENT,
//  238       (void *)&zclGp_gpSharedSecurityKeyType
//  239     }
//  240   },
//  241   {
//  242     ZCL_CLUSTER_ID_GREEN_POWER,
//  243     {  // Attribute record
//  244       ATTRID_GP_SHARED_SEC_KEY,
//  245       ZCL_DATATYPE_128_BIT_SEC_KEY,
//  246       ACCESS_CONTROL_READ | ACCESS_CONTROL_WRITE | ACCESS_CLIENT,
//  247       (void *)&zclGp_gpSharedSecurityKey
//  248     }
//  249   },
//  250   {
//  251     ZCL_CLUSTER_ID_GREEN_POWER,
//  252     {  // Attribute record
//  253       ATTRID_GP_LINK_KEY,
//  254       ZCL_DATATYPE_128_BIT_SEC_KEY,
//  255       ACCESS_CONTROL_READ | ACCESS_CONTROL_WRITE | ACCESS_CLIENT,
//  256       (void *)&zclGp_gpLinkKey
//  257     }
//  258   },
//  259   {
//  260     ZCL_CLUSTER_ID_GREEN_POWER,
//  261     {  // Attribute record
//  262       ATTRID_CLUSTER_REVISION,
//  263       ZCL_DATATYPE_UINT16,
//  264       ACCESS_CONTROL_READ | ACCESS_CLIENT,
//  265       (void *)&zclGp_clusterRevision
//  266     }
//  267   }
//  268 };
//  269 
//  270 
//  271 uint8 CONST zclGp_NumAttributes = ( sizeof(zclGp_Attrs) / sizeof(zclGp_Attrs[0]) );
//  272 
//  273  /*********************************************************************
//  274  * EXTERNAL VARIABLES
//  275  */
//  276 
//  277 //List to filter duplicated packets
//  278 gp_DataInd_t        *gp_DataIndList;
//  279 
//  280 
//  281 /*********************************************************************
//  282  * EXTERNAL FUNCTIONS
//  283  */
//  284 
//  285 
//  286 /*********************************************************************
//  287  * LOCAL VARIABLES
//  288  */
//  289 // This is the Cluster ID List and should be filled with Application
//  290 // specific cluster IDs.
//  291 #define GREEN_POWER_EP_MAX_INCLUSTERS       1
//  292 
//  293 #define GREEN_POWER_EP_MAX_OUTCLUSTERS       1
//  294 static const cId_t greenPower_EP_OutClusterList[GREEN_POWER_EP_MAX_OUTCLUSTERS] =
//  295 {
//  296   ZCL_CLUSTER_ID_GREEN_POWER
//  297 };
//  298 
//  299 static SimpleDescriptionFormat_t greenPower_EP_SimpleDesc =
//  300 {
//  301   GREEN_POWER_INTERNAL_ENDPOINT,         //  int Endpoint;
//  302   ZCL_GP_PROFILE_ID,                     //  uint16 AppProfId;
//  303   ZCL_GP_DEVICEID_PROXY_BASIC,           //  uint16 AppDeviceId;
//  304   0,                                     //  int   AppDevVer:4;
//  305   0,                                     //  int   AppFlags:4;
//  306   0,                                     //  byte  AppNumInClusters;
//  307   NULL,                                  //  byte *pAppInClusterList;
//  308   GREEN_POWER_EP_MAX_OUTCLUSTERS,        //  byte  AppNumInClusters;
//  309   (cId_t *)greenPower_EP_OutClusterList  //  byte *pAppInClusterList;
//  310 };
//  311 
//  312 
//  313 
//  314 
//  315  /*********************************************************************
//  316  * LOCAL FUNCTIONS
//  317  */
//  318 static void GP_ProccessCommissioningNotification(gp_DataInd_t *gp_DataInd);
//  319 static void GP_ProccessNotification(gp_DataInd_t *gp_DataInd);
//  320 
//  321 static void zclGp_GpPairingCommandCB( zclGpPairing_t *pCmd );
//  322 static void zclGp_GpProxyTableReqCB( zclGpProxyTableRequest_t *pCmd );
//  323 static void zclGp_GpProxyCommissioningModeCB(zclGpProxyCommissioningMode_t* pCmd);
//  324 static void zclGp_GpResponseCommandCB(zclGpResponse_t* pCmd);
//  325 static void gp_u32CastPointer( uint8 *data, uint8 *p );
//  326 static void gp_u16CastPointer( uint8 *data, uint8 *p );
//  327 static void gp_u8CastPointer( uint8 *data, uint8 *p );
//  328 static void gp_ZclPairingParse( zclGpPairing_t* pCmd, gpPairingCmd_t* payload );
//  329 static void gp_ZclProxyTableReqParse( zclGpProxyTableRequest_t* pCmd, gpProxyTableReqCmd_t* payload );
//  330 static uint8 gp_SecurityOperationProxy( gp_DataInd_t* pInd, uint8* pKeyType, uint8* pKey);
//  331 static gp_DataInd_t* gp_DataIndFindDuplicate(uint8 handle, uint8 secLvl);
//  332 static uint8 GP_RecoveryKey(uint8 GPDFKeyType,uint8 KeyType, uint8 status, uint8 *Key);
//  333  
//  334 
//  335 
//  336 
//  337 /*********************************************************************
//  338  * ZCL General Profile Callback table
//  339  */
//  340 static zclGp_AppCallbacks_t zclGpProxy_CmdCallbacks =
//  341 {
//  342   zclGp_GpPairingCommandCB,            //
//  343   zclGp_GpProxyTableReqCB,
//  344   zclGp_GpProxyCommissioningModeCB,    //
//  345   zclGp_GpResponseCommandCB  
//  346 };
//  347 
//  348 /*********************************************************************
//  349  * PUBLIC FUNCTIONS
//  350  *********************************************************************/
//  351 
//  352 
//  353  
//  354 void gp_endpointInit(void)
//  355 {
//  356 
//  357   bdb_RegisterSimpleDescriptor( &greenPower_EP_SimpleDesc );
//  358   
//  359   zclGp_RegisterCmdCallbacks( GREEN_POWER_INTERNAL_ENDPOINT, &zclGpProxy_CmdCallbacks );
//  360   
//  361   // Register the application's attribute list
//  362   zcl_registerAttrList( GREEN_POWER_INTERNAL_ENDPOINT, zclGp_NumAttributes, zclGp_Attrs );
//  363   
//  364   zcl_registerReadWriteCB( GREEN_POWER_INTERNAL_ENDPOINT, zclGpp_ReadWriteAttrCB, NULL );
//  365   
//  366   gp_ProxyTblInit( FALSE );
//  367 
//  368 }
//  369 
//  370 /*********************************************************************
//  371  * @fn      gp_stopCommissioningMode
//  372  *
//  373  * @brief   Stops the commissioning mode
//  374  *
//  375  * @param   none
//  376  *
//  377  * @return  none
//  378  */
//  379 void gp_stopCommissioningMode(void)
//  380 {
//  381   //Callback to notify about the end of the commissioning mode
//  382   gp_commissioningOptions = 0;
//  383   zgGP_InCommissioningMode = FALSE;
//  384   gp_commissionerAddress = 0xFFFF;
//  385   osal_stop_timerEx(gp_TaskID,GP_COMMISSIONING_WINDOW_TIMEOUT);
//  386   
//  387   //Release the gpTxQueue, proxy does not support bidirectional communication on operational mode
//  388   //A.3.2.8
//  389   gp_FreeGpTxQueue();
//  390   
//  391   //Notify the user that we have exited the commissioning mode
//  392   if(pfnCommissioningMode)
//  393   {
//  394     pfnCommissioningMode(FALSE);
//  395   }
//  396 }
//  397 
//  398 /*********************************************************************
//  399  * @fn      zclGp_ManteinanceIndParse
//  400  *
//  401  * @brief   Parse the Gp Manteinance indication to Gp Notification command
//  402  *
//  403  * @param   pInd - Pointer to the incoming data
//  404  *
//  405  * @return  ZStatus_t
//  406  */
//  407 ZStatus_t zclGp_ManteinanceIndParse( gp_DataInd_t *pInd, gpCommissioningNotificationCmd_t *pGpNotification )
//  408 {
//  409   uint8 currEntry[PROXY_TBL_ENTRY_LEN];
//  410   uint8  ntfOpt[2] = {0x00, 0x00};
//  411   int8 RSSI;
//  412   uint8 LQI;
//  413   
//  414   gp_ResetProxyBasicTblEntry(currEntry);
//  415   
//  416   
//  417   if ( pInd->GPDCmmdID != GP_CHANNEL_REQ_COMMAND_ID )
//  418   {
//  419     if ( PROXY_TBL_COMP_APPLICTION_ID( pInd->appID, GP_OPT_APP_ID_GPD ) )
//  420     {
//  421       pGpNotification->gpdId = pInd->SrcId;
//  422       ntfOpt[0] = GP_OPT_APP_ID_GPD;
//  423     }
//  424     else if ( PROXY_TBL_COMP_APPLICTION_ID( pInd->appID, GP_OPT_APP_ID_IEEE ) )
//  425     {
//  426       osal_memcpy( pGpNotification->gpdIEEE, &(pInd->srcAddr.addr.extAddr), Z_EXTADDR_LEN );
//  427       pGpNotification->ep = pInd->EndPoint;
//  428       ntfOpt[0] = GP_OPT_APP_ID_IEEE;
//  429     }
//  430   }
//  431   
//  432   // Set the options bit field
//  433   ( pInd->RxAfterTx == TRUE ) ?PROXY_TBL_SET_RX_AFTER_TX( ( uint8* )&ntfOpt[0] ) : PROXY_TBL_CLR_RX_AFTER_TX( ( uint8* )&ntfOpt[0] );
//  434   GP_CNTF_SET_SEC_LEVEL( ( uint8* )&ntfOpt[0], currEntry[PROXY_TBL_ENTRY_SEC_OPT] );
//  435   GP_CNTF_SET_SEC_KEY_TYPE( ( uint16* )ntfOpt, currEntry[PROXY_TBL_ENTRY_SEC_OPT] );
//  436   if( pInd->status == GP_DATA_IND_STATUS_AUTH_FAILURE )
//  437   {
//  438     GP_CNTF_SET_SEC_FAIL( ( uint8* )&ntfOpt[1] );
//  439     pGpNotification->mic = pInd->MIC;
//  440   }
//  441   else
//  442   {
//  443     GP_CNTF_CLR_SEC_FAIL( ( uint8* )&ntfOpt[1] );
//  444     pGpNotification->mic = 0xFFFFFFFF;
//  445   }
//  446   GP_CNTF_SET_BIDIRECTIONAL_CAP( ( uint8* )&ntfOpt[1] );
//  447 
//  448   GP_CNTF_SET_PROXY_INFO( ( uint8* )&ntfOpt[1] );
//  449   
//  450   pGpNotification->options |= ( ( ntfOpt[0] ) & 0x00FF );
//  451   pGpNotification->options |= ( ( ( ntfOpt[1] ) <<  8 ) & 0xFF00 );
//  452   
//  453   pGpNotification->gpdSecCounter = pInd->GPDSecFrameCounter;
//  454   pGpNotification->cmdId = pInd->GPDCmmdID;
//  455 
//  456   if ( pInd->GPDasduLength > 0 )
//  457   {
//  458     pGpNotification->payloadLen = pInd->GPDasduLength;
//  459     pGpNotification->cmdPayload = pInd->GPDasdu;
//  460   }
//  461   
//  462   pGpNotification->gppShortAddr = _NIB.nwkDevAddress;
//  463   
//  464   RSSI = pInd->Rssi;
//  465   ( RSSI > 8 ) ?RSSI = 8 : ( RSSI < -109 ) ?RSSI = -109 : NULL;
//  466   RSSI += 110;
//  467   RSSI /= 2;
//  468   
//  469   ( pInd->LinkQuality == 0 ) ?LQI = 0 : ( pInd->LinkQuality > 0 ) ?LQI = 2 : NULL;
//  470   
//  471   pGpNotification->gppGpdLink = RSSI;
//  472   pGpNotification->gppGpdLink |= ( LQI << 6 );
//  473     
//  474   return SUCCESS;
//  475 }
//  476 
//  477 /*********************************************************************
//  478  * @fn      zclGp_DataIndParse
//  479  *
//  480 
//  481  * @brief   Parse the Gp Data indication to Gp Notification command
//  482  *
//  483  * @param   pInd - Pointer to the incoming data
//  484  *
//  485  * @return  ZStatus_t
//  486  */
//  487 ZStatus_t zclGp_DataIndParse( gp_DataInd_t *pInd, gpNotificationCmd_t *pGpNotification )
//  488 {
//  489   uint8 currEntry[PROXY_TBL_ENTRY_LEN];
//  490   uint8  ntfOpt[2] = {0x00, 0x00};
//  491   uint8 i;
//  492   int8 RSSI;
//  493   uint8 LQI;
//  494   uint8 status;
//  495   
//  496   gp_ResetProxyBasicTblEntry(currEntry);
//  497   
//  498   for ( i = 1; i <= GPP_MAX_PROXY_TABLE_ENTRIES ; i++ )
//  499   {
//  500     status = gp_getProxyTableByIndex( ( ZCD_NV_PROXY_TABLE_START + i ), currEntry );
//  501 
//  502     if ( status == NV_OPER_FAILED )
//  503     {
//  504       return status;
//  505     }
//  506     
//  507     // if the entry is empty
//  508     if ( status == NV_INVALID_DATA )
//  509     {
//  510       continue;
//  511     }
//  512   
//  513     if ( PROXY_TBL_COMP_APPLICTION_ID( pInd->appID, currEntry[PROXY_TBL_ENTRY_OPT] ) )
//  514     {
//  515       if ( pInd->appID == GP_OPT_APP_ID_GPD )
//  516       {
//  517         if ( osal_memcmp( &pInd->SrcId, &currEntry[PROXY_TBL_ENTRY_GPD_ID + 4], sizeof ( uint32 ) ) )
//  518         {
//  519           // Entry found
//  520           pGpNotification->gpdId = pInd->SrcId;
//  521           ntfOpt[0] = GP_OPT_APP_ID_GPD;
//  522           break;
//  523         }
//  524       }
//  525       else if ( pInd->appID == GP_OPT_APP_ID_IEEE )
//  526       {
//  527         if ( osal_memcmp( &pInd->srcAddr, &currEntry[PROXY_TBL_ENTRY_GPD_ID], Z_EXTADDR_LEN ) )
//  528         {
//  529           // Entry found
//  530           osal_memcpy( pGpNotification->gpdIEEE, &(pInd->srcAddr.addr.extAddr), Z_EXTADDR_LEN );
//  531           pGpNotification->ep = pInd->EndPoint;
//  532           ntfOpt[0] = GP_OPT_APP_ID_IEEE;
//  533           break;
//  534         }
//  535       }
//  536     }
//  537     else
//  538     {
//  539       continue;
//  540     }
//  541   }
//  542   
//  543   // Set the options bit field
//  544   GP_NTF_SET_ALSO_UNICAST( ( uint8* )&ntfOpt[0], currEntry[PROXY_TBL_ENTRY_OPT] );
//  545   GP_NTF_SET_ALSO_DGROUP( ( uint8* )&ntfOpt[0], currEntry[PROXY_TBL_ENTRY_OPT] );
//  546   GP_NTF_SET_ALSO_CGROUP( ( uint8* )&ntfOpt[0], currEntry[PROXY_TBL_ENTRY_OPT] );
//  547   GP_NTF_SET_SEC_LEVEL( ( uint8* )&ntfOpt[0], currEntry[PROXY_TBL_ENTRY_SEC_OPT] );
//  548   GP_NTF_SET_SEC_KEY_TYPE( ( uint8* )&ntfOpt[1], currEntry[PROXY_TBL_ENTRY_SEC_OPT] );
//  549   pInd->RxAfterTx ?PROXY_TBL_SET_RX_AFTER_TX( ( uint8* )&ntfOpt[1] ) : PROXY_TBL_CLR_RX_AFTER_TX( ( uint8* )&ntfOpt[1] );
//  550   
//  551   // Mandatory to set this sub fields to 0b1 by the Green Power Proxy Basic Spec in A.3.3.4.1
//  552   PROXY_TBL_CLR_TX_QUEUE_FULL( ( uint8* )&ntfOpt[1] );
//  553   PROXY_TBL_SET_BIDIRECTIONAL_CAP( ( uint8* )&ntfOpt[1] );
//  554   PROXY_TBL_SET_PROXY_INFO( ( uint8* )&ntfOpt[1] );
//  555   
//  556   pGpNotification->options |= ( ( ntfOpt[0] ) & 0x00FF );
//  557   pGpNotification->options |= ( ( ( ntfOpt[1] ) <<  8 ) & 0xFF00 );
//  558   
//  559   pGpNotification->gpdSecCounter = pInd->GPDSecFrameCounter;
//  560   pGpNotification->cmdId = pInd->GPDCmmdID;
//  561 
//  562   if ( pInd->GPDasduLength > 0 )
//  563   {
//  564     pGpNotification->payloadLen = pInd->GPDasduLength;
//  565     pGpNotification->cmdPayload = pInd->GPDasdu;
//  566   }
//  567   
//  568   pGpNotification->gppShortAddr = _NIB.nwkDevAddress;
//  569   
//  570   RSSI = pInd->Rssi;
//  571   ( RSSI > 8 ) ?RSSI = 8 : ( RSSI < -109 ) ?RSSI = -109 : NULL;
//  572   RSSI += 110;
//  573   RSSI /= 2;
//  574   
//  575   ( pInd->LinkQuality == 0 ) ?LQI = 0 : ( pInd->LinkQuality > 0 ) ?LQI = 2 : NULL;
//  576   
//  577   pGpNotification->gppGpdLink = RSSI;
//  578   pGpNotification->gppGpdLink |= ( LQI << 6 );
//  579     
//  580   return SUCCESS;
//  581 }
//  582 
//  583 /*********************************************************************
//  584  * @fn      zclGp_GpPairingCommandCB
//  585  *
//  586  * @brief   Callback from the ZCL GreenPower Cluster Library when
//  587  *          it received an Gp Notification Command for this application.
//  588  *
//  589  * @param   pCmd - command payload
//  590  *
//  591  * @return  none
//  592  */
//  593 static void zclGp_GpPairingCommandCB( zclGpPairing_t *pCmd )
//  594 {
//  595   gpPairingCmd_t pairingPayload = {0x00};
//  596 
//  597   gp_ZclPairingParse( pCmd, &pairingPayload );
//  598   gp_PairingUpdateProxyTlb( &pairingPayload );
//  599   
//  600   
//  601   if(gp_commissioningOptions & GP_COMM_OPT_EXIT_ON_PAIRING_SUCCESS_MASK)
//  602   {
//  603     gp_stopCommissioningMode();
//  604   }
//  605 }
//  606 
//  607 /*********************************************************************
//  608  * @fn      zclGp_GpProxyTableReqCB
//  609  *
//  610  * @brief   Callback from the ZCL GreenPower Cluster Library when
//  611  *          it received a Gp proxy table req.
//  612  *
//  613  * @param   pCmd - command payload
//  614  *
//  615  * @return  none
//  616  */
//  617 static void zclGp_GpProxyTableReqCB( zclGpProxyTableRequest_t *pCmd )
//  618 {
//  619   uint8 i;
//  620   uint8 entryLen = 0;
//  621   uint8 maxEntryLen = 0;
//  622   uint8* buf = NULL;
//  623   uint8 currEntry[PROXY_TBL_ENTRY_LEN];
//  624   
//  625   
//  626   gp_ResetProxyBasicTblEntry(currEntry);
//  627   zclGpProxyTableResponse_t proxyTblRsp = {0};
//  628   gpProxyTableReqCmd_t proxyTblReqPayload = {0};
//  629   
//  630   proxyTblRsp.proxyTableEntry = NULL;
//  631   
//  632 
//  633   gp_ZclProxyTableReqParse( pCmd, &proxyTblReqPayload );
//  634   
//  635   // To get total entries for "Total number of non-empty Proxy Table entries" field
//  636   for ( i = 0; i <= GPP_MAX_PROXY_TABLE_ENTRIES; i++ )
//  637   {
//  638     if ( gp_getProxyTableByIndex( ( ZCD_NV_PROXY_TABLE_START + i ), currEntry ) == SUCCESS )
//  639     {
//  640       proxyTblRsp.tableEntriesTotal += 1;
//  641     }
//  642   }
//  643   
//  644   // for Request Table Entries by Index
//  645   if ( GP_IS_REQ_TPY_INDEX ( proxyTblReqPayload.options ) )
//  646   {
//  647     if ( (proxyTblRsp.tableEntriesTotal == 0x00) || (proxyTblRsp.tableEntriesTotal < proxyTblReqPayload.index) )
//  648     {
//  649       proxyTblRsp.status = SUCCESS;
//  650       proxyTblRsp.startIndex = proxyTblReqPayload.index;
//  651       proxyTblRsp.entriesCount = 0x00;
//  652       // Send response and exit
//  653       zclGp_SendGpProxyTableResponse( pCmd->srcAddr, &proxyTblRsp, zcl_InSeqNum );
//  654       return;
//  655     }
//  656     for ( i = proxyTblReqPayload.index; i <= GPP_MAX_PROXY_TABLE_ENTRIES; i++ )
//  657     {    
//  658       maxEntryLen = entryLen;    // Save the last iteration Lenght
//  659       
//  660       // Get the length of the payload
//  661       if ( pt_ZclReadGetProxyEntry ( ( ZCD_NV_PROXY_TABLE_START + i ), NULL, &entryLen ) != SUCCESS )
//  662       {
//  663         break;
//  664       }
//  665       
//  666       if ( entryLen >= 75 )   // max payload for entries
//  667       {
//  668         entryLen = maxEntryLen;   // The last valid lenght is the MAX for this packet
//  669         break;
//  670       }
//  671     }
//  672 
//  673     if ( entryLen )
//  674     {
//  675       buf = zcl_mem_alloc( entryLen );
//  676       if ( buf != NULL )
//  677       {
//  678         // Load the buffer - serially
//  679         uint8 *pBuf = buf;
//  680       
//  681         entryLen = 0;
//  682         proxyTblRsp.entriesCount = 0;
//  683         for ( i = proxyTblReqPayload.index; i <= GPP_MAX_PROXY_TABLE_ENTRIES ; i++ )
//  684         {  
//  685           if( pt_ZclReadGetProxyEntry ( ( ZCD_NV_PROXY_TABLE_START + i ), pBuf, &entryLen ) != SUCCESS )
//  686           {
//  687             break;
//  688           }
//  689           
//  690           proxyTblRsp.entriesCount += 1;
//  691           if ( entryLen >= maxEntryLen )   // to see if we reched the MAX calculated payload
//  692           {
//  693             break;
//  694           }
//  695         }
//  696       }
//  697     }
//  698   }
//  699   
//  700   // for Request Table Entries by GPD ID
//  701   if ( GP_IS_REQ_TYP_GPD ( proxyTblReqPayload.options ) )
//  702   {
//  703     uint8 lookForEntry = 0;
//  704     gpd_ID_t gpd_ID;
//  705     uint16 NvProxyTableIndex;
//  706     uint8  ProxyTableEntryTemp[PROXY_TBL_ENTRY_LEN];
//  707     
//  708     if ( GP_IS_APPLICATION_ID_GPD( proxyTblReqPayload.options ) )
//  709     {
//  710       gpd_ID.AppID = GP_OPT_APP_ID_GPD;
//  711       gpd_ID.GPDId.SrcID = proxyTblReqPayload.gpdId;
//  712       lookForEntry = 1;
//  713       proxyTblRsp.startIndex = 0xFF;
//  714     }
//  715     else if ( GP_IS_APPLICATION_ID_IEEE( proxyTblReqPayload.options ) )
//  716     {
//  717       gpd_ID.AppID = GP_OPT_APP_ID_IEEE;
//  718       osal_memcpy( gpd_ID.GPDId.GPDExtAddr, proxyTblReqPayload.gpdIEEE, Z_EXTADDR_LEN );
//  719       lookForEntry = 1;
//  720       proxyTblRsp.startIndex = 0xFF;
//  721     }
//  722     
//  723     if ( lookForEntry )
//  724     {
//  725       if ( gp_getProxyTableByGpId(&gpd_ID, ProxyTableEntryTemp, &NvProxyTableIndex) == ZSuccess )
//  726       {    
//  727         maxEntryLen = entryLen;    // Save the last iteration Lenght
//  728         
//  729         // Get the length of the payload
//  730         if ( pt_ZclReadGetProxyEntry ( NvProxyTableIndex, NULL, &entryLen ) != ZSuccess )
//  731         {
//  732           entryLen = 0;
//  733         }
//  734       
//  735         if ( entryLen >= 75 )   // max payload for entries
//  736         {
//  737           entryLen = maxEntryLen;   // The last valid lenght is the MAX for this packet
//  738         }
//  739       }
//  740       else
//  741       {
//  742         proxyTblRsp.status = ZCL_STATUS_NOT_FOUND;
//  743       }
//  744       
//  745       if ( entryLen )
//  746       {
//  747         buf = zcl_mem_alloc( entryLen );
//  748         if ( buf != NULL )
//  749         {
//  750           // Load the buffer - serially
//  751           uint8 *pBuf = buf;
//  752         
//  753           entryLen = 0;
//  754           proxyTblRsp.entriesCount = 0;
//  755         
//  756           if ( pt_ZclReadGetProxyEntry ( NvProxyTableIndex, pBuf, &entryLen ) == SUCCESS )
//  757           {
//  758             proxyTblRsp.entriesCount = 1;
//  759           }
//  760         }
//  761       }
//  762     }
//  763   }
//  764   
//  765   // Send response and exit
//  766   proxyTblRsp.startIndex = proxyTblReqPayload.index;
//  767   proxyTblRsp.proxyTableEntry = buf;
//  768   zclGp_SendGpProxyTableResponse( pCmd->srcAddr, &proxyTblRsp, zcl_InSeqNum );
//  769   zcl_mem_free( buf );
//  770 }
//  771 
//  772 
//  773 /*********************************************************************
//  774  * @fn      zclGp_GpResponseCommandCB
//  775  *
//  776  * @brief   Callback from the ZCL GreenPower Cluster Library when
//  777  *          it received a Gp Response command. (Ref A.3.5.2.1)
//  778  *
//  779  * @param   pCmd - command payload
//  780  *
//  781  * @return  none
//  782  */
//  783 static void zclGp_GpResponseCommandCB(zclGpResponse_t *pCmd)
//  784 {
//  785   gp_DataReq_t  *gp_DataReq;
//  786   gpd_ID_t      gpd_ID;
//  787   uint8         endpoint = 0;
//  788   uint8         command;
//  789   uint8         payloadLen = 0;
//  790   
//  791   //No bidirectional communication in operational mode
//  792   //A.3.2.8
//  793   if(!zgGP_InCommissioningMode)
//  794   {
//  795     return;
//  796   }
//  797   
//  798   gpd_ID.AppID = pCmd->options & GP_RSP_CMD_OPT_APP_ID_MASK;
//  799   if(gpd_ID.AppID == GP_APP_ID_DEFAULT)
//  800   {
//  801     gpd_ID.GPDId.SrcID = osal_build_uint32(pCmd->pData,sizeof(uint32));
//  802     pCmd->pData += sizeof(uint32);
//  803   }
//  804   else if(gpd_ID.AppID == GP_APP_ID_DEFAULT)
//  805   {
//  806     gpd_ID.GPDId.SrcID = osal_build_uint32(pCmd->pData,sizeof(uint32));
//  807     pCmd->pData += sizeof(uint32);
//  808     
//  809     endpoint = *pCmd->pData;
//  810     pCmd->pData++;
//  811   }
//  812   else
//  813   {
//  814     //Invalid app ID
//  815     return;
//  816   }
//  817   
//  818   command  = *pCmd->pData;
//  819   pCmd->pData++;
//  820   payloadLen = *pCmd->pData;
//  821   pCmd->pData++;
//  822    
//  823   gp_DataReq = (gp_DataReq_t*)osal_msg_allocate(sizeof(gp_DataReq_t) + payloadLen);  
//  824   
//  825   if(gp_DataReq == NULL)
//  826   {
//  827     //FAIL no memory
//  828     return;
//  829   }
//  830   if(payloadLen == 0xFF)
//  831   {
//  832     payloadLen = 0;
//  833   }
//  834   gp_DataReq->TxOptions = GP_OPT_USE_TX_QUEUE_MASK;
//  835   gp_DataReq->EndPoint = endpoint;
//  836   osal_memcpy(gp_DataReq->GPDasdu,pCmd->pData,payloadLen);
//  837   gp_DataReq->GPDasduLength = payloadLen;
//  838   gp_DataReq->GPDCmmdId = command;
//  839   osal_memcpy(&gp_DataReq->gpd_ID,&gpd_ID,sizeof(gpd_ID_t));
//  840 
//  841   gp_DataReq->GPEPhandle = gp_GetHandle(GPEP_HANDLE_TYPE);
//  842       
//  843   gp_DataReq->hdr.event = GP_DATA_REQ;
//  844   gp_DataReq->hdr.status = 0;  
//  845   
//  846   if(pCmd->options & GP_RSP_CMD_OPT_TRANSMIT_ON_ENDPOINT_MATCH_MASK)
//  847   {
//  848     gp_DataReq->TxOptions |= GP_OPT_TX_ON_MATCHING_ENDPOINT_MASK;
//  849   }
//  850   
//  851   //Validate the command being send as unicast and we are the tempMaster
//  852   if((pCmd->tempMasterShortAddr == _NIB.nwkDevAddress) && (pCmd->dstAddr == _NIB.nwkDevAddress))
//  853   {
//  854     uint16 NvProxyTableIndex;
//  855     uint8  ProxyTableEntryTemp[PROXY_TBL_ENTRY_LEN];
//  856     
//  857     //Check if the entry exist, if so, set the first to forward flag to 1
//  858     if ( gp_getProxyTableByGpId(&gpd_ID,ProxyTableEntryTemp,&NvProxyTableIndex) == ZSuccess )
//  859     {
//  860       //Update FirstToForward to 1
//  861       if(PROXY_TBL_GET_FIRST_TO_FORWARD(ProxyTableEntryTemp[PROXY_TBL_ENTRY_OPT]) == 0)
//  862       {
//  863         PROXY_TBL_SET_FIRST_TO_FORWARD(&ProxyTableEntryTemp[PROXY_TBL_ENTRY_OPT]);
//  864         osal_nv_write(NvProxyTableIndex,PROXY_TBL_ENTRY_OPT,2,&ProxyTableEntryTemp[PROXY_TBL_ENTRY_OPT]);
//  865       }
//  866     }
//  867     //Depends on TempMasterAddress
//  868     gp_DataReq->Action = TRUE;
//  869     
//  870     //Step 6 of Section A.3.9.1 The Procedure
//  871     //Check if we are in a different channel
//  872     if((pCmd->tempMasterTxChannel + 0x0B) != _NIB.nwkLogicalChannel)
//  873     {
//  874       //did we got permission to attend channel request?
//  875       if(osal_get_timeoutEx(gp_TaskID,GP_CHANNEL_CONFIGURATION_TIMEOUT))
//  876       {
//  877         gp_tempLogicalChannel = _NIB.nwkLogicalChannel;
//  878         _NIB.nwkLogicalChannel = pCmd->tempMasterTxChannel;
//  879         ZMacSetReq( ZMacChannel, &(_NIB.nwkLogicalChannel) );
//  880       }
//  881     }
//  882   }
//  883   else
//  884   {
//  885     uint16 NvProxyTableIndex;
//  886     uint8  ProxyTableEntryTemp[PROXY_TBL_ENTRY_LEN];
//  887        
//  888     //We are not the tempMaster or this was not a unicast to us, set the first to forward flag to 0
//  889     if( gp_getProxyTableByGpId(&gpd_ID,ProxyTableEntryTemp,&NvProxyTableIndex) == ZSuccess )
//  890     {
//  891       if(PROXY_TBL_GET_FIRST_TO_FORWARD(ProxyTableEntryTemp[PROXY_TBL_ENTRY_OPT]) == 1)
//  892       {
//  893         PROXY_TBL_SET_FIRST_TO_FORWARD(&ProxyTableEntryTemp[PROXY_TBL_ENTRY_OPT]);
//  894         osal_nv_write(NvProxyTableIndex,PROXY_TBL_ENTRY_OPT,2,&ProxyTableEntryTemp[PROXY_TBL_ENTRY_OPT]);
//  895       } 
//  896     }
//  897     
//  898     //Also remove any packet to the GPD
//  899     gp_DataReq->Action = 0;
//  900   }
//  901   
//  902   osal_msg_send(gp_TaskID,(uint8*)gp_DataReq);
//  903 }
//  904 
//  905 
//  906 
//  907 /*********************************************************************
//  908  * @fn      zclGp_GpProxyCommissioningModeCB
//  909  *
//  910  * @brief   Callback from the ZCL GreenPower Cluster Library when
//  911  *          it received a Gp Commissioning Mode command.
//  912  *
//  913  * @param   pCmd - command payload
//  914  *
//  915  * @return  none
//  916  */
//  917 static void zclGp_GpProxyCommissioningModeCB(zclGpProxyCommissioningMode_t* pCmd)
//  918 {
//  919   gp_commissioningOptions = pCmd->options;
//  920   uint32 CommissioningWindow = PGG_COMMISSIONING_WINDOW;
//  921   
//  922   if ( ( zgGP_InCommissioningMode == TRUE ) && ( gp_commissionerAddress != pCmd->srcAddr ) )
//  923   {
//  924     // If is in commissioning mode and the soruce address is different from 
//  925     // the device that set the proxy in commissioning mode, then drop
//  926     // the request.
//  927     return;
//  928   }
//  929 
//  930   //Enter in commissioning mode
//  931   if(gp_commissioningOptions & GP_COMM_OPT_ACTION_MASK)
//  932   {
//  933   
//  934 #if 0
//  935     if(gp_commissioningOptions & GP_COMM_OPT_CHANNEL_PRES_MASK)
//  936     {
//  937       //Section A.3.3.5.3, channel field is not supported in the current version of the spec
//  938     }
//  939 #endif
//  940  
//  941     if(gp_commissioningOptions & GP_COMM_OPT_EXIT_ON_WINDOW_EXPIRATION_MASK)
//  942     {
//  943       CommissioningWindow = osal_build_uint16(pCmd->pData);
//  944       pCmd->pData += sizeof(uint16);
//  945       
//  946       
//  947     }
//  948     if(gp_commissioningOptions & GP_COMM_OPT_UNICAST_COMM_MASK)
//  949     {
//  950       gp_commissionerAddress = pCmd->srcAddr;
//  951     }
//  952     else
//  953     {
//  954       gp_commissionerAddress = 0xFFFF;
//  955     }
//  956     
//  957     //Convert to timer units
//  958     CommissioningWindow = CommissioningWindow * 1000;
//  959     
//  960     //Exit upon expire
//  961     zgGP_InCommissioningMode = TRUE;
//  962     
//  963     //Notify the user about entering in commissioning mode
//  964     if(pfnCommissioningMode)
//  965     {
//  966       pfnCommissioningMode(TRUE);
//  967     }
//  968   }
//  969   //Exit commissioning mode
//  970   else
//  971   { 
//  972     gp_stopCommissioningMode();
//  973   }
//  974 }
//  975 
//  976  /*********************************************************************
//  977  * @fn          gp_ZclPairingParse
//  978  *
//  979  * @brief       Parse the pairing data message payload
//  980  *
//  981  * @param       
//  982  *
//  983  * @return      
//  984  */
//  985 static void gp_ZclPairingParse( zclGpPairing_t* pCmd, gpPairingCmd_t* payload )
//  986 {
//  987 
//  988   payload->options |= ( ( ( uint32 ) pCmd->options[2] << 16 ) & 0x00FF0000 );
//  989   payload->options |= ( ( ( uint32 ) pCmd->options[1] <<  8 ) & 0x0000FF00 );
//  990   payload->options |= ( ( ( uint32 ) pCmd->options[0] )       & 0x000000FF );
//  991     
//  992   // Options bitfield
//  993   // If Application Id bitfield is 0b000
//  994   if( GP_IS_APPLICATION_ID_GPD( payload->options ) )
//  995   {        
//  996     // Populate GPD ID
//  997     gp_PopulateField( ( uint8* )&payload->gpdId, &pCmd->pData, sizeof( payload->gpdId ) );
//  998     
//  999     // Populate GPD IEEE Invalid
// 1000     osal_memset ( &payload->gpdIEEE, 0xFF, Z_EXTADDR_LEN );
// 1001     // Populate EP Invalid
// 1002     payload->ep = 0xFF;
// 1003   }
// 1004   // If Application Id bitfield is 0b010
// 1005   else if( GP_IS_APPLICATION_ID_IEEE( payload->options ) )
// 1006   {
// 1007     // Populate GPD ID Invalid
// 1008     payload->gpdId = 0xFFFFFFFF;
// 1009     
// 1010     // Populate GPD IEEE
// 1011     gp_PopulateField( ( uint8* )&payload->gpdIEEE, &pCmd->pData, Z_EXTADDR_LEN );
// 1012     // Populate EP
// 1013     gp_PopulateField( ( uint8* )&payload->ep, &pCmd->pData, sizeof( payload->ep ) );
// 1014   }
// 1015   
// 1016   // If Remove GPD bit is 0b0
// 1017   if( !GP_REMOVE_GPD( payload->options ) )
// 1018   {
// 1019     // Communication Mode 0b00 or 0b11
// 1020     if( ( GP_IS_COMMUNICATION_MODE_FULL_UNICAST( payload->options ) ) || ( GP_IS_COMMUNICATION_MODE_LIGHT_UNICAST( payload->options ) ) )
// 1021     {
// 1022       // Populate Sink Addesses
// 1023       gp_PopulateField( ( uint8* )&payload->sinkIEEE, &pCmd->pData, Z_EXTADDR_LEN );
// 1024       gp_PopulateField( ( uint8* )&payload->sinkNwkAddr, &pCmd->pData, sizeof( payload->sinkNwkAddr ) );
// 1025       
// 1026       // Populate Grp Address Ivalid
// 1027       payload->sinkGroupID = 0xFFFF;
// 1028     }
// 1029     // Communication Mode 0b01 or 0b10
// 1030     else if ( ( GP_IS_COMMUNICATION_MODE_GRPCAST_DGROUP_ID( payload->options ) ) || ( GP_IS_COMMUNICATION_MODE_GRPCAST_GROUP_ID( payload->options ) ) )
// 1031     {
// 1032       // Populate Sink Addesses Invalid
// 1033       osal_memset ( &payload->sinkIEEE, 0xFF, Z_EXTADDR_LEN );
// 1034       payload->sinkNwkAddr = 0xFFFF;
// 1035       
// 1036       // Populate Grp Address
// 1037       if( GP_IS_APPLICATION_ID_IEEE( payload->options ) )
// 1038       {
// 1039         payload->sinkGroupID |= ((payload->gpdIEEE[6]) << 8) & 0xFF00;
// 1040         payload->sinkGroupID |= (payload->gpdIEEE[7]) & 0x00FF;
// 1041         pCmd->pData +=2;
// 1042       }
// 1043       else
// 1044       {
// 1045         gp_PopulateField( ( uint8* )&payload->sinkGroupID, &pCmd->pData, sizeof( payload->sinkGroupID ) );
// 1046       }
// 1047     }
// 1048   }
// 1049   else
// 1050   {
// 1051     uint8 i;
// 1052     uint8 status;
// 1053     uint8 currEntry[PROXY_TBL_ENTRY_LEN];
// 1054       
// 1055     gp_ResetProxyBasicTblEntry(currEntry);
// 1056     // Remove
// 1057     for ( i = 0; i <= GPP_MAX_PROXY_TABLE_ENTRIES ; i++ )
// 1058     {
// 1059       status = gp_getProxyTableByIndex( ( ZCD_NV_PROXY_TABLE_START + i ), currEntry );
// 1060 
// 1061       if ( status == NV_OPER_FAILED )
// 1062       {
// 1063         // FAIL
// 1064         return;
// 1065       }
// 1066     
// 1067       // if the entry is empty
// 1068       if ( status == NV_INVALID_DATA )
// 1069       {
// 1070         // Look for the next entry
// 1071         continue;
// 1072       }
// 1073       
// 1074       if( GP_IS_APPLICATION_ID_GPD( payload->options ) )
// 1075       {
// 1076         if ( osal_memcmp( &currEntry[PROXY_TBL_ENTRY_GPD_ID + 4], &payload->gpdId, sizeof ( uint32 ) ) )
// 1077         {
// 1078           // Remove this GPD entry
// 1079           gp_ResetProxyBasicTblEntry( currEntry );
// 1080         }
// 1081       }
// 1082       else if( GP_IS_APPLICATION_ID_IEEE( payload->options ) )
// 1083       {   
// 1084         if ( osal_memcmp( &currEntry[PROXY_TBL_ENTRY_GPD_ID ], payload->sinkIEEE, Z_EXTADDR_LEN ) )
// 1085         {
// 1086           // Remove this GPD entry
// 1087           gp_ResetProxyBasicTblEntry( currEntry );
// 1088         }
// 1089       }
// 1090     }
// 1091     return;
// 1092   }
// 1093   
// 1094   // If Add Sink bit is 0b1
// 1095   if ( GP_ADD_SINK( payload->options ) )
// 1096   {
// 1097     // Populate Device ID
// 1098     gp_PopulateField( ( uint8* )&payload->deviceId, &pCmd->pData, sizeof( payload->deviceId ) );
// 1099     
// 1100     if ( GP_SEC_COUNTER( payload->options ) )
// 1101     {
// 1102       // Populate GPD security frame counter
// 1103       gp_PopulateField( ( uint8* )&payload->gpdSecCounter, &pCmd->pData, sizeof( payload->gpdSecCounter ) );
// 1104     }
// 1105     else
// 1106     {
// 1107       payload->gpdSecCounter = 0xFFFFFFFF;
// 1108     }
// 1109     
// 1110     if ( GP_SEC_KEY ( payload->options ) )
// 1111     {
// 1112       gp_PopulateField( ( uint8* )&payload->gpdKey, &pCmd->pData, SEC_KEY_LEN );
// 1113     }
// 1114     else
// 1115     {
// 1116       osal_memset ( &payload->gpdKey, 0xFF, SEC_KEY_LEN );
// 1117     }
// 1118     
// 1119     if ( GP_ALIAS ( payload->options ) )
// 1120     {
// 1121       gp_PopulateField( ( uint8* )&payload->assignedAlias, &pCmd->pData, sizeof( payload->assignedAlias ) );
// 1122     }
// 1123     else
// 1124     {
// 1125       payload->assignedAlias = 0xFFFF;
// 1126     }
// 1127     if ( GP_FORWARDING_RADIUS ( payload->options ) )
// 1128     {
// 1129       gp_PopulateField( ( uint8* )&payload->forwardingRadius, &pCmd->pData, sizeof( payload->forwardingRadius ) );
// 1130     }
// 1131     else
// 1132     {
// 1133       payload->forwardingRadius = 0xFF;
// 1134     }
// 1135   }
// 1136   else
// 1137   {
// 1138     // Ivalidate every field
// 1139     payload->deviceId = 0xFF;
// 1140     payload->gpdSecCounter = 0xFFFFFFFF;
// 1141     payload->assignedAlias = 0xFFFF;
// 1142     payload->forwardingRadius = 0xFF;
// 1143   }
// 1144 }
// 1145 
// 1146  /*********************************************************************
// 1147  * @fn          gp_ZclProxyTableReqParse
// 1148  *
// 1149  * @brief       Parse the proxy table request data message payload
// 1150  *
// 1151  * @param       
// 1152  *
// 1153  * @return      
// 1154  */
// 1155 static void gp_ZclProxyTableReqParse( zclGpProxyTableRequest_t* pCmd, gpProxyTableReqCmd_t* payload )
// 1156 {
// 1157 
// 1158   payload->options =  pCmd->options;
// 1159     
// 1160   // If Request type bitfield is 0b00
// 1161   if( GP_IS_REQ_TYP_GPD( payload->options ) )
// 1162   {  
// 1163     // If Application Id bitfield is 0b000
// 1164     if( GP_IS_APPLICATION_ID_GPD( payload->options ) )
// 1165     {        
// 1166       // Populate GPD ID
// 1167       gp_PopulateField( ( uint8* )&payload->gpdId, &pCmd->pData, sizeof( payload->gpdId ) );
// 1168     
// 1169       // Populate GPD IEEE Invalid
// 1170       osal_memset ( &payload->gpdIEEE, 0xFF, Z_EXTADDR_LEN );
// 1171       // Populate EP Invalid
// 1172       payload->ep = 0xFF;
// 1173     }
// 1174     // If Application Id bitfield is 0b010
// 1175     else if( GP_IS_APPLICATION_ID_IEEE( payload->options ) )
// 1176     {
// 1177       // Populate GPD ID Invalid
// 1178       payload->gpdId = 0xFFFFFFFF;
// 1179     
// 1180       // Populate GPD IEEE
// 1181       gp_PopulateField( ( uint8* )&payload->gpdIEEE, &pCmd->pData, Z_EXTADDR_LEN );
// 1182       // Populate EP
// 1183       gp_PopulateField( ( uint8* )&payload->ep, &pCmd->pData, sizeof( payload->ep ) );
// 1184     }
// 1185     // Populate Index Invalid
// 1186     payload->index = 0xFF;
// 1187   }
// 1188   // If Request type bitfield is 0b01
// 1189   else if( GP_IS_REQ_TPY_INDEX( payload->options ) )
// 1190   {
// 1191     // Populate GPD ID Invalid
// 1192     payload->gpdId = 0xFFFFFFFF;
// 1193     
// 1194     // Populate GPD IEEE Invalid
// 1195     osal_memset ( &payload->gpdIEEE, 0xFF, Z_EXTADDR_LEN );
// 1196     
// 1197     // Populate EP Invalid
// 1198     payload->ep = 0xFF;
// 1199     
// 1200     // Populate index
// 1201     gp_PopulateField( ( uint8* )&payload->index, &pCmd->pData, sizeof( payload->index ) );
// 1202   }
// 1203 
// 1204 }
// 1205 
// 1206  /*********************************************************************
// 1207  * @fn          gp_PopulateField
// 1208  *
// 1209  * @brief       General function fill the proxy table vector item
// 1210  *
// 1211  * @param       
// 1212  *
// 1213  * @return      
// 1214  */
// 1215 void gp_PopulateField( uint8* pField, uint8** pData, uint8 size )
// 1216 {
// 1217   switch ( size )
// 1218   {
// 1219     case ( sizeof( uint8 ) ):
// 1220       gp_u8CastPointer( pField, *pData );
// 1221       break;
// 1222     case ( sizeof( uint16 ) ):
// 1223       gp_u16CastPointer( pField, *pData );
// 1224       break;
// 1225     case ( sizeof( uint32 ) ):
// 1226       gp_u32CastPointer( pField, *pData );
// 1227       break;
// 1228     case ( Z_EXTADDR_LEN ):
// 1229       osal_memcpy( pField, *pData, Z_EXTADDR_LEN );
// 1230       break;
// 1231     case ( SEC_KEY_LEN ):
// 1232       osal_memcpy( pField, *pData, SEC_KEY_LEN );
// 1233       break;
// 1234   }
// 1235   *pData += size;
// 1236 }
// 1237 
// 1238  /*********************************************************************
// 1239  * @fn          gp_ProxyTblInit
// 1240  *
// 1241  * @brief       General function to init the NV items for proxy table
// 1242  *
// 1243  * @param       
// 1244  *
// 1245  * @return      
// 1246  */
// 1247 
// 1248 uint8 gp_ProxyTblInit( uint8 resetTable )
// 1249 {
// 1250   uint8 i;
// 1251   uint8 status;
// 1252   uint8 emptyEntry[PROXY_TBL_ENTRY_LEN];
// 1253   
// 1254   gp_ResetProxyBasicTblEntry( emptyEntry );
// 1255   
// 1256   for ( i = 0; i <= GPP_MAX_PROXY_TABLE_ENTRIES ; i++ )
// 1257   {
// 1258     status = osal_nv_item_init( ( ZCD_NV_PROXY_TABLE_START + i ),
// 1259                                        PROXY_TBL_ENTRY_LEN, &emptyEntry );
// 1260     
// 1261     if ( ( status != SUCCESS ) && ( status != NV_ITEM_UNINIT ) )
// 1262     {
// 1263       return status;
// 1264     }
// 1265     if ( ( status == SUCCESS ) && ( resetTable == TRUE ) )
// 1266     {
// 1267       status = osal_nv_write( ( ZCD_NV_PROXY_TABLE_START + i ), 0,
// 1268                                     PROXY_TBL_ENTRY_LEN, &emptyEntry );
// 1269     }
// 1270   }
// 1271   return status;
// 1272 }
// 1273 
// 1274 
// 1275  /*********************************************************************
// 1276  * @fn          gp_getProxyTableByGpId
// 1277  *
// 1278  * @brief       General function to get proxy table entry by gpd_ID (GP Src ID or Extended Adddress)
// 1279  *
// 1280  * @param       gpd_ID  - address to look for in the table
// 1281  *              pEntry  - buffer in which the entry of the table will be copied
// 1282  *
// 1283  * @return      
// 1284  */
// 1285 
// 1286 uint8 gp_getProxyTableByGpId(gpd_ID_t *gpd_ID, uint8 *pEntry,uint16 *NvProxyTableIndex)
// 1287 {
// 1288   uint8 i;
// 1289   uint8 status;
// 1290 
// 1291   if((pEntry == NULL) ||  (gpd_ID == NULL))
// 1292   {
// 1293     return ZInvalidParameter;
// 1294   }     
// 1295   
// 1296 
// 1297   for ( i = 0; i <= GPP_MAX_PROXY_TABLE_ENTRIES ; i++ )
// 1298   {
// 1299     status = gp_getProxyTableByIndex( ( ZCD_NV_PROXY_TABLE_START + i ), pEntry );
// 1300 
// 1301     if ( status == NV_OPER_FAILED )
// 1302     {
// 1303       // FAIL
// 1304       return ZFailure;
// 1305     }
// 1306     
// 1307     // if the entry is empty
// 1308     if ( status == NV_INVALID_DATA )
// 1309     {
// 1310       continue;
// 1311     }
// 1312 
// 1313     //Check that App ID is the same
// 1314 
// 1315     if ( PROXY_TBL_COMP_APPLICTION_ID( gpd_ID->AppID, pEntry[PROXY_TBL_ENTRY_OPT] ) )
// 1316     {
// 1317       if ( gpd_ID->AppID == GP_OPT_APP_ID_GPD )
// 1318       {
// 1319         if ( osal_memcmp( &gpd_ID->GPDId.SrcID, &pEntry[PROXY_TBL_ENTRY_GPD_ID + 4], sizeof ( uint32 ) ) )
// 1320         {
// 1321           // Entry found
// 1322           break;
// 1323         }
// 1324       }
// 1325 
// 1326       else if ( gpd_ID->AppID == GP_OPT_APP_ID_IEEE )
// 1327       {
// 1328         if ( osal_memcmp( &gpd_ID->GPDId.GPDExtAddr, &pEntry[PROXY_TBL_ENTRY_GPD_ID], Z_EXTADDR_LEN ) )
// 1329         {
// 1330           // Entry found
// 1331           break;
// 1332         }
// 1333       }
// 1334     }
// 1335     else
// 1336     {
// 1337       continue;
// 1338     }
// 1339   }
// 1340 
// 1341   if(i <= GPP_MAX_PROXY_TABLE_ENTRIES)
// 1342   {
// 1343     if(NvProxyTableIndex != NULL)
// 1344     {
// 1345       *NvProxyTableIndex = ZCD_NV_PROXY_TABLE_START + i;
// 1346     }
// 1347     return ZSuccess;
// 1348   }
// 1349     
// 1350   return ZInvalidParameter;
// 1351 }
// 1352 
// 1353  /*********************************************************************
// 1354  * @fn          gp_SecurityOperationProxy
// 1355  *
// 1356  * @brief       Performs Security Operations according to Proxy
// 1357  *
// 1358  * @param       ind - pointer to gp data indication
// 1359  * @param       pFrameCounter 
// 1360  * @param       pKeyType 
// 1361  * @param       pkey Key to be used to decript the packet (if applies)
// 1362  *
// 1363  * @return      GP_SEC_RSP status
// 1364  */
// 1365 uint8 gp_SecurityOperationProxy( gp_DataInd_t* pInd, uint8* pKeyType, uint8* pKey)
// 1366 {
// 1367   uint8    currEntry[PROXY_TBL_ENTRY_LEN];
// 1368   uint8    status;
// 1369   uint32   SecFrameCounter = 0;
// 1370   uint8    securityCheckFail = FALSE;
// 1371   uint8    endpointCheckFail = FALSE;
// 1372   uint16   NvProxyTableIndex = 0;
// 1373   gpd_ID_t gpd_ID;
// 1374   
// 1375   gp_ResetProxyBasicTblEntry(currEntry);
// 1376   
// 1377   if((pKeyType == NULL) || (pKey == NULL) || (pInd == NULL))
// 1378   {
// 1379     return GP_SEC_RSP_ERROR;
// 1380   }
// 1381   *pKeyType = 0;
// 1382   osal_memset(pKey,0,SEC_KEY_LEN);
// 1383   
// 1384   gpd_ID.AppID = pInd->appID;
// 1385   
// 1386   if(gpd_ID.AppID == GP_APP_ID_DEFAULT)
// 1387   {
// 1388     gpd_ID.GPDId.SrcID = pInd->SrcId;
// 1389   }
// 1390   else
// 1391   {
// 1392     osal_memcpy(gpd_ID.GPDId.GPDExtAddr,pInd->srcAddr.addr.extAddr,Z_EXTADDR_LEN);
// 1393   }
// 1394   
// 1395   status = gp_getProxyTableByGpId(&gpd_ID,currEntry,&NvProxyTableIndex);
// 1396   
// 1397   //Not found
// 1398   if(status == ZInvalidParameter)
// 1399   {
// 1400     //Section A.3.5.2.1 if in commissioning mode and GPDF from proxy that do not 
// 1401     //have entry, then drop frame
// 1402     if(zgGP_InCommissioningMode == FALSE)
// 1403     {
// 1404       return GP_SEC_RSP_DROP_FRAME;
// 1405     }
// 1406     if(pInd->GPDFKeyType == 0)
// 1407     {
// 1408       //If there is no shared key, then pass unprocess
// 1409       if(osal_memcmp(pKey,zgpSharedKey,SEC_KEY_LEN))
// 1410       {
// 1411         return GP_SEC_RSP_PASS_UNPROCESSED;
// 1412       }
// 1413       osal_memcpy(pKey,zgpSharedKey,SEC_KEY_LEN);
// 1414     }
// 1415     else
// 1416     {
// 1417       return GP_SEC_RSP_PASS_UNPROCESSED;
// 1418     }
// 1419   }
// 1420   
// 1421   //error
// 1422   else if(status == ZFailure)
// 1423   {
// 1424     //Not found, or error, drop the frame
// 1425     return GP_SEC_RSP_DROP_FRAME;
// 1426   }
// 1427   
// 1428   //Found
// 1429   else
// 1430   {
// 1431     
// 1432 //Active/Inactive entries in the proxy table are not supported    
// 1433 #if 1
// 1434       //If security level is zero then don't check and pass unproessed
// 1435       if( (pInd->GPDFSecLvl == PROXY_TBL_GET_SEC_OPT_SECURITY_LVL(currEntry[PROXY_TBL_ENTRY_SEC_OPT]) ) &&
// 1436           ( GP_SECURITY_LVL_NO_SEC == PROXY_TBL_GET_SEC_OPT_SECURITY_LVL(currEntry[PROXY_TBL_ENTRY_SEC_OPT]) ))
// 1437       {
// 1438         pInd->GPDSecFrameCounter = (uint32)pInd->SeqNumber;
// 1439         return GP_SEC_RSP_PASS_UNPROCESSED;
// 1440       }
// 1441       //Check security Section A.3.7.3.3
// 1442       //Check framecounter freshness
// 1443       SecFrameCounter = osal_build_uint32(&currEntry[PROXY_TBL_ENTRY_SEC_FRAME],sizeof(uint32));
// 1444       if(SecFrameCounter >= pInd->GPDSecFrameCounter)
// 1445       {
// 1446         securityCheckFail = TRUE;
// 1447       }
// 1448       //Compare the security level
// 1449       else if(pInd->GPDFSecLvl != PROXY_TBL_GET_SEC_OPT_SECURITY_LVL(currEntry[PROXY_TBL_ENTRY_SEC_OPT]))
// 1450       {
// 1451         securityCheckFail = TRUE;
// 1452       }
// 1453       //Mapping of security key type (section A.1.4.1.3 Table 12)
// 1454       else if((PROXY_TBL_GET_SEC_OPT_SECURITY_KEY_TYP(currEntry[PROXY_TBL_ENTRY_SEC_OPT]) <= 0x03)
// 1455               && (pInd->GPDFKeyType == 1))
// 1456       {
// 1457         securityCheckFail = TRUE;
// 1458       }
// 1459       else if(  ((PROXY_TBL_GET_SEC_OPT_SECURITY_KEY_TYP(currEntry[PROXY_TBL_ENTRY_SEC_OPT]) == 0x07) ||
// 1460                  (PROXY_TBL_GET_SEC_OPT_SECURITY_KEY_TYP(currEntry[PROXY_TBL_ENTRY_SEC_OPT]) == 0x04)) 
// 1461                && (pInd->GPDFKeyType == 0) )
// 1462       {
// 1463         securityCheckFail = TRUE;
// 1464         
// 1465       }
// 1466       else if( (PROXY_TBL_GET_SEC_OPT_SECURITY_KEY_TYP(currEntry[PROXY_TBL_ENTRY_SEC_OPT]) == 0x05) ||
// 1467                (PROXY_TBL_GET_SEC_OPT_SECURITY_KEY_TYP(currEntry[PROXY_TBL_ENTRY_SEC_OPT]) == 0x06) )
// 1468       {
// 1469         //keytype reserved
// 1470         securityCheckFail = TRUE;
// 1471       }
// 1472       
// 1473       if(securityCheckFail == TRUE)
// 1474       {
// 1475         if(zgGP_InCommissioningMode == FALSE)
// 1476         {
// 1477           return GP_SEC_RSP_DROP_FRAME;
// 1478         }
// 1479         else
// 1480         {
// 1481           return GP_SEC_RSP_PASS_UNPROCESSED;
// 1482         }
// 1483       }
// 1484       else
// 1485       {
// 1486         //Securty check success
// 1487         osal_memcpy(pKey,&currEntry[PROXY_TBL_ENTRY_GPD_KEY],SEC_KEY_LEN);
// 1488         *pKeyType = PROXY_TBL_GET_SEC_OPT_SECURITY_KEY_TYP(currEntry[PROXY_TBL_ENTRY_SEC_OPT]);
// 1489       
// 1490         //compare the endpoint
// 1491         if(endpointCheckFail)
// 1492         {
// 1493           return GP_SEC_RSP_TX_THEN_DROP;
// 1494         }
// 1495         else
// 1496         {
// 1497           return GP_SEC_RSP_MATCH;
// 1498         }
// 1499       }
// 1500       
// 1501 //Active/Inactive entries in the proxy table are not supported
// 1502 #else
// 1503     //Is active
// 1504     if(PROXY_TBL_GET_ENTRY_ACTIVE(currEntry[PROXY_TBL_ENTRY_OPT]))
// 1505     {
// 1506       //Check security Section A.3.7.3.3
// 1507       //Check framecounter freshness
// 1508       SecFrameCounter = osal_build_uint32(&currEntry[PROXY_TBL_ENTRY_SEC_FRAME],sizeof(uint32));
// 1509       if(SecFrameCounter >= pInd->GPDSecFrameCounter)
// 1510       {
// 1511         securityCheckFail = TRUE;
// 1512       }
// 1513       //Compare the security level
// 1514       else if(pInd->GPDFSecLvl != PROXY_TBL_GET_SEC_OPT_SECURITY_LVL(currEntry[PROXY_TBL_ENTRY_SEC_OPT]))
// 1515       {
// 1516         securityCheckFail = TRUE;
// 1517       }
// 1518       //Mapping of security key type (section A.1.4.1.3 Table 12)
// 1519       else if((PROXY_TBL_GET_SEC_OPT_SECURITY_KEY_TYP(currEntry[PROXY_TBL_ENTRY_SEC_OPT]) <= 0x03)
// 1520               && (pInd->GPDFKeyType == 1))
// 1521       {
// 1522         securityCheckFail = TRUE;
// 1523       }
// 1524       else if(  ((PROXY_TBL_GET_SEC_OPT_SECURITY_KEY_TYP(currEntry[PROXY_TBL_ENTRY_SEC_OPT]) == 0x07) ||
// 1525                  (PROXY_TBL_GET_SEC_OPT_SECURITY_KEY_TYP(currEntry[PROXY_TBL_ENTRY_SEC_OPT]) == 0x04)) 
// 1526                && (pInd->GPDFKeyType == 0) )
// 1527       {
// 1528         securityCheckFail = TRUE;
// 1529         
// 1530       }
// 1531       else if( (PROXY_TBL_GET_SEC_OPT_SECURITY_KEY_TYP(currEntry[PROXY_TBL_ENTRY_SEC_OPT]) == 0x05) ||
// 1532                (PROXY_TBL_GET_SEC_OPT_SECURITY_KEY_TYP(currEntry[PROXY_TBL_ENTRY_SEC_OPT]) == 0x06) )
// 1533       {
// 1534         //keytype reserved
// 1535         securityCheckFail = TRUE;
// 1536       }
// 1537       
// 1538       if(securityCheckFail == TRUE)
// 1539       {
// 1540         if(zgGP_InCommissioningMode == FALSE)
// 1541         {
// 1542           return GP_SEC_RSP_DROP_FRAME;
// 1543         }
// 1544         else
// 1545         {
// 1546           return GP_SEC_RSP_PASS_UNPROCESSED;
// 1547         }
// 1548       }
// 1549       else
// 1550       {
// 1551         //Securty check success
// 1552         osal_memcpy(pKey,&currEntry[PROXY_TBL_ENTRY_GPD_KEY],SEC_KEY_LEN);
// 1553         *pKeyType = GP_GET_SEC_KEY_TYPE(currEntry[PROXY_TBL_ENTRY_SEC_OPT]);
// 1554       
// 1555         //compare the endpoint
// 1556         if(endpointCheckFail)
// 1557         {
// 1558           return GP_SEC_RSP_TX_THEN_DROP;
// 1559         }
// 1560         else
// 1561         {
// 1562           return GP_SEC_RSP_MATCH;
// 1563         }
// 1564       }
// 1565     }
// 1566 
// 1567     //Inactive
// 1568     else
// 1569     {
// 1570       //Found, inactive and in operational mode
// 1571       if(zgGP_InCommissioningMode == FALSE)
// 1572       {
// 1573         //Check framecounter freshness
// 1574         SecFrameCounter = osal_build_uint32(&currEntry[PROXY_TBL_ENTRY_SEC_FRAME],sizeof(uint32));
// 1575         if(SecFrameCounter < pInd->GPDSecFrameCounter)
// 1576         {
// 1577           //Update framecounter
// 1578            osal_memcpy(&currEntry[PROXY_TBL_ENTRY_SEC_FRAME],(uint8*)&pInd->GPDSecFrameCounter,sizeof(uint32));
// 1579 
// 1580            status = osal_nv_write( NvProxyTableIndex, 0,
// 1581                                PROXY_TBL_ENTRY_LEN, currEntry );
// 1582            
// 1583            if ( status != SUCCESS )
// 1584            {
// 1585              // FAIL
// 1586              return GP_SEC_RSP_ERROR;
// 1587            }
// 1588         }
// 1589         return GP_SEC_RSP_DROP_FRAME;
// 1590       }
// 1591       //Found,inactive, and in commissioning mode
// 1592       else
// 1593       {
// 1594         //If key type = 0, its the same as not found
// 1595         if(pInd->GPDFKeyType == 0)
// 1596         {
// 1597           Found = FALSE;
// 1598         }
// 1599         else
// 1600         {
// 1601           return GP_SEC_RSP_PASS_UNPROCESSED;
// 1602         }
// 1603       }
// 1604     }
// 1605 #endif
// 1606     
// 1607   }
// 1608 
// 1609 
// 1610   //Should not reach this point
// 1611   return GP_SEC_RSP_DROP_FRAME;
// 1612 }
// 1613 
// 1614  /*********************************************************************
// 1615  * @fn          gp_u32CastPointer
// 1616  *
// 1617  * @brief       General function fill uint32 from pionter.
// 1618  *
// 1619  * @param       pBitField - pointer to the bit field.
// 1620  *              bit       - position of the bit to set in the given bitfield.
// 1621  *
// 1622  * @return      
// 1623  */
// 1624 static void gp_u32CastPointer( uint8 *data, uint8 *p )
// 1625 {
// 1626     *( uint32* )data |= ( ( *( uint32* ) p++ )       & 0x000000FF );
// 1627     *( uint32* )data |= ( ( *( uint32* ) p++ <<  8 ) & 0x0000FF00 );
// 1628     *( uint32* )data |= ( ( *( uint32* ) p++ << 16 ) & 0x00FF0000 );
// 1629     *( uint32* )data |= ( ( *( uint32* ) p++ << 24 ) & 0xFF000000 );
// 1630 }
// 1631 
// 1632  /*********************************************************************
// 1633  * @fn          gp_u16CastPointer
// 1634  *
// 1635  * @brief       General function fill uint16 from pionter.
// 1636  *
// 1637  * @param       pBitField - pointer to the bit field.
// 1638  *              bit       - position of the bit to set in the given bitfield.
// 1639  *
// 1640  * @return      
// 1641  */
// 1642 static void gp_u16CastPointer( uint8 *data, uint8 *p )
// 1643 {
// 1644     *( uint16* )data |= ( ( *( uint16* ) p++ )       & 0x00FF );
// 1645     *( uint16* )data |= ( ( *( uint16* ) p++ <<  8 ) & 0xFF00 );
// 1646 }
// 1647 
// 1648  /*********************************************************************
// 1649  * @fn          gp_u8CastPointer
// 1650  *
// 1651  * @brief       General function fill uint16 from pionter.
// 1652  *
// 1653  * @param       pBitField - pointer to the bit field.
// 1654  *              bit       - position of the bit to set in the given bitfield.
// 1655  *
// 1656  * @return      
// 1657  */
// 1658 static void gp_u8CastPointer( uint8 *data, uint8 *p )
// 1659 {
// 1660     *( uint8* )data |= ( ( *( uint8* ) p ) );
// 1661 }
// 1662 
// 1663  /*********************************************************************
// 1664  * @fn          gp_getProxyTableByIndex
// 1665  *
// 1666  * @brief       General function to get proxy table entry by NV index
// 1667  *
// 1668  * @param       nvIndex - NV Id of proxy table
// 1669  *              pEntry  - pointer to PROXY_TBL_ENTRY_LEN array
// 1670  *
// 1671  * @return      
// 1672  */
// 1673 uint8 gp_getProxyTableByIndex( uint16 nvIndex, uint8 *pEntry )
// 1674 {
// 1675   uint8 status;
// 1676   uint16 emptyEntry = 0xFFFF;
// 1677   
// 1678   
// 1679   if ( ( nvIndex < ZCD_NV_PROXY_TABLE_START ) || ( nvIndex > ZCD_NV_PROXY_TABLE_END ) )
// 1680   {
// 1681     return NV_OPER_FAILED;
// 1682   }
// 1683   
// 1684   status = osal_nv_read( nvIndex, 0,
// 1685                           PROXY_TBL_ENTRY_LEN, pEntry );
// 1686   
// 1687   if ( status != SUCCESS )
// 1688   {
// 1689     // Return the failure status of NV read procedure
// 1690     return status;
// 1691   }
// 1692     
// 1693       
// 1694   // if the entry is empty
// 1695   if ( osal_memcmp( pEntry, &emptyEntry, sizeof ( uint16 ) ) )
// 1696   {
// 1697     return NV_INVALID_DATA;
// 1698   }
// 1699   
// 1700   return status;
// 1701 }
// 1702 
// 1703 /*********************************************************************
// 1704  * @fn          GP_DataInd
// 1705  *
// 1706  * @brief       This passes the MCPS data indications received in MAC to the application
// 1707  *
// 1708  * @param       gp_DataInd
// 1709  *
// 1710  * @return      FreeMsg - TRUE if the message will be released, False if it will 
// 1711  *                        be keeped for duplicate filtering
// 1712  */
// 1713 uint8 GP_DataInd(gp_DataInd_t *gp_DataInd)
// 1714 {
// 1715   uint32   timeout;
// 1716   uint8    freeMsg = FALSE;
// 1717   gpd_ID_t gpd_ID;
// 1718   uint8    ProxyTableEntryTemp[PROXY_TBL_ENTRY_LEN];
// 1719   uint16   ProxyTableEntryIndex = 0;
// 1720   
// 1721   //If authentication/decryption fail, then drop the frame and stop processing
// 1722   //GP Basic proxy A.3.5.2.3
// 1723   if(gp_DataInd->status == GP_DATA_IND_STATUS_COUNTER_FAILURE ||
// 1724       gp_DataInd->status == GP_DATA_IND_STATUS_AUTH_FAILURE )
// 1725   {
// 1726     return freeMsg;
// 1727   }
// 1728 
// 1729   gp_DataIndAppendToList(gp_DataInd, &gp_DataIndList);
// 1730   
// 1731   gp_DataInd->SecReqHandling.timeout = gpDuplicateTimeout;
// 1732   //Consider the current time elapsed to the next timeout
// 1733   timeout = osal_get_timeoutEx(gp_TaskID,GP_DUPLICATE_FILTERING_TIMEOUT_EVENT);
// 1734   
// 1735   if(timeout)
// 1736   {
// 1737     gp_DataInd->SecReqHandling.timeout += timeout;
// 1738   }  
// 1739   else
// 1740   {
// 1741     osal_start_timerEx(gp_TaskID,GP_DUPLICATE_FILTERING_TIMEOUT_EVENT,gp_DataInd->SecReqHandling.timeout);
// 1742   }  
// 1743 
// 1744   gpd_ID.AppID = gp_DataInd->appID;
// 1745   if(gp_DataInd->appID == GP_OPT_APP_ID_IEEE)
// 1746   {
// 1747     osal_memcpy(gpd_ID.GPDId.GPDExtAddr, gp_DataInd->srcAddr.addr.extAddr, Z_EXTADDR_LEN);
// 1748   }
// 1749   else
// 1750   {
// 1751     gpd_ID.GPDId.SrcID = gp_DataInd->SrcId;
// 1752   }
// 1753 
// 1754   if(gp_getProxyTableByGpId(&gpd_ID,ProxyTableEntryTemp,&ProxyTableEntryIndex) == ZSuccess)
// 1755   {
// 1756 
// 1757     //Update Sec Frame counter to proxy table  A.3.6.1.3
// 1758     osal_nv_write( ProxyTableEntryIndex, PROXY_TBL_ENTRY_SEC_FRAME,
// 1759                        sizeof(uint32), (uint8*) &gp_DataInd->GPDSecFrameCounter );
// 1760   }  
// 1761 
// 1762   if ( zgGP_InCommissioningMode == TRUE )
// 1763   {
// 1764     if(gp_DataInd->GPDCmmdID == GP_CHANNEL_REQ_COMMAND_ID)
// 1765     {
// 1766       if(pfnChangeChannelReqForBDB)
// 1767       {
// 1768         //Check if we got permission from BDB
// 1769         if(!pfnChangeChannelReqForBDB())
// 1770         {
// 1771           //No permisssion
// 1772           return freeMsg;
// 1773         }
// 1774       }
// 1775       if(pfnChangeChannelReq)
// 1776       {
// 1777         //Check if we got permission from BDB
// 1778         if(!pfnChangeChannelReq())
// 1779         {
// 1780           //No permisssion
// 1781           return freeMsg;
// 1782         }
// 1783       }
// 1784       
// 1785       osal_start_timerEx(gp_TaskID,GP_CHANNEL_CONFIGURATION_TIMEOUT,gpBirectionalCommissioningChangeChannelTimeout);
// 1786     }
// 1787     GP_ProccessCommissioningNotification( gp_DataInd );
// 1788   }
// 1789   else if ( ( zgGP_InCommissioningMode == FALSE ) )
// 1790   {
// 1791     GP_ProccessNotification( gp_DataInd );
// 1792   }
// 1793   
// 1794   return freeMsg;
// 1795 }
// 1796 
// 1797 /*********************************************************************
// 1798  * @fn          GP_ProccessCommissioningNotification
// 1799  *
// 1800  * @brief       General function to process the GP Manteinance Indication in operational mode
// 1801  *
// 1802  * @param       gp_DataInd
// 1803  *
// 1804  * @return      none
// 1805  */
// 1806 static void GP_ProccessCommissioningNotification(gp_DataInd_t *gp_DataInd)
// 1807 {
// 1808   gpCommissioningNotificationCmd_t gpNotification;
// 1809   
// 1810   if ( ( gp_DataInd->GPDCmmdID == GP_COMMISSIONING_COMMAND_ID ) || ( gp_DataInd->GPDCmmdID == GP_SUCCESS_COMMAND_ID ) ||
// 1811        ( gp_DataInd->GPDCmmdID == GP_CHANNEL_REQ_COMMAND_ID ) )
// 1812   {
// 1813   
// 1814     osal_memset( &gpNotification, 0, sizeof ( gpCommissioningNotificationCmd_t ) );
// 1815     zclGp_ManteinanceIndParse( gp_DataInd, &gpNotification );
// 1816   
// 1817     zclGp_SendGpCommissioningNotificationCommand ( &gpNotification );
// 1818   }
// 1819 }
// 1820 
// 1821 /*********************************************************************
// 1822  * @fn          GP_ProccessNotification
// 1823  *
// 1824  * @brief       General function to process the GP Data Indication in operational mode
// 1825  *
// 1826  * @param       gp_DataInd
// 1827  *
// 1828  * @return      none
// 1829  */
// 1830 static void GP_ProccessNotification(gp_DataInd_t *gp_DataInd)
// 1831 {
// 1832   gpNotificationCmd_t gpNotification;
// 1833   
// 1834   osal_memset( &gpNotification, 0, sizeof ( gpNotificationCmd_t ) );
// 1835   zclGp_DataIndParse( gp_DataInd, &gpNotification );
// 1836   
// 1837   zclGp_SendGpNotificationCommand ( &gpNotification, gp_DataInd->SeqNumber );
// 1838 }
// 1839 
// 1840 /*********************************************************************
// 1841  * @fn          GP_SecReq
// 1842  *
// 1843  * @brief       Primitive from dGP stub to GP EndPoint asking how to process a GPDF.
// 1844  *
// 1845  * @param       gp_SecReq 
// 1846  *
// 1847  * @return      none
// 1848  */
// 1849 uint8 GP_SecReq(gp_SecReq_t *gp_SecReq)
// 1850 {
// 1851   gp_SecRsp_t *gp_SecRsp = NULL;
// 1852   uint8 status;
// 1853   uint8  ProxyTableEntryTemp[PROXY_TBL_ENTRY_LEN];
// 1854   gp_DataInd_t* temp;
// 1855   uint8   KeyType;
// 1856   uint8   Key[SEC_KEY_LEN];
// 1857 
// 1858 
// 1859   gp_SecRsp = (gp_SecRsp_t*)osal_msg_allocate(sizeof(gp_SecRsp_t));
// 1860 
// 1861   //No mem, then do not release the msg, process later
// 1862   if(gp_SecRsp == NULL)
// 1863   {
// 1864     return FALSE;
// 1865   }
// 1866   
// 1867   gp_SecRsp->hdr.event = GP_SEC_RSP;
// 1868   gp_SecRsp->hdr.status = ZSuccess;
// 1869 
// 1870   gp_SecRsp->dGPStubHandle = gp_SecReq->dGPStubHandle;
// 1871   gp_SecRsp->EndPoint = gp_SecReq->EndPoint;
// 1872 
// 1873   osal_memcpy(&gp_SecRsp->gp_SecData,&gp_SecReq->gp_SecData, sizeof(gp_SecData_t));
// 1874   osal_memcpy(&gp_SecRsp->gpd_ID,&gp_SecReq->gpd_ID, sizeof(gpd_ID_t));
// 1875 
// 1876   gp_SecRsp->Status = GP_SEC_RSP_DROP_FRAME;
// 1877  
// 1878   //Find duplicates A.3.6.1.2 Duplicate filtering
// 1879   if( gp_DataIndFindDuplicate(gp_SecReq->dGPStubHandle, gp_SecReq->gp_SecData.GPDFSecLvl) )
// 1880   {  //Check if the entry exist
// 1881     if ( gp_getProxyTableByGpId(&gp_SecReq->gpd_ID, ProxyTableEntryTemp, NULL) == ZSuccess )
// 1882     {
// 1883       gp_SecRsp->Status = GP_SEC_RSP_DROP_FRAME;
// 1884       osal_msg_send(gp_TaskID,(uint8*)gp_SecRsp);
// 1885 
// 1886       return TRUE;
// 1887     }
// 1888   }
// 1889   
// 1890   temp = gp_DataIndGet(gp_SecReq->dGPStubHandle);
// 1891     
// 1892   //Section A.3.7.3.3
// 1893   status = gp_SecurityOperationProxy(temp,&KeyType,Key);
// 1894 
// 1895   switch(status)
// 1896   {
// 1897     case GP_SEC_RSP_ERROR:  //This should not happen
// 1898     case GP_SEC_RSP_DROP_FRAME:
// 1899       gp_SecRsp->Status = GP_SEC_RSP_DROP_FRAME;
// 1900     break;
// 1901     
// 1902     case GP_SEC_RSP_PASS_UNPROCESSED:  
// 1903       gp_SecRsp->Status = GP_SEC_RSP_PASS_UNPROCESSED;
// 1904     break;
// 1905     
// 1906     case GP_SEC_RSP_MATCH:
// 1907     case GP_SEC_RSP_TX_THEN_DROP:
// 1908       if(GP_RecoveryKey(gp_SecReq->gp_SecData.GPDFKeyType,KeyType,status,Key) == GP_SEC_RSP_DROP_FRAME)
// 1909       {
// 1910         gp_SecRsp->Status = GP_SEC_RSP_DROP_FRAME;
// 1911       }
// 1912       else
// 1913       {
// 1914         gp_SecRsp->Status = status;
// 1915         osal_memcpy(gp_SecRsp->GPDKey,Key,SEC_KEY_LEN);
// 1916       }
// 1917     break;
// 1918   }
// 1919 
// 1920 
// 1921   osal_msg_send(gp_TaskID,(uint8*)gp_SecRsp);
// 1922   return TRUE;
// 1923 }
// 1924 
// 1925 /*********************************************************************
// 1926  * @fn          GP_RecoveryKey
// 1927  *
// 1928  * @brief       Procedure to retrive the key to be used to decrypt the GPDF
// 1929  *
// 1930  * @param       GPDFKeyType   KeyType from the GPDF
// 1931  * @param       KeyType       Key type in the Proxy table entry for this GPD
// 1932  * @param       Status        Previous status to search key (MATCH, TX_THEN_DROP)
// 1933  * @param       Key[out]      Key to be used
// 1934  *                       
// 1935  * @return      Status
// 1936  */
// 1937 uint8 GP_RecoveryKey(uint8 GPDFKeyType,uint8 KeyType, uint8 status, uint8 *Key)
// 1938 {
// 1939   uint8 TempKey[SEC_KEY_LEN] = {0xFF};
// 1940   //TODO: A.3.7.3.4 Incoming frames: key recovery
// 1941   if(GPDFKeyType)
// 1942   {
// 1943     if(KeyType == GP_SECURITY_KEY_TYPE_OUT_OF_BOX_GPD_KEY)
// 1944     {
// 1945       //Is the key of the Proxy table entry empty?
// 1946       if(osal_memcmp(&Key,&TempKey,SEC_KEY_LEN))
// 1947       {
// 1948         return GP_SEC_RSP_DROP_FRAME;
// 1949       }          
// 1950       else
// 1951       {
// 1952         //There is a key, then use it
// 1953         return status;
// 1954       }
// 1955     }
// 1956     else if(KeyType == GP_SECURITY_KEY_TYPE_DERIVED_IND_GPD_KEY)
// 1957     {
// 1958       //Is the key of the Proxy table entry empty?
// 1959       if(osal_memcmp(&Key,&TempKey,SEC_KEY_LEN))
// 1960       {
// 1961         return GP_SEC_RSP_DROP_FRAME;
// 1962       }  
// 1963       //There is a key, then use it. Derived keys are provided by the Sink 
// 1964       //device at paring time according to A.3.7.1.2.2
// 1965       return status;
// 1966     }
// 1967     else
// 1968     {
// 1969       return GP_SEC_RSP_DROP_FRAME;
// 1970     }
// 1971   }
// 1972   else
// 1973   {
// 1974     uint8  gpSharedSecKeyType;
// 1975     uint16 AttLen;
// 1976 
// 1977     //Get the SharedKeyType Attribute
// 1978     zcl_ReadAttrData(GREEN_POWER_INTERNAL_ENDPOINT,ZCL_CLUSTER_ID_GREEN_POWER,ATTRID_GP_SHARED_SEC_KEY_TYPE,&gpSharedSecKeyType,&AttLen);
// 1979 
// 1980     if(KeyType == gpSharedSecKeyType)
// 1981     {
// 1982       if(!osal_memcmp(TempKey,zgpSharedKey,SEC_KEY_LEN))
// 1983       {
// 1984         //Use key shared key
// 1985         osal_memcpy(Key,zgpSharedKey,SEC_KEY_LEN);
// 1986         return status;
// 1987       }
// 1988     }
// 1989     if(KeyType == GP_SECURITY_KEY_TYPE_ZIGBEE_NWK_KEY)
// 1990     {
// 1991       ZDSecMgrReadKeyFromNv(ZCD_NV_PRECFGKEY,Key);
// 1992     }
// 1993     //There is a key, then use it. Derived keys are provided by the Sink 
// 1994     //device at paring time according to A.3.7.1.2.2
// 1995     else
// 1996     {
// 1997       return GP_SEC_RSP_DROP_FRAME;
// 1998     }
// 1999   }
// 2000   return status;
// 2001 }
// 2002 
// 2003 
// 2004 gp_DataInd_t* gp_DataIndFindDuplicate(uint8 handle, uint8 secLvl)
// 2005 {
// 2006   gp_DataInd_t* temp;
// 2007   gp_DataInd_t* tempList;
// 2008   temp = gp_DataIndGet(handle);
// 2009   
// 2010   if(temp != NULL)
// 2011   {
// 2012     tempList = gp_DataIndList;
// 2013     
// 2014     while(tempList != NULL)
// 2015     {
// 2016       //search for MAC seq num
// 2017       if(secLvl == 0)
// 2018       {
// 2019         if((temp->SeqNumber == tempList->SeqNumber) && (temp->appID == tempList->appID)&&
// 2020            (temp->SecReqHandling.dGPStubHandle != tempList->SecReqHandling.dGPStubHandle))
// 2021         {
// 2022           break;
// 2023         }
// 2024       }
// 2025       //Other secLevels uses SecFrameCounter
// 2026       else
// 2027       {
// 2028         if((temp->GPDSecFrameCounter == tempList->GPDSecFrameCounter) && 
// 2029            (temp->SecReqHandling.dGPStubHandle != tempList->SecReqHandling.dGPStubHandle))
// 2030         {
// 2031           
// 2032           break;
// 2033         }
// 2034       }
// 2035       tempList = tempList->SecReqHandling.next;
// 2036     }
// 2037   }
// 2038   return tempList;
// 2039 }
// 2040  
// 2041 /*********************************************************************
// 2042  * @fn          GP_DataCnf
// 2043  *
// 2044  * @brief       Primitive to notify GP EndPoint the status of a previews DataReq
// 2045  *
// 2046  * @param       gp_DataCnf
// 2047  *
// 2048  * @return      none
// 2049  */
// 2050 void GP_DataCnf(gp_DataCnf_t *gp_DataCnf)
// 2051 {
// 2052   //Current spec does not mandates to do anything with this.
// 2053   switch(gp_DataCnf->status)
// 2054   {
// 2055     case GP_DATA_CNF_TX_QUEUE_FULL:
// 2056     case GP_DATA_CNF_ENTRY_REPLACED:
// 2057     case GP_DATA_CNF_ENTRY_ADDED:
// 2058     case GP_DATA_CNF_ENTRY_EXPIRED:
// 2059     case GP_DATA_CNF_ENTRY_REMOVED:
// 2060     case GP_DATA_CNF_GPDF_SENDING_FINALIZED:
// 2061     break;
// 2062   }  
// 2063 }
// 2064 
// 2065  /*********************************************************************
// 2066  * PRIVATE FUNCTIONS
// 2067  *********************************************************************/
// 2068 
// 2069 void gp_RegisterCommissioningModeCB(gpCommissioningMode_t gpCommissioningMode)
// 2070 {
// 2071   if(gpCommissioningMode)
// 2072   {
// 2073      pfnCommissioningMode = gpCommissioningMode;
// 2074   }
// 2075 }
// 2076 
// 2077 /*********************************************************************
// 2078  * @fn          gp_RegisterGPChangeChannelReqCB
// 2079  *
// 2080  * @brief       Register a callback in which the application will be notified about a change
// 2081  *              of channel for at most gpBirectionalCommissioningChangeChannelTimeout ms
// 2082  *              to perform GP bidirectional commissioning in the channel parameter.
// 2083  *
// 2084  * @param       gpChangeChannelReq
// 2085  *
// 2086  * @return      none
// 2087  */
// 2088 void gp_RegisterGPChangeChannelReqCB(gpChangeChannelReq_t gpChangeChannelReq)
// 2089 {
// 2090   if(gpChangeChannelReq)
// 2091   {
// 2092     pfnChangeChannelReq = gpChangeChannelReq;
// 2093   }
// 2094 }
// 2095 
// 2096 /*********************************************************************
// 2097  * @fn          gp_RegisterGPChangeChannelReqForBDBCB
// 2098  *
// 2099  * @brief       Register a callback in which the bdb will be notified about a change
// 2100  *              of channel for at most gpBirectionalCommissioningChangeChannelTimeout ms
// 2101  *              to perform GP bidirectional commissioning in the channel parameter.
// 2102  *
// 2103  * @param       gpChangeChannelReq
// 2104  *
// 2105  * @return      none
// 2106  */
// 2107 void gp_RegisterGPChangeChannelReqForBDBCB(gpChangeChannelReq_t gpChangeChannelReq)
// 2108 {
// 2109   if(gpChangeChannelReq)
// 2110   {
// 2111     pfnChangeChannelReqForBDB = gpChangeChannelReq;
// 2112   }
// 2113 }
// 2114 
// 2115 
// 2116 
// 2117 
// 2118 /*********************************************************************
// 2119  * @fn          gp_returnOperationalChannel
// 2120  *
// 2121  * @brief       Return to the operational channel after bidirectional commissioning
// 2122  *
// 2123  * @param       none
// 2124  *
// 2125  * @return      none
// 2126  */
// 2127 void gp_returnOperationalChannel(void)
// 2128 {
// 2129   gp_DataReq_t gp_DataReq;
// 2130   _NIB.nwkLogicalChannel = gp_tempLogicalChannel;
// 2131   ZMacSetReq( ZMacChannel, &(_NIB.nwkLogicalChannel) );
// 2132   osal_stop_timerEx(gp_TaskID,GP_CHANNEL_CONFIGURATION_TIMEOUT);
// 2133   
// 2134   gp_DataReq.Action = 0;
// 2135   gp_DataReq.gpd_ID.AppID = GP_APP_ID_DEFAULT;
// 2136   gp_DataReq.gpd_ID.GPDId.SrcID = 0;
// 2137   
// 2138   GP_DataReq(&gp_DataReq);
// 2139 }
// 2140 
// 2141      
// 2142  /*********************************************************************
// 2143  * @fn          gp_expireDuplicateFiltering
// 2144  *
// 2145  * @brief       Process the expiration of the packets in the duplicate filtering
// 2146  *              list. Assumption is the first in the queue is the first into expire.
// 2147  *
// 2148  * @param       none
// 2149  *
// 2150  * @return      none
// 2151  */    
// 2152 void gp_expireDuplicateFiltering(void)
// 2153 {
// 2154   gp_DataInd_t * temp;
// 2155   uint32 timeout;
// 2156   
// 2157   temp = gp_DataIndList;
// 2158   timeout = gp_DataIndList->SecReqHandling.timeout;
// 2159   
// 2160   while(temp != NULL)
// 2161   {
// 2162     if(timeout >= temp->SecReqHandling.timeout)
// 2163     {
// 2164       gp_DataInd_t *expired = temp;   
// 2165       
// 2166       temp = temp->SecReqHandling.next;
// 2167       gp_DataIndReleaseFromList(TRUE, expired,&gp_DataIndList);
// 2168     }
// 2169     else
// 2170     {
// 2171       temp->SecReqHandling.timeout -= timeout;
// 2172       temp = temp->SecReqHandling.next;
// 2173     }
// 2174   }
// 2175   osal_start_timerEx(gp_TaskID, GP_DUPLICATE_FILTERING_TIMEOUT_EVENT, timeout);
// 2176 }
// 2177 
// 2178 #endif
// 2179 /*********************************************************************
// 2180 *********************************************************************/
// 2181 
// 
//
// 
//
//
//Errors: none
//Warnings: none
