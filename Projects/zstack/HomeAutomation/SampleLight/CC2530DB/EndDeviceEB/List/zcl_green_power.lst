###############################################################################
#
# IAR C/C++ Compiler V10.30.1.6000 for 8051               19/Apr/2021  17:31:12
# Copyright 2004-2018 IAR Systems AB.
# Evaluation license - IAR Embedded Workbench for 8051, Evaluation edition 10.30
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Components\stack\zcl\zcl_green_power.c
#    Command line       =  
#        -f C:\users\slavko\Temp\EW25ac.tmp ("C:\Texas Instruments\Z-Stack
#        3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Components\stack\zcl\zcl_green_power.c" -D BDB_REPORTING -D
#        SECURE=1 -D TC_LINKKEY_JOIN -D NV_INIT -D NV_RESTORE -D xPOWER_SAVING
#        -D NWK_AUTO_POLL -D xZTOOL_P1 -D xMT_TASK -D xMT_APP_FUNC -D
#        xMT_SYS_FUNC -D xMT_ZDO_FUNC -D xMT_ZDO_MGMT -D xMT_APP_CNF_FUNC -D
#        LCD_SUPPORTED=DEBUG -D MULTICAST_ENABLED=FALSE -D ZCL_READ -D
#        ZCL_DISCOVER -D ZCL_WRITE -D ZCL_BASIC -D ZCL_IDENTIFY -D ZCL_ON_OFF
#        -D ZCL_SCENES -D ZCL_GROUPS -D ZCL_LEVEL_CTRL -lC "C:\Texas
#        Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\EndDeviceEB\List"
#        -lA "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\EndDeviceEB\List"
#        --diag_suppress Pe001,Pa010 -o "C:\Texas Instruments\Z-Stack
#        3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\EndDeviceEB\Obj"
#        -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data_rom --nr_virtual_regs 16 -f "C:\Texas
#        Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\Tools\CC2530DB\f8wEndev.cfg"
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_TX_DATA_MAX=3
#        -DMAC_CFG_TX_MAX=6 -DMAC_CFG_RX_MAX=3) -f "C:\Texas
#        Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg"
#        (-DZIGBEEPRO -DSECURE=1 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 -DDEFAULT_KEY={0} -DMAC_MAX_FRAME_SIZE=116
#        -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const __code"
#        -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000
#        -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100 -DREJOIN_POLL_RATE=440
#        -DREJOIN_BACKOFF=900000 -DREJOIN_SCAN=900000 -DENABLE_LED4_DISABLE_S1)
#        -f "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\Tools\CC2530DB\f8wZCL.cfg"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\" -I
#        "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\Source\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\Source\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\ZMain\TI2530DB\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\hal\include\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\mac\include\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\mac\high_level\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\single_chip\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\mt\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\osal\include\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\services\saddr\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\services\sdata\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\af\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\bdb\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\gp\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\nwk\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\sapi\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\sec\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\sys\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\zcl\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\zdo\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\zmac\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\zmac\f8w\"
#        -Ohz --require_prototypes)
#    Locale             =  English_USA.1252
#    List file          =  
#        C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\EndDeviceEB\List\zcl_green_power.lst
#    Object file        =  
#        C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\EndDeviceEB\Obj\zcl_green_power.r51
#
###############################################################################

C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack 3.0.2\Components\stack\zcl\zcl_green_power.c
      1          /**************************************************************************************************
      2            Filename:       zcl_green_power.c
      3            Revised:        $Date: 2015-09-10 09:36:48 -0700 (Thu, 10 Sep 2015) $
      4            Revision:       $Revision: 44493 $
      5          
      6            Description:    Zigbee Cluster Library - General.  This application receives all
      7                            ZCL messages and initially parses them before passing to application.
      8          
      9          
     10            Copyright 2006-2015 Texas Instruments Incorporated. All rights reserved.
     11          
     12            IMPORTANT: Your use of this Software is limited to those specific rights
     13            granted under the terms of a software license agreement between the user
     14            who downloaded the software, his/her employer (which must be your employer)
     15            and Texas Instruments Incorporated (the "License"). You may not use this
     16            Software unless you agree to abide by the terms of the License. The License
     17            limits your use, and you acknowledge, that the Software may not be modified,
     18            copied or distributed unless embedded on a Texas Instruments microcontroller
     19            or used solely and exclusively in conjunction with a Texas Instruments radio
     20            frequency transceiver, which is integrated into your product. Other than for
     21            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     22            works of, modify, distribute, perform, display or sell this Software and/or
     23            its documentation for any purpose.
     24          
     25            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     26            PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     27            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     28            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     29            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     30            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     31            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     32            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     33            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     34            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     35            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     36          
     37            Should you have any questions regarding your right to use this Software,
     38            contact Texas Instruments Incorporated at www.TI.com.
     39          **************************************************************************************************/
     40          
     41          
     42          
     43          /*********************************************************************
     44           * INCLUDES
     45           */
     46          
     47          #include "ZGlobals.h"  
     48          #include "ZComDef.h"
     49          #include "zcl.h"
     50          #include "zcl_green_power.h"
     51          #include "stub_aps.h"
     52          #include "gp_common.h"
     53          #include "bdb_interface.h"
     54             
     55          #if !defined (DISABLE_GREENPOWER_BASIC_PROXY) && (ZG_BUILD_RTR_TYPE)
     56          
     57          /*********************************************************************
     58           * MACROS
     59           */
     60          
     61          /*********************************************************************
     62           * CONSTANTS
     63           */
     64          
     65          //const static uint8 PROXY_BASIC_TBL_EMPTY_ENTRY[]  =  {0xFF, 0xFF, /* Options 16-bit bitmap */  \
     66                                                 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /*GPD ID Unsigned 32-bit integer/ IEEE address */  \
     67                                                 0x00, /* Endpoint Unsigned 8-bit integer */  \
     68                                                 0xFF, 0xFF, /* GPD Assigned Alias Unsigned 16-bit integer */  \
     69                                                 0xFF, /* Security Options 8-bit bitmap */  \
     70                                                 0xFF, 0xFF, 0xFF, 0xFF, /* GPD security frame counter Unsigned 32-bit Integer */  \
     71                                                 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, /* GPD key Security key */  \
     72                                                 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /* Lightweight sink address list sequence of octets */  \
     73                                                 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, \
     74                                                 0x00, /* Free group entries flag */  \
     75                                                 0x00, 0x00, 0x00, 0x00, /* Sink group list sequence of octets */  \
     76                                                 0x00, 0x00, 0x00, 0x00,  \
     77                                                 0x00, /* Groupcast radius Unsigned 8-bit integer */  \
     78                                                 0x00 /* Search Counter Unsigned 8-bit integer */  \
     79                                                };   
     80             
     81          /*********************************************************************
     82           * TYPEDEFS
     83           */
     84          
     85          typedef struct zclGpCBRec
     86          {
     87            struct zclGpCBRec        *next;
     88            uint8                     endpoint; // Used to link it into the endpoint descriptor
     89            zclGp_AppCallbacks_t     *CBs;      // Pointer to Callback function
     90          } zclGpCBRec_t;
     91          
     92          
     93          /*********************************************************************
     94           * GLOBAL VARIABLES
     95           */
     96          
     97          /*********************************************************************
     98           * GLOBAL FUNCTIONS
     99           */
    100          
    101          /*********************************************************************
    102           * LOCAL VARIABLES
    103           */
    104          static zclGpCBRec_t *zclGpCBs = (zclGpCBRec_t *)NULL;
    105          static uint8 zclGpPluginRegisted = FALSE;
    106          static gpNotificationMsg_t *pNotificationMsgHead = NULL;
    107          static gpCmdPayloadMsg_t *pCmdPayloadMsgHead = NULL;
    108          
    109          //static zclGenSceneItem_t *zclGenSceneTable = (zclGenSceneItem_t *)NULL;
    110          
    111          
    112          /*********************************************************************
    113           * LOCAL FUNCTIONS
    114           */
    115          static ZStatus_t zclGp_HdlIncoming( zclIncoming_t *pInMsg );
    116          static ZStatus_t zclGp_HdlInSpecificCommands( zclIncoming_t *pInMsg );
    117          static zclGp_AppCallbacks_t *zclGp_FindCallbacks( uint8 endpoint );
    118          static uint8 gp_addPairedSinksToMsgQueue( uint8 appId, uint8 *pId, gpCmdPayloadMsg_t* pMsg );
    119          
    120          static ZStatus_t zclGp_ProcessInProxyBasic( zclIncoming_t *pInMsg, zclGp_AppCallbacks_t *pCBs );
    121          
    122          
    123          /*********************************************************************
    124           * @fn      zclGp_RegisterCmdCallbacks
    125           *
    126           * @brief   Register an applications command callbacks
    127           *
    128           * @param   endpoint - application's endpoint
    129           * @param   callbacks - pointer to the callback record.
    130           *
    131           * @return  ZMemError if not able to allocate
    132           */
    133          ZStatus_t zclGp_RegisterCmdCallbacks( uint8 endpoint, zclGp_AppCallbacks_t *callbacks )
    134          {
    135            zclGpCBRec_t *pNewItem;
    136            zclGpCBRec_t *pLoop;
    137          
    138            // Register as a ZCL Plugin
    139            if ( zclGpPluginRegisted == FALSE )
    140            {
    141              zcl_registerPlugin( ZCL_CLUSTER_ID_GREEN_POWER,
    142                                  ZCL_CLUSTER_ID_GREEN_POWER,
    143                                  zclGp_HdlIncoming );
    144          
    145              zclGpPluginRegisted = TRUE;
    146            }
    147          
    148            // Fill in the new profile list
    149            pNewItem = zcl_mem_alloc( sizeof( zclGpCBRec_t ) );
    150            if ( pNewItem == NULL )
    151              return (ZMemError);
    152          
    153            pNewItem->next = (zclGpCBRec_t *)NULL;
    154            pNewItem->endpoint = endpoint;
    155            pNewItem->CBs = callbacks;
    156          
    157            // Find spot in list
    158            if (  zclGpCBs == NULL )
    159            {
    160              zclGpCBs = pNewItem;
    161            }
    162            else
    163            {
    164              // Look for end of list
    165              pLoop = zclGpCBs;
    166              while ( pLoop->next != NULL )
    167                pLoop = pLoop->next;
    168          
    169              // Put new item at end of list
    170              pLoop->next = pNewItem;
    171            }
    172          
    173            return ( ZSuccess );
    174          }
    175          
    176          /*********************************************************************
    177           * @fn      zclGp_FindCallbacks
    178           *
    179           * @brief   Find the callbacks for an endpoint
    180           *
    181           * @param   endpoint - endpoint to find the application callbacks for
    182           *
    183           * @return  pointer to the callbacks
    184           */
    185          static zclGp_AppCallbacks_t *zclGp_FindCallbacks( uint8 endpoint )
    186          {
    187            zclGpCBRec_t *pCBs;
    188          
    189            pCBs = zclGpCBs;
    190            while ( pCBs )
    191            {
    192              if ( pCBs->endpoint == endpoint )
    193                return ( pCBs->CBs );
    194              pCBs = pCBs->next;
    195            }
    196            return ( (zclGp_AppCallbacks_t *)NULL );
    197          }
    198          
    199          /*********************************************************************
    200           * @fn      zclGp_HdlIncoming
    201           *
    202           * @brief   Callback from ZCL to process incoming Commands specific
    203           *          to this cluster library or Profile commands for attributes
    204           *          that aren't in the attribute list
    205           *
    206           *
    207           * @param   pInMsg - pointer to the incoming message
    208           *
    209           * @return  ZStatus_t
    210           */
    211          static ZStatus_t zclGp_HdlIncoming( zclIncoming_t *pInMsg )
    212          {
    213            ZStatus_t stat = ZSuccess;
    214          
    215          #if defined ( INTER_PAN )
    216            if ( StubAPS_InterPan( pInMsg->msg->srcAddr.panId, pInMsg->msg->srcAddr.endPoint ) )
    217              return ( stat ); // Cluster not supported thru Inter-PAN
    218          #endif
    219            if ( zcl_ClusterCmd( pInMsg->hdr.fc.type ) )
    220            {
    221              // Is this a manufacturer specific command?
    222              if ( pInMsg->hdr.fc.manuSpecific == 0 )
    223              {
    224                stat = zclGp_HdlInSpecificCommands( pInMsg );
    225              }
    226              else
    227              {
    228                // We don't support any manufacturer specific command.
    229                stat = ZFailure;
    230              }
    231            }
    232            else
    233            {
    234              // Handle all the normal (Read, Write...) commands -- should never get here
    235              stat = ZFailure;
    236            }
    237            return ( stat );
    238          }
    239          
    240          /*********************************************************************
    241           * @fn      zclGp_HdlInSpecificCommands
    242           *
    243           * @brief   Callback from ZCL to process incoming Commands specific
    244           *          to this cluster library
    245          
    246           * @param   pInMsg - pointer to the incoming message
    247           *
    248           * @return  ZStatus_t
    249           */
    250          static ZStatus_t zclGp_HdlInSpecificCommands( zclIncoming_t *pInMsg )
    251          {
    252            ZStatus_t stat;
    253            zclGp_AppCallbacks_t *pCBs;
    254          
    255            // make sure endpoint exists
    256            pCBs = zclGp_FindCallbacks( pInMsg->msg->endPoint );
    257            if ( pCBs == NULL )
    258              return ( ZFailure );
    259          
    260            switch ( pInMsg->msg->clusterId )
    261            {
    262              case ZCL_CLUSTER_ID_GREEN_POWER:
    263                // Proxy Basic handler
    264                stat = zclGp_ProcessInProxyBasic( pInMsg, pCBs );
    265                break;
    266          
    267              default:
    268                stat = ZFailure;
    269                break;
    270            }
    271          
    272            return ( stat );
    273          }
    274          
    275          /*********************************************************************
    276           * @fn      zclGp_ProcessInProxyBasic
    277           *
    278           * @brief   Process in the received client commands for the Proxy Basic.
    279           *
    280           * @param   pInMsg - pointer to the incoming message
    281           *
    282           * @return  ZStatus_t
    283           */
    284          static ZStatus_t zclGp_ProcessInProxyBasic( zclIncoming_t *pInMsg,
    285                                                    zclGp_AppCallbacks_t *pCBs )
    286          {
    287            // Server side command handler
    288            if ( zcl_ServerCmd( pInMsg->hdr.fc.direction ) )
    289            {
    290              // Server side command handling is not supported
    291              zclDefaultRspCmd_t defaultRspCmd;
    292          
    293              defaultRspCmd.commandID = pInMsg->hdr.commandID;
    294              defaultRspCmd.statusCode = ZCL_STATUS_UNSUP_CLUSTER_COMMAND;
    295              zcl_SendDefaultRspCmd( pInMsg->msg->endPoint, &(pInMsg->msg->srcAddr),
    296                                     pInMsg->msg->clusterId, &defaultRspCmd,
    297                                     ZCL_FRAME_SERVER_CLIENT_DIR, true, 0, pInMsg->hdr.transSeqNum );
    298            }
    299            // Client side command handler
    300            if ( zcl_ClientCmd( pInMsg->hdr.fc.direction ) )
    301            {
    302              switch ( pInMsg->hdr.commandID )
    303              {
    304                case COMMAND_GP_PAIRING:
    305                  if ( pCBs->pfnGpPairingCmd )
    306                  {
    307                    zclGpPairing_t cmd;
    308                    
    309                    zcl_InSeqNum = pInMsg->hdr.transSeqNum;
    310                    
    311                    cmd.srcAddr = &(pInMsg->msg->srcAddr);
    312                    osal_memcpy( cmd.options, (void*)pInMsg->pData, sizeof(cmd.options) );
    313                    pInMsg->pData += sizeof(cmd.options);  // Move data pointer after options field
    314                              
    315                    if ( pInMsg->pData == NULL )
    316                    {
    317                      return ZFailure;
    318                    }
    319                    
    320                    cmd.pData = pInMsg->pData;
    321                    pCBs->pfnGpPairingCmd( &cmd );
    322          
    323                  }
    324                  break;
    325                  
    326                case COMMAND_GP_PROXY_TABLE_REQUEST:
    327                  if ( pCBs->pfnGpProxyTableReqCmd )
    328                  {
    329                    zclGpProxyTableRequest_t cmd;
    330                    
    331                    zcl_InSeqNum = pInMsg->hdr.transSeqNum;
    332                    
    333                    cmd.srcAddr = &(pInMsg->msg->srcAddr);
    334                    osal_memcpy( &cmd.options, (void*)pInMsg->pData, sizeof(cmd.options) );
    335                    pInMsg->pData += sizeof(cmd.options);  // Move data pointer after options field
    336                    
    337                    if ( pInMsg->pData == NULL )
    338                    {
    339                      return ZFailure;
    340                    }
    341                    
    342                    cmd.pData = (void*)pInMsg->pData;
    343                    pCBs->pfnGpProxyTableReqCmd( &cmd );
    344          
    345                  }
    346                  break;
    347                case COMMAND_GP_PROXY_COMMISSIONING_MODE:
    348                  if(pCBs->pfnGpProxyCommissioningModeCmd)
    349                  {
    350                    zclGpProxyCommissioningMode_t cmd;
    351          
    352                    osal_memcpy( &cmd.options, (void*)pInMsg->pData, sizeof(cmd.options) );
    353                    pInMsg->pData += sizeof(cmd.options);  // Move data pointer after options field
    354                   
    355                    if ( pInMsg->pData == NULL )
    356                    {
    357                      return ZFailure;
    358                    }
    359          
    360                    cmd.pData = (void*)pInMsg->pData;
    361          
    362                    if(pInMsg->msg->srcAddr.addrMode == afAddr16Bit)
    363                    {
    364                      cmd.srcAddr = pInMsg->msg->srcAddr.addr.shortAddr;
    365                    }
    366                    
    367                    pCBs->pfnGpProxyCommissioningModeCmd( &cmd );
    368                  }
    369                  break;
    370                  case COMMAND_GP_RESPONSE:
    371                    
    372                    if(pCBs->pfnGpResponseCommand)
    373                    {
    374                      zclGpResponse_t cmd;
    375          
    376                      osal_memcpy( &cmd.options, (void*)pInMsg->pData, sizeof(cmd.options) );
    377                      pInMsg->pData += sizeof(cmd.options);  // Move data pointer after options field
    378                      
    379                      cmd.tempMasterShortAddr = osal_build_uint16(pInMsg->pData);
    380                      pInMsg->pData += sizeof(cmd.tempMasterShortAddr);  // Move data pointer after tempMaster field
    381                      
    382                      osal_memcpy( &cmd.tempMasterTxChannel, (void*)pInMsg->pData, sizeof(cmd.tempMasterTxChannel) );
    383                      pInMsg->pData += sizeof(cmd.tempMasterTxChannel);  // Move data pointer after options field
    384                      
    385                      cmd.dstAddr = pInMsg->msg->macDestAddr;  
    386                      
    387                      if ( pInMsg->pData == NULL )
    388                      {
    389                        return ZFailure;
    390                      }
    391                      cmd.pData = (void*)pInMsg->pData;
    392          
    393                      pCBs->pfnGpResponseCommand( &cmd ); 
    394                    }
    395                  break;
    396              }
    397            }
    398          
    399            return ( ZSuccess );
    400          }
    401          
    402          /*********************************************************************
    403           * @fn      zclGp_SendGpNotificationCommand
    404           *
    405           * @brief   Send the Green Power Notification Command to a device
    406           *
    407           * @param   pCmd - Pointer to GP Notification Struct
    408           *          secNum - Sequence number given by the GPDF  
    409           *
    410           * @return  ZStatus_t
    411           */
    412          ZStatus_t zclGp_SendGpNotificationCommand( gpNotificationCmd_t *pCmd, uint8 secNum )
    413          {
    414            uint8 *buf = NULL;
    415            uint8 *pBuf = NULL;
    416            uint8 *pGpdId = NULL;
    417            uint8 appId;
    418            ZStatus_t status;
    419            uint16 len = 11;  // options + GPD Sec Counter + Cmd ID + payloadLen + GPP Short Address + GPP-GPD link
    420            gpCmdPayloadMsg_t *pCmdPayloadMsgCurr = NULL;
    421            
    422            // Check some stuff to calculate the packet len
    423            // If Application Id bitfield is 0b000
    424            if( GP_IS_APPLICATION_ID_GPD( pCmd->options ) )
    425            {
    426              len += 4;  // GPD ID
    427            }
    428            // If Application Id bitfield is 0b010
    429            else if( GP_IS_APPLICATION_ID_IEEE( pCmd->options ) )
    430            {
    431              len += 9;  // IEEE addr + EP
    432            }
    433            
    434            // Length of the command payload
    435            len += pCmd->payloadLen;
    436          
    437            buf = zcl_mem_alloc( len );
    438            if ( buf )
    439            {
    440              pBuf = buf;
    441              
    442              zcl_memcpy( pBuf, &pCmd->options, sizeof ( uint16 ) );
    443              pBuf += sizeof ( uint16 );
    444              
    445              // If Application Id bitfield is 0b000
    446              if( GP_IS_APPLICATION_ID_GPD( pCmd->options ) )
    447              {
    448                zcl_memcpy( pBuf, &pCmd->gpdId, sizeof ( uint32 ) );
    449                pGpdId = ( uint8* )&pCmd->gpdId;
    450                appId = GP_OPT_APP_ID_GPD;
    451                pBuf += sizeof ( uint32 );
    452              }
    453              // If Application Id bitfield is 0b010
    454              else if( GP_IS_APPLICATION_ID_IEEE( pCmd->options ) )
    455              {
    456                zcl_memcpy( pBuf, &pCmd->gpdIEEE, Z_EXTADDR_LEN );
    457                pGpdId = pCmd->gpdIEEE;
    458                appId = GP_OPT_APP_ID_IEEE;
    459                pBuf += Z_EXTADDR_LEN;
    460                *pBuf++ = pCmd->ep;
    461              }
    462              
    463              zcl_memcpy( pBuf, &pCmd->gpdSecCounter, sizeof ( uint32 ) );
    464              pBuf += sizeof ( uint32 );
    465          
    466              *pBuf++ = pCmd->cmdId;
    467              
    468              *pBuf++ = pCmd->payloadLen;
    469              if ( pCmd->payloadLen > 0 )
    470              {
    471                zcl_memcpy( pBuf, &pCmd->cmdPayload, pCmd->payloadLen );
    472                pBuf += pCmd->payloadLen;
    473              }
    474              
    475              zcl_memcpy( pBuf, &pCmd->gppShortAddr, sizeof ( uint16 ) );
    476              pBuf += sizeof ( uint16 );
    477              
    478              *pBuf++ = pCmd->gppGpdLink;
    479              
    480              pCmdPayloadMsgCurr = gp_AddCmdPayloadMsgNode ( &pCmdPayloadMsgHead, buf, len );
    481              
    482              pCmdPayloadMsgCurr->secNum = secNum;
    483                    
    484              if ( pCmdPayloadMsgCurr != NULL )
    485              {
    486                gp_addPairedSinksToMsgQueue( appId, pGpdId, pCmdPayloadMsgCurr );
    487                osal_start_timerEx( zcl_TaskID, ZCL_DATABUF_SEND, 50 );
    488              }
    489          
    490            }
    491            else
    492              status = ZMemError;
    493          
    494            return ( status );
    495          }
    496            
    497          /*********************************************************************
    498           * @fn      zclGp_SendGpCommissioningNotificationCommand
    499           *
    500           * @brief   Send the Green Power Commissioning Notification Command to a device
    501           *
    502           * @param   pCmd - Pointer to GP Commissioning Notification Struct
    503           *
    504           * @return  ZStatus_t
    505           */
    506          ZStatus_t zclGp_SendGpCommissioningNotificationCommand( gpCommissioningNotificationCmd_t *pCmd )
    507          {
    508            uint8 *buf = NULL;
    509            uint8 *pBuf = NULL;
    510            ZStatus_t status;
    511            uint16 len = 11;  // options + GPD Sec Counter + Cmd ID + payloadLen + GPP Short Address + GPP-GPD link
    512            
    513            // Check some stuff to calculate the packet len
    514            // If Application Id bitfield is 0b000
    515            if( GP_IS_APPLICATION_ID_GPD( pCmd->options ) )
    516            {
    517              len += 4;  // GPD ID
    518            }
    519            // If Application Id bitfield is 0b010
    520            else if( GP_IS_APPLICATION_ID_IEEE( pCmd->options ) )
    521            {
    522              len += 9;  // IEEE addr + EP
    523            }
    524            
    525            // Length of the command payload
    526            len += pCmd->payloadLen;
    527          
    528            buf = zcl_mem_alloc( len );
    529            if ( buf )
    530            {
    531              pBuf = buf;
    532              
    533              zcl_memcpy( pBuf, &pCmd->options, sizeof ( uint16 ) );
    534              pBuf += sizeof ( uint16 );
    535              
    536              // If Application Id bitfield is 0b000
    537              if( GP_IS_APPLICATION_ID_GPD( pCmd->options ) )
    538              {
    539                zcl_memcpy( pBuf, &pCmd->gpdId, sizeof ( uint32 ) );
    540                pBuf += sizeof ( uint32 );
    541              }
    542              // If Application Id bitfield is 0b010
    543              else if( GP_IS_APPLICATION_ID_IEEE( pCmd->options ) )
    544              {
    545                zcl_memcpy( pBuf, &pCmd->gpdIEEE, Z_EXTADDR_LEN );
    546                pBuf += Z_EXTADDR_LEN;
    547                *pBuf++ = pCmd->ep;
    548              }
    549              
    550              zcl_memcpy( pBuf, &pCmd->gpdSecCounter, sizeof ( uint32 ) );
    551              pBuf += sizeof ( uint32 );
    552          
    553              *pBuf++ = pCmd->cmdId;
    554              
    555              *pBuf++ = pCmd->payloadLen;
    556              if ( pCmd->payloadLen > 0 )
    557              {
    558                zcl_memcpy( pBuf, &pCmd->cmdPayload, pCmd->payloadLen );
    559                pBuf += pCmd->payloadLen;
    560              }
    561              
    562              zcl_memcpy( pBuf, &pCmd->gppShortAddr, sizeof ( uint16 ) );
    563              pBuf += sizeof ( uint16 );
    564              
    565              *pBuf++ = pCmd->gppGpdLink;
    566              
    567              afAddrType_t addr;
    568              addr.endPoint = GREEN_POWER_INTERNAL_ENDPOINT;
    569              addr.panId = _NIB.nwkPanId;
    570              addr.addr.shortAddr = gp_commissionerAddress; 
    571                  
    572              if ( gp_commissionerAddress == 0xFFFF )
    573              {
    574                addr.addrMode = afAddrBroadcast;
    575              }
    576              else
    577              {
    578                addr.addrMode = afAddr16Bit;
    579              }
    580                  
    581              zcl_SendCommand( GREEN_POWER_INTERNAL_ENDPOINT, &addr, ZCL_CLUSTER_ID_GREEN_POWER,
    582                                COMMAND_GP_COMMISSIONING_NOTIFICATION, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    583                                TRUE, 0,  bdb_getZCLFrameCounter(), len, buf ); 
    584                
    585              zcl_mem_free( buf );
    586            }
    587            else
    588              status = ZMemError;
    589          
    590            return ( status );
    591          }
    592          /*********************************************************************
    593           * @fn      zclGp_SendGpProxyTableResponse
    594           *
    595           * @brief   Send the Green Power Proxy Table Response to a device
    596           *
    597           * @param   dstAddr - where to send the request
    598           * @param   groupID - pointer to the group structure
    599           * @param   groupName - pointer to Group Name.  This is a Zigbee
    600           *          string data type, so the first byte is the length of the
    601           *          name (in bytes), then the name.
    602           *
    603           * @return  ZStatus_t
    604           */
    605          ZStatus_t zclGp_SendGpProxyTableResponse( afAddrType_t *dstAddr, zclGpProxyTableResponse_t *rsp, 
    606                                                    uint8 seqNum )
    607          {
    608            uint8 *buf = NULL;
    609            uint8 *pBuf = NULL;
    610            uint8 *pEntry = NULL;
    611            
    612            ZStatus_t status;
    613            uint16 entryLen = 0;
    614            uint16 len;
    615            
    616            if ( rsp->proxyTableEntry != NULL )
    617            {
    618              pEntry = rsp->proxyTableEntry;
    619              zcl_memcpy( &entryLen, pEntry, sizeof ( uint16 ) );
    620              pEntry += sizeof ( uint16 );
    621            }
    622            
    623            len = entryLen + 4;
    624          
    625            buf = zcl_mem_alloc( len );
    626            if ( buf )
    627            {
    628              pBuf = buf;
    629              *pBuf++ = rsp->status;
    630              *pBuf++ = rsp->tableEntriesTotal;
    631              *pBuf++ = rsp->startIndex;
    632              *pBuf++ = rsp->entriesCount;
    633              if ( rsp->proxyTableEntry != NULL )
    634              {
    635                zcl_memcpy( pBuf, pEntry, entryLen );
    636              }
    637          
    638              status = zcl_SendCommand( GREEN_POWER_INTERNAL_ENDPOINT, dstAddr, ZCL_CLUSTER_ID_GREEN_POWER,
    639                                        COMMAND_GP_PROXY_TABLE_RESPONSE, TRUE, ZCL_FRAME_CLIENT_SERVER_DIR,
    640                                        TRUE, 0, seqNum, len, buf );
    641              zcl_mem_free( buf );
    642            }
    643            else
    644              status = ZMemError;
    645          
    646            return ( status );
    647          }
    648          
    649           /*********************************************************************
    650           * @fn          gp_addPairedSinksToMsgQueue
    651           *
    652           * @brief       General function to add Notification Msg to Queue for all 
    653           *              Sinks paired to the given GPD
    654           *
    655           * @param       nvIndex - NV Id of proxy table
    656           *              pEntry  - pointer to PROXY_TBL_ENTRY_LEN array
    657           *
    658           * @return      
    659           */
    660          static uint8 gp_addPairedSinksToMsgQueue( uint8 appId, uint8 *pId, gpCmdPayloadMsg_t* pMsg )
    661          {
    662            uint8 freeSinkEntry[LSINK_ADDR_LEN] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
    663            uint8 status;
    664            uint8 i;
    665            uint8 currEntry[PROXY_TBL_ENTRY_LEN];
    666            afAddrType_t dstAddr = {0};
    667            gpNotificationMsg_t *pNotificationMsgCurr = NULL;
    668          
    669              
    670            for ( i = 0; i <= GPP_MAX_PROXY_TABLE_ENTRIES ; i++ )
    671            {
    672              status = gp_getProxyTableByIndex( ( ZCD_NV_PROXY_TABLE_START + i ), currEntry );
    673          
    674              if ( status == NV_OPER_FAILED )
    675              {
    676                break;
    677              }
    678              
    679              // if the entry is empty
    680              if ( status == NV_INVALID_DATA )
    681              {
    682                if ( i >= GPP_MAX_PROXY_TABLE_ENTRIES )
    683                {
    684                  return status;
    685                }
    686                continue;
    687              }
    688              
    689              if ( PROXY_TBL_COMP_APPLICTION_ID( appId, currEntry[PROXY_TBL_ENTRY_OPT] ) )
    690              {
    691                if ( appId == GP_OPT_APP_ID_GPD )
    692                {
    693                  if ( osal_memcmp( pId, &currEntry[PROXY_TBL_ENTRY_GPD_ID + 4], sizeof ( uint32 ) ) )
    694                  {
    695                    // Entry found
    696                    break;
    697                  }
    698                }
    699                else if ( appId == GP_OPT_APP_ID_IEEE )
    700                {
    701                  if ( osal_memcmp( pId, &currEntry[PROXY_TBL_ENTRY_GPD_ID], Z_EXTADDR_LEN ) )
    702                  {
    703                    // Entry found
    704                    break;
    705                  }
    706                }
    707              }
    708            }
    709            
    710            dstAddr.endPoint = GREEN_POWER_INTERNAL_ENDPOINT;
    711            dstAddr.panId = _NIB.nwkPanId;
    712            
    713            if ( PROXY_TBL_GET_LIGHTWIGHT_UNICAST( currEntry[PROXY_TBL_ENTRY_OPT] ) )
    714            {
    715              dstAddr.addrMode = afAddr16Bit;
    716              if ( !osal_memcmp( freeSinkEntry, &currEntry[PROXY_TBL_ENTRY_1ST_LSINK_ADDR], LSINK_ADDR_LEN ) )
    717              {
    718                osal_memcpy( &dstAddr.addr.shortAddr, &currEntry[PROXY_TBL_ENTRY_1ST_LSINK_ADDR + Z_EXTADDR_LEN], sizeof ( uint16 ) );
    719                
    720                pNotificationMsgCurr = gp_AddNotificationMsgNode( &pNotificationMsgHead, pMsg );
    721                if ( pNotificationMsgCurr != NULL )
    722                {
    723                  pNotificationMsgCurr->addr = dstAddr;
    724                }
    725              }
    726              if ( !osal_memcmp( freeSinkEntry, &currEntry[PROXY_TBL_ENTRY_2ND_LSINK_ADDR], LSINK_ADDR_LEN ) )
    727              {
    728                osal_memcpy( &dstAddr.addr.shortAddr, &currEntry[PROXY_TBL_ENTRY_2ND_LSINK_ADDR + Z_EXTADDR_LEN], sizeof ( uint16 ) );   
    729                
    730                pNotificationMsgCurr = gp_AddNotificationMsgNode( &pNotificationMsgHead, pMsg );
    731                if ( pNotificationMsgCurr != NULL )
    732                {
    733                  pNotificationMsgCurr->addr = dstAddr;
    734                }
    735              }
    736            }
    737               
    738            if ( PROXY_TBL_GET_DGROUP( currEntry[PROXY_TBL_ENTRY_OPT] ) || PROXY_TBL_GET_CGROUP( currEntry[PROXY_TBL_ENTRY_OPT + 1] ) )
    739            {
    740              dstAddr.addrMode = afAddrGroup;
    741              if ( GET_BIT( &currEntry[PROXY_TBL_ENTRY_GRP_TBL_ENTRIES], PROXY_TBL_ENTRY_1ST_GRP_BIT ) )
    742              {
    743                osal_memcpy( &dstAddr.addr.shortAddr, &currEntry[PROXY_TBL_ENTRY_1ST_GRP_ADDR], sizeof ( uint16 ) );   
    744                
    745                pNotificationMsgCurr = gp_AddNotificationMsgNode( &pNotificationMsgHead, pMsg );
    746                if ( pNotificationMsgCurr != NULL )
    747                {
    748                  pNotificationMsgCurr->addr = dstAddr;
    749                }
    750              }
    751              if ( GET_BIT( &currEntry[PROXY_TBL_ENTRY_GRP_TBL_ENTRIES], PROXY_TBL_ENTRY_2ND_GRP_BIT ) )
    752              {
    753                osal_memcpy( &dstAddr.addr.shortAddr, &currEntry[PROXY_TBL_ENTRY_2ND_GRP_ADDR], sizeof ( uint16 ) );   
    754                
    755                pNotificationMsgCurr = gp_AddNotificationMsgNode( &pNotificationMsgHead, pMsg );
    756                if ( pNotificationMsgCurr != NULL )
    757                {
    758                  pNotificationMsgCurr->addr = dstAddr;
    759                }
    760              }
    761            }
    762          
    763            return status;
    764          }
    765          
    766          /*********************************************************************
    767           * @fn      gp_CreateNotificationMsgList
    768           *
    769           * @brief   Create Notification Msg List for paired sinks if empty
    770           *
    771           * @param   pHead - pointer to a pointer of the list head
    772           *
    773           * @return  none
    774           */
    775          void gp_CreateNotificationMsgList( gpNotificationMsg_t **pHead )
    776          {
    777          
    778            // Create the list if empty
    779            if ( *pHead == NULL )
    780            {
    781              *pHead = ( gpNotificationMsg_t* )osal_mem_alloc( sizeof( gpNotificationMsg_t ) );
    782              
    783              if ( *pHead != NULL )
    784              {
    785                (*pHead)->pNext = NULL;
    786              }
    787            }
    788            return;
    789          }
    790          
    791          /*********************************************************************
    792           * @fn      gp_CreateCmdPayloadMsgList
    793           *
    794           * @brief   Create Notification Msg List for paired sinks if empty
    795           *
    796           * @param   pHead - pointer to a pointer of the list head
    797           *
    798           * @return  none
    799           */
    800          void gp_CreateCmdPayloadMsgList( gpCmdPayloadMsg_t **pHead )
    801          {
    802          
    803            // Create the list if empty
    804            if ( *pHead == NULL )
    805            {
    806              *pHead = ( gpCmdPayloadMsg_t* )osal_mem_alloc( sizeof( gpCmdPayloadMsg_t ) );
    807              ( ( gpCmdPayloadMsg_t* )*pHead )->pMsg = NULL;
    808              
    809              if ( *pHead != NULL )
    810              {
    811                (*pHead)->pNext = NULL;
    812              }
    813            }
    814            return;
    815          }
    816          
    817          /*********************************************************************
    818           * @fn      gp_AddNotificationMsgNode
    819           *
    820           * @brief   Add node to Notification Msg list
    821           *
    822           * @param   pHead - pointer to a pointer of the list head
    823           *
    824           * @return  pointer to new node
    825           */
    826          gpNotificationMsg_t* gp_AddNotificationMsgNode( gpNotificationMsg_t **pHead, gpCmdPayloadMsg_t *pMsg )
    827          {
    828            gpNotificationMsg_t **pCurr;
    829            
    830              // Create respondent list if empty
    831            if ( *pHead == NULL )
    832            {
    833              gp_CreateNotificationMsgList( pHead );
    834              ( ( gpNotificationMsg_t* ) *pHead )->pMsg = ( uint8* )pMsg;
    835              return *pHead;
    836            }
    837            
    838            pCurr = &((*pHead)->pNext);
    839            
    840            while ( *pCurr != NULL )
    841            {
    842              pCurr = &((*pCurr)->pNext);
    843            }
    844          
    845            *pCurr = ( gpNotificationMsg_t* )osal_mem_alloc( sizeof( gpNotificationMsg_t ) );
    846              
    847            if ( (*pCurr)->pNext != NULL )
    848            {
    849              (*pCurr)->pNext = NULL;
    850            }
    851            ( ( gpNotificationMsg_t* ) *pCurr )->pMsg = ( uint8* )pMsg;
    852            return *pCurr;
    853          }
    854          
    855          /*********************************************************************
    856           * @fn      gp_AddCmdPayloadMsgNode
    857           *
    858           * @brief   Add node to Notification Msg list
    859           *
    860           * @param   pHead - pointer to a pointer of the list head
    861           *
    862           * @return  pointer to new node
    863           */
    864          gpCmdPayloadMsg_t* gp_AddCmdPayloadMsgNode( gpCmdPayloadMsg_t **pHead, uint8* pBuf, uint8 len )
    865          {
    866            gpCmdPayloadMsg_t **pCurr;
    867            
    868              // Create respondent list if empty
    869            if ( *pHead == NULL )
    870            {
    871              gp_CreateCmdPayloadMsgList( pHead );
    872              
    873              if ( pHead != NULL )
    874              {
    875                ( ( ( gpCmdPayloadMsg_t* ) *pHead )->lenght ) = len;
    876                ( ( ( gpCmdPayloadMsg_t* ) *pHead )->pMsg ) = ( uint8* )pBuf;
    877              }
    878              return *pHead;
    879            }
    880            
    881            pCurr = &((*pHead)->pNext);
    882            
    883            while ( *pCurr != NULL )
    884            {
    885              pCurr = &((*pCurr)->pNext);
    886            }
    887          
    888            *pCurr = ( gpCmdPayloadMsg_t* )osal_mem_alloc( sizeof( gpCmdPayloadMsg_t ) );
    889              
    890            if ( (*pCurr)->pNext != NULL )
    891            {
    892              (*pCurr)->pNext = NULL;
    893            }
    894            ( ( ( gpCmdPayloadMsg_t* ) *pCurr )->lenght ) = len;
    895            ( ( ( gpCmdPayloadMsg_t* ) *pCurr )->pMsg ) = ( uint8* )pBuf;
    896            
    897            return *pCurr;
    898          }
    899          
    900          /*********************************************************************
    901           * @fn      gp_GetHeadNotificationMsg
    902           *
    903           * @brief   Returns head pointer for  finding and binding respondent list
    904           *
    905           * @param   none
    906           *
    907           * @return  pointer to head
    908           */
    909          gpNotificationMsg_t* gp_GetHeadNotificationMsg(void)
    910          {
    911            return ( pNotificationMsgHead );
    912          }
    913          
    914          /*********************************************************************
    915           * @fn      gp_GetPHeadNotification
    916           *
    917           * @brief   Returns head pointer for  finding and binding respondent list
    918           *
    919           * @param   none
    920           *
    921           * @return  pointer to head
    922           */
    923          gpNotificationMsg_t** gp_GetPHeadNotification(void)
    924          {
    925            return ( &pNotificationMsgHead );
    926          }
    927          
    928          /*********************************************************************
    929           * @fn      gp_GetHeadCmdPayloadMsg
    930           *
    931           * @brief   Returns head pointer for  finding and binding respondent list
    932           *
    933           * @param   none
    934           *
    935           * @return  pointer to head
    936           */
    937          gpCmdPayloadMsg_t* gp_GetHeadCmdPayloadMsg(void)
    938          {
    939            return ( pCmdPayloadMsgHead );
    940          }
    941          
    942          /*********************************************************************
    943           * @fn      gp_GetHeadCmdPayloadMsg
    944           *
    945           * @brief   Returns head pointer for  finding and binding respondent list
    946           *
    947           * @param   none
    948           *
    949           * @return  pointer to head
    950           */
    951          gpCmdPayloadMsg_t** gp_GetPHeadCmdPayload(void)
    952          {
    953            return ( &pCmdPayloadMsgHead );
    954          }
    955          
    956          /*********************************************************************
    957           * @fn      gp_NotificationMsgClean
    958           *
    959           * @brief   This function free reserved memory for respondent list
    960           *
    961           * @param   pHead - begin of the Notification Msg list
    962           *
    963           * @return  status
    964           */
    965          void gp_NotificationMsgClean( gpNotificationMsg_t **pHead )
    966          {
    967            gpNotificationMsg_t **pCurr;
    968            gpNotificationMsg_t **pNext;
    969            
    970            if ( *pHead == NULL )
    971            {
    972              return;
    973            }
    974            
    975            pCurr = pHead;
    976            
    977            if( *pCurr != NULL )
    978            {
    979              pNext = &((*pCurr)->pNext);
    980              while( *pNext != NULL )
    981              {
    982                if ( ( ( gpNotificationMsg_t* ) *pCurr )->pMsg == ( ( gpNotificationMsg_t* ) *pNext )->pMsg )
    983                {
    984                  break;
    985                }
    986                pNext = &((*pNext)->pNext);
    987              }
    988          
    989              if( *pNext == NULL )
    990              {
    991                gp_CmdPayloadMsgClean( gp_GetPHeadCmdPayload( ) );
    992              }
    993              osal_mem_free( *pCurr );
    994              *pCurr = ( gpNotificationMsg_t* )NULL;
    995              pCurr = pNext;
    996            }
    997            *pHead = *pCurr;
    998          }
    999          
   1000          /*********************************************************************
   1001           * @fn      gp_NotificationMsgClean
   1002           *
   1003           * @brief   This function free reserved memory for respondent list
   1004           *
   1005           * @param   pHead - begin of the Notification Msg list
   1006           *
   1007           * @return
   1008           */
   1009          void gp_CmdPayloadMsgClean( gpCmdPayloadMsg_t **pHead )
   1010          {
   1011            gpCmdPayloadMsg_t **pCurr;
   1012            gpCmdPayloadMsg_t **pNext;
   1013            
   1014            if ( *pHead == NULL )
   1015            {
   1016              return;
   1017            }
   1018            
   1019            pCurr = pHead;
   1020            
   1021            if( *pCurr != NULL )
   1022            {
   1023              pNext = &((*pCurr)->pNext);
   1024              osal_mem_free ( ( ( gpCmdPayloadMsg_t* ) *pCurr )->pMsg );
   1025              ( ( gpCmdPayloadMsg_t* ) *pCurr )->pMsg = NULL;
   1026              osal_mem_free( *pCurr );
   1027              *pCurr = ( gpCmdPayloadMsg_t* )NULL;
   1028              pCurr = pNext;
   1029            }
   1030            pHead = pCurr;
   1031          }
   1032          
   1033          /*********************************************************************
   1034           * @fn      gp_ResetProxyBasicTblEntry
   1035           *
   1036           * @brief   This function removes data of the given entry
   1037           *
   1038           * @param   pHead - begin of the Notification Msg list
   1039           *
   1040           * @return
   1041           */
   1042          void gp_ResetProxyBasicTblEntry( uint8* entry )
   1043          {
   1044            osal_memset(entry, 0xFF, PROXY_TBL_ENTRY_1ST_LSINK_ADDR);
   1045            osal_memset(&entry[PROXY_TBL_ENTRY_1ST_LSINK_ADDR],0x00,PROXY_TBL_ENTRY_LEN - PROXY_TBL_ENTRY_1ST_LSINK_ADDR);
   1046            entry[PROXY_TBL_ENTRY_GPD_EP] = 0;
   1047          }
   1048          
   1049          #endif
   1050          /***************************************************************************
   1051          ****************************************************************************/


 

 


Errors: none
Warnings: none
