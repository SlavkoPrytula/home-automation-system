///////////////////////////////////////////////////////////////////////////////
//
// IAR C/C++ Compiler V10.30.1.6000 for 8051              19/Apr/2021  17:59:52
// Copyright 2004-2018 IAR Systems AB.
// Evaluation license - IAR Embedded Workbench for 8051, Evaluation edition 10.30
//
//    Core               =  plain
//    Code model         =  banked
//    Data model         =  large
//    Calling convention =  xdata reentrant
//    Constant location  =  data_rom
//    Dptr setup         =  1,16
//                          
//    Source file        =  
//        C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
//        3.0.2\Z-Stack 3.0.2\Components\stack\bdb\bdb_touchlink.c
//    Command line       =  
//        -f C:\users\slavko\Temp\EW6584.tmp ("C:\Texas Instruments\Z-Stack
//        3.0.2-20210417T211827Z-001\Z-Stack 3.0.2\Z-Stack
//        3.0.2\Components\stack\bdb\bdb_touchlink.c" -D BDB_REPORTING -D
//        SECURE=1 -D TC_LINKKEY_JOIN -D NV_INIT -D NV_RESTORE -D xZTOOL_P1 -D
//        xMT_TASK -D xMT_APP_FUNC -D xMT_SYS_FUNC -D xMT_ZDO_FUNC -D
//        xMT_ZDO_MGMT -D xMT_APP_CNF_FUNC -D LCD_SUPPORTED=DEBUG -D
//        MULTICAST_ENABLED=FALSE -D ZCL_READ -D ZCL_DISCOVER -D ZCL_WRITE -D
//        ZCL_BASIC -D ZCL_IDENTIFY -D ZCL_ON_OFF -D ZCL_SCENES -D ZCL_GROUPS
//        -D ZCL_LEVEL_CTRL -lC "C:\Texas Instruments\Z-Stack
//        3.0.2-20210417T211827Z-001\Z-Stack 3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\CoordinatorEB\List"
//        -lA "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
//        3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\CoordinatorEB\List"
//        --diag_suppress Pe001,Pa010 -o "C:\Texas Instruments\Z-Stack
//        3.0.2-20210417T211827Z-001\Z-Stack 3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\CoordinatorEB\Obj"
//        -e --debug --core=plain --dptr=16,1 --data_model=large
//        --code_model=banked --calling_convention=xdata_reentrant
//        --place_constants=data_rom --nr_virtual_regs 16 -f "C:\Texas
//        Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack 3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\Tools\CC2530DB\f8wCoord.cfg"
//        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRUE
//        -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8 -DMAC_CFG_RX_MAX=5
//        -DZDO_COORDINATOR -DRTR_NWK) -f "C:\Texas Instruments\Z-Stack
//        3.0.2-20210417T211827Z-001\Z-Stack 3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg"
//        (-DZIGBEEPRO -DSECURE=1 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
//        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
//        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
//        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
//        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
//        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
//        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
//        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
//        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
//        -DMAX_BINDING_CLUSTER_IDS=4 -DDEFAULT_KEY={0}
//        -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
//        "-DCONST=const __code" -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE
//        -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100
//        -DREJOIN_POLL_RATE=440 -DREJOIN_BACKOFF=900000 -DREJOIN_SCAN=900000
//        -DENABLE_LED4_DISABLE_S1) -f "C:\Texas Instruments\Z-Stack
//        3.0.2-20210417T211827Z-001\Z-Stack 3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\Tools\CC2530DB\f8wZCL.cfg"
//        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
//        3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\" -I
//        "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
//        3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\Source\"
//        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
//        3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\Source\"
//        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
//        3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\ZMain\TI2530DB\"
//        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
//        3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\hal\include\"
//        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
//        3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\"
//        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
//        3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\mac\include\"
//        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
//        3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\mac\high_level\"
//        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
//        3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\"
//        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
//        3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\single_chip\"
//        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
//        3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\mt\"
//        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
//        3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\osal\include\"
//        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
//        3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\services\saddr\"
//        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
//        3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\services\sdata\"
//        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
//        3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\af\"
//        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
//        3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\bdb\"
//        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
//        3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\gp\"
//        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
//        3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\nwk\"
//        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
//        3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\sapi\"
//        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
//        3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\sec\"
//        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
//        3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\sys\"
//        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
//        3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\zcl\"
//        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
//        3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\stack\zdo\"
//        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
//        3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\zmac\"
//        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
//        3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\..\..\..\..\..\Components\zmac\f8w\"
//        -Ohz --require_prototypes)
//    Locale             =  English_USA.1252
//    List file          =  
//        C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
//        3.0.2\Z-Stack
//        3.0.2\Projects\zstack\HomeAutomation\SampleLight\CC2530DB\CoordinatorEB\List\bdb_touchlink.s51
//
///////////////////////////////////////////////////////////////////////////////

        NAME bdb_touchlink

        RTMODEL "__SystemLibrary", "CLib"
        RTMODEL "__calling_convention", "xdata_reentrant"
        RTMODEL "__code_model", "banked"
        RTMODEL "__core", "plain"
        RTMODEL "__data_model", "large"
        RTMODEL "__dptr_size", "16"
        RTMODEL "__extended_stack", "disabled"
        RTMODEL "__location_for_constants", "data"
        RTMODEL "__number_of_dptrs", "1"
        RTMODEL "__register_banks", "*"
        RTMODEL "__rt_version", "1"

        RSEG DOVERLAY:DATA:NOROOT(0)
        RSEG IOVERLAY:IDATA:NOROOT(0)
        RSEG ISTACK:IDATA:NOROOT(0)
        RSEG PSTACK:XDATA:NOROOT(0)
        RSEG XSTACK:XDATA:NOROOT(0)


        END
// C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack 3.0.2\Z-Stack 3.0.2\Components\stack\bdb\bdb_touchlink.c
//    1 /**************************************************************************************************
//    2   Filename:       bdb_touchlink.c
//    3   Revised:        $Date: 2013-12-06 15:53:38 -0800 (Fri, 06 Dec 2013) $
//    4   Revision:       $Revision: 36460 $
//    5 
//    6   Description:    Zigbee Cluster Library - Light Link Profile.
//    7 
//    8 
//    9   Copyright 2011-2013 Texas Instruments Incorporated. All rights reserved.
//   10 
//   11   IMPORTANT: Your use of this Software is limited to those specific rights
//   12   granted under the terms of a software license agreement between the user
//   13   who downloaded the software, his/her employer (which must be your employer)
//   14   and Texas Instruments Incorporated (the "License").  You may not use this
//   15   Software unless you agree to abide by the terms of the License. The License
//   16   limits your use, and you acknowledge, that the Software may not be modified,
//   17   copied or distributed unless embedded on a Texas Instruments microcontroller
//   18   or used solely and exclusively in conjunction with a Texas Instruments radio
//   19   frequency transceiver, which is integrated into your product.  Other than for
//   20   the foregoing purpose, you may not use, reproduce, copy, prepare derivative
//   21   works of, modify, distribute, perform, display or sell this Software and/or
//   22   its documentation for any purpose.
//   23 
//   24   YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
//   25   PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
//   26   INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
//   27   NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
//   28   TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
//   29   NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
//   30   LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
//   31   INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
//   32   OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
//   33   OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
//   34   (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
//   35 
//   36   Should you have any questions regarding your right to use this Software,
//   37   contact Texas Instruments Incorporated at www.TI.com.
//   38 **************************************************************************************************/
//   39 
//   40 /*********************************************************************
//   41  * INCLUDES
//   42  */
//   43 #include "OSAL_Nv.h"
//   44 #include "hal_aes.h"
//   45 #include "ssp_hash.h"
//   46 #include "nwk_util.h"
//   47 #include "ZDSecMgr.h"
//   48 #include "ZDObject.h"
//   49 
//   50 #if defined( INTER_PAN )
//   51   #include "stub_aps.h"
//   52 #if defined ( BDB_TL_INITIATOR )
//   53   #include "bdb_touchlink_initiator.h"
//   54 #endif // BDB_TL_INITIATOR
//   55 #if defined ( BDB_TL_TARGET )
//   56   #include "bdb_touchlink_target.h"
//   57 #endif // BDB_TL_TARGET
//   58 #endif
//   59 
//   60 #include "bdb.h"
//   61 #include "bdb_interface.h"
//   62 #include "bdb_tlCommissioning.h"
//   63 #include "bdb_touchlink.h"
//   64 
//   65 #if defined ( BDB_TL_TARGET ) || defined ( BDB_TL_INITIATOR )
//   66 
//   67 /*********************************************************************
//   68  * MACROS
//   69  */
//   70 #define TOUCHLINK_NEW_MIN( min, max )                  ( ( (uint32)(max) + (uint32)(min) + 1 ) / 2 )
//   71 
//   72 /*********************************************************************
//   73  * CONSTANTS
//   74  */
//   75 
//   76 #define TOUCHLINK_NUM_DEVICE_INFO_ENTRIES              5
//   77 
//   78 
//   79 /*********************************************************************
//   80  * TYPEDEFS
//   81  */
//   82 
//   83 /*********************************************************************
//   84  * GLOBAL VARIABLES
//   85  */
//   86 
//   87 uint32 touchLinkLastAcceptedTransID;
//   88    
//   89 // Used for Network Discovery
//   90 touchLinkDiscoveredNwkParam_t *pDiscoveredNwkParamList = NULL;
//   91 
//   92 // Current Touch Link Transaction ID
//   93 uint32 touchLinkTransID;
//   94 
//   95 // Scan Response ID
//   96 uint32 touchLinkResponseID;
//   97 
//   98 // Our group ID range
//   99 uint16 touchLinkGrpIDsBegin;
//  100 uint16 touchLinkGrpIDsEnd;
//  101 
//  102 // Flag for leave
//  103 uint8 touchLinkLeaveInitiated;
//  104 
//  105 // Device Information Table
//  106 bdbTLDeviceInfo_t *touchLinkSubDevicesTbl[5];
//  107 
//  108 // Touchlink distributed network flag
//  109 bool touchlinkDistNwk = FALSE;
//  110 
//  111 bool touchlinkFNReset;
//  112 
//  113 /*********************************************************************
//  114  * EXTERNAL VARIABLES
//  115  */
//  116 
//  117 /*********************************************************************
//  118  * EXTERNAL FUNCTIONS
//  119  */
//  120 
//  121 /*********************************************************************
//  122  * LOCAL VARIABLES
//  123  */
//  124 // TOUCHLINK Profile attributes - Our free network address and group ID ranges
//  125 static uint16 touchLinkFreeNwkAddrBegin;
//  126 static uint16 touchLinkFreeNwkAddrEnd;
//  127 static uint16 touchLinkFreeGrpIdBegin;
//  128 static uint16 touchLinkFreeGrpIdEnd;
//  129 
//  130 static bool touchLinkIsInitiator;
//  131 static uint8 touchLinkTaskId;
//  132 
//  133 // This is the Cluster ID List and should be filled with Application
//  134 // specific cluster IDs.
//  135 #define TOUCHLINK_EP_MAX_INCLUSTERS       1
//  136 static const cId_t touchLink_EP_InClusterList[TOUCHLINK_EP_MAX_INCLUSTERS] =
//  137 {
//  138   ZCL_CLUSTER_ID_TOUCHLINK
//  139 };
//  140 
//  141 #define TOUCHLINK_EP_MAX_OUTCLUSTERS       1
//  142 static const cId_t touchLink_EP_OutClusterList[TOUCHLINK_EP_MAX_OUTCLUSTERS] =
//  143 {
//  144   ZCL_CLUSTER_ID_TOUCHLINK
//  145 };
//  146 
//  147 static SimpleDescriptionFormat_t touchLink_EP_SimpleDesc =
//  148 {
//  149   TOUCHLINK_INTERNAL_ENDPOINT,         //  int Endpoint;
//  150   TOUCHLINK_PROFILE_ID,                //  uint16 AppProfId[2];
//  151   TOUCHLINK_INTERNAL_DEVICE_ID,        //  uint16 AppDeviceId[2];
//  152   TOUCHLINK_DEVICE_VERSION,            //  int   AppDevVer:4;
//  153   TOUCHLINK_INTERNAL_FLAGS,            //  int   AppFlags:4;
//  154   TOUCHLINK_EP_MAX_INCLUSTERS,         //  byte  AppNumInClusters;
//  155   (cId_t *)touchLink_EP_InClusterList, //  byte *pAppInClusterList;
//  156   TOUCHLINK_EP_MAX_OUTCLUSTERS,        //  byte  AppNumInClusters;
//  157   (cId_t *)touchLink_EP_OutClusterList //  byte *pAppInClusterList;
//  158 };
//  159 
//  160 #if defined( INTER_PAN )
//  161 // Define endpoint structure to register with STUB APS for INTER-PAN support
//  162 static endPointDesc_t touchLink_EP =
//  163 {
//  164   TOUCHLINK_INTERNAL_ENDPOINT,
//  165   0,
//  166   &touchLinkTaskId,
//  167   (SimpleDescriptionFormat_t *)NULL,  // No Simple description for this endpoint
//  168   (afNetworkLatencyReq_t)0            // No Network Latency req
//  169 };
//  170 #endif
//  171 
//  172 
//  173 /*********************************************************************
//  174  * LOCAL FUNCTIONS
//  175  */
//  176 static void touchLink_BuildAesKey( uint8 *pAesKey, uint32 transID, uint32 responseID, uint8 keyIndex );
//  177 void touchLink_ItemInit( uint16 id, uint16 len, void *pBuf );
//  178 static void *touchLink_BeaconIndCB ( void *param );
//  179 static void *touchLink_NwkDiscoveryCnfCB ( void *param );
//  180 static void touchLink_InitNV( void );
//  181 
//  182 /*********************************************************************
//  183  * PUBLIC FUNCTIONS
//  184  */
//  185 
//  186 /*********************************************************************
//  187  * @fn      touchLink_InitVariables
//  188  *
//  189  * @brief   Initialize the TOUCHLINK global and local variables.
//  190  *
//  191  * @param   initiator - if caller is Initiator
//  192  *
//  193  * @return  none
//  194  */
//  195 void touchLink_InitVariables( bool initiator )
//  196 {
//  197   touchLinkTransID = 0;
//  198   touchLinkIsInitiator = initiator;
//  199 
//  200   if ( bdbAttributes.bdbNodeIsOnANetwork == FALSE )
//  201   {
//  202     _NIB.nwkDevAddress = INVALID_NODE_ADDR;
//  203   }
//  204 
//  205   // verify groups communication is initiated by broadcasts rather than multicasts
//  206   _NIB.nwkUseMultiCast = FALSE;
//  207   // detect and remove stored deprecated end device children after power up
//  208   zgRouterOffAssocCleanup = TRUE;
//  209   osal_nv_write(ZCD_NV_ROUTER_OFF_ASSOC_CLEANUP, 0, sizeof(zgRouterOffAssocCleanup), &zgRouterOffAssocCleanup);
//  210 
//  211   touchLink_InitFreeRanges( initiator );
//  212 
//  213   touchLink_InitNV();
//  214 
//  215   touchLinkLeaveInitiated = FALSE;
//  216 
//  217   // Initialize device info table
//  218   osal_memset( touchLinkSubDevicesTbl, 0, sizeof( touchLinkSubDevicesTbl ) );
//  219   
//  220   touchLinkIsInitiator = FALSE;
//  221   
//  222   // set broadcast address mask to support broadcast filtering
//  223   NLME_SetBroadcastFilter( ZDO_Config_Node_Descriptor.CapabilityFlags );
//  224 }
//  225 
//  226 /*********************************************************************
//  227  * @fn      touchLink_InitFreeRanges
//  228  *
//  229  * @brief   Initialize the TOUCHLINK free range global variables.
//  230  *
//  231  * @param   initiator - if caller is link initiator
//  232  *
//  233  * @return  none
//  234  */
//  235 void touchLink_InitFreeRanges( bool initiator )
//  236 {
//  237   // Initialize our free network address and group ID ranges
//  238   if ( initiator )
//  239   {
//  240     touchLinkFreeNwkAddrBegin = APL_FREE_NWK_ADDR_RANGE_BEGIN;
//  241     touchLinkFreeNwkAddrEnd = APL_FREE_NWK_ADDR_RANGE_END;
//  242 
//  243     touchLinkFreeGrpIdBegin = APL_FREE_GROUP_ID_RANGE_BEGIN;
//  244     touchLinkFreeGrpIdEnd = APL_FREE_GROUP_ID_RANGE_END;
//  245   }
//  246   else
//  247   {
//  248     touchLinkFreeNwkAddrBegin = touchLinkFreeNwkAddrEnd = 0;
//  249     touchLinkFreeGrpIdBegin = touchLinkFreeGrpIdEnd = 0;
//  250   }
//  251 
//  252   // Initialize our local group ID range
//  253   touchLinkGrpIDsBegin = touchLinkGrpIDsEnd = 0;
//  254 }
//  255 
//  256 /*********************************************************************
//  257  * @fn      touchLink_UpdateFreeRanges
//  258  *
//  259  * @brief   Update the TOUCHLINK free range global variables.
//  260  *
//  261  * @param   pParams - new parameters
//  262  *
//  263  * @return  none
//  264  */
//  265 void touchLink_UpdateFreeRanges( bdbTLNwkParams_t *pParams )
//  266 {
//  267   // Set our free network address and group ID ranges
//  268   touchLinkFreeNwkAddrBegin = pParams->freeNwkAddrBegin;
//  269   touchLinkFreeNwkAddrEnd = pParams->freeNwkAddrEnd;
//  270   touchLinkFreeGrpIdBegin = pParams->freeGrpIDBegin;
//  271   touchLinkFreeGrpIdEnd = pParams->freeGrpIDEnd;
//  272 
//  273   // Set our group ID range
//  274   touchLinkGrpIDsBegin = pParams->grpIDsBegin;
//  275   touchLinkGrpIDsEnd = pParams->grpIDsEnd;
//  276 }
//  277 
//  278 /*********************************************************************
//  279  * @fn      touchLink_GerFreeRanges
//  280  *
//  281  * @brief   Get the TOUCHLINK free range global variables.
//  282  *
//  283  * @param   pParams - parameter to get
//  284  *
//  285  * @return  none
//  286  */
//  287 void touchLink_GerFreeRanges( bdbTLNwkParams_t *pParams )
//  288 {
//  289   // Set our free network address and group ID ranges
//  290   pParams->freeNwkAddrBegin = touchLinkFreeNwkAddrBegin;
//  291   pParams->freeNwkAddrEnd = touchLinkFreeNwkAddrEnd;
//  292   pParams->freeGrpIDBegin = touchLinkFreeGrpIdBegin;
//  293   pParams->freeGrpIDEnd = touchLinkFreeGrpIdEnd;
//  294   
//  295     // Set our group ID range
//  296   pParams->grpIDsBegin = touchLinkGrpIDsBegin;
//  297   pParams->grpIDsEnd = touchLinkGrpIDsEnd;
//  298 }
//  299 
//  300 /*********************************************************************
//  301  * @fn      touchLink_IsValidSplitFreeRanges
//  302  *
//  303  * @brief   Checks to see if the resulting two ranges are not smaller
//  304  *          than the threshold after division of a network address or
//  305  *          group ID range. The Initiator splits its own free range
//  306  *          in half and assigns the top half to the new device.
//  307  *
//  308  *          Note: A range (Nmin...Nmax) is split as follows:
//  309  *
//  310  *                N'min = (Nmax + Nmin + 1)/2
//  311  *                N'max = Nmax
//  312  *                Nmax = N'min - 1
//  313  *
//  314  * @param   totalGrpIDs - total number of group IDs needed
//  315  *
//  316  * @return  TRUE if split possible. FALSE, otherwise.
//  317  */
//  318 bool touchLink_IsValidSplitFreeRanges( uint8 totalGrpIDs )
//  319 {
//  320   if ( ( touchLinkFreeNwkAddrBegin != 0 ) && ( touchLinkFreeGrpIdBegin != 0 ) )
//  321   {
//  322       return ( ( ( ( touchLinkFreeNwkAddrEnd - touchLinkFreeNwkAddrBegin ) / 2 ) >= APL_FREE_ADDR_THRESHOLD ) &&
//  323                ( ( ( touchLinkFreeGrpIdEnd - ( touchLinkFreeGrpIdBegin + totalGrpIDs - 1 ) ) / 2 ) >= APL_FREE_GROUP_ID_THRESHOLD ) );
//  324 
//  325   }
//  326 
//  327   return ( FALSE );
//  328 }
//  329 
//  330 /*********************************************************************
//  331  * @fn      touchLink_SplitFreeRanges
//  332  *
//  333  * @brief   Split our own free network address and group ID ranges
//  334  *          in half and assign the top half to the new device.
//  335  *
//  336  *          Note: A range (Nmin...Nmax) is split as follows:
//  337  *
//  338  *                N'min = (Nmax + Nmin + 1)/2
//  339  *                N'max = Nmax
//  340  *                Nmax = N'min - 1
//  341  *
//  342  * output parameters
//  343  *
//  344  * @param   pAddrBegin - new address range begin
//  345  * @param   pAddrEnd - new address range end
//  346  * @param   pGrpIdBegin - new group id range begin
//  347  * @param   pGrpIdEnd - new group id range end
//  348  *
//  349  * @return  none
//  350  */
//  351 void touchLink_SplitFreeRanges( uint16 *pAddrBegin, uint16 *pAddrEnd,
//  352                         uint16 *pGrpIdBegin, uint16 *pGrpIdEnd )
//  353 {
//  354   if ( ( touchLinkFreeNwkAddrBegin != 0 ) && ( touchLinkFreeGrpIdBegin != 0 ) )
//  355   {
//  356     *pAddrBegin = TOUCHLINK_NEW_MIN( touchLinkFreeNwkAddrBegin, touchLinkFreeNwkAddrEnd );
//  357     *pGrpIdBegin = TOUCHLINK_NEW_MIN( touchLinkFreeGrpIdBegin, touchLinkFreeGrpIdEnd );
//  358 
//  359     *pAddrEnd = touchLinkFreeNwkAddrEnd;
//  360     *pGrpIdEnd = touchLinkFreeGrpIdEnd;
//  361 
//  362     // Update our max
//  363     touchLinkFreeNwkAddrEnd = *pAddrBegin - 1;
//  364     touchLinkFreeGrpIdEnd = *pGrpIdBegin - 1;
//  365   }
//  366   else
//  367   {
//  368     *pAddrBegin = *pAddrEnd = 0;
//  369     *pGrpIdBegin = *pGrpIdEnd = 0;
//  370   }
//  371 }
//  372 
//  373 /*********************************************************************
//  374  * @fn      touchLink_PopGrpIDRange
//  375  *
//  376  * @brief   Pop the requested number of group IDs out of the free group IDs range.
//  377  *
//  378  * input parameters
//  379  *
//  380  * @param   numGrpIDs - number of group IDs needed
//  381  *
//  382  * output parameters
//  383  *
//  384  * @param   pGrpIdBegin - new group id range begin, or 0 if unavaialable
//  385  * @param   pGrpIdEnd - new group id range end, , or 0 if unavaialable
//  386  *
//  387  * @return  none
//  388  */
//  389 void touchLink_PopGrpIDRange( uint8 numGrpIDs, uint16 *pGrpIDsBegin, uint16 *pGrpIDsEnd )
//  390 {
//  391   if ( ( touchLinkFreeGrpIdBegin != 0 )
//  392        && ( touchLinkFreeGrpIdBegin <= touchLinkFreeGrpIdEnd )
//  393        && ( ( touchLinkFreeGrpIdEnd - touchLinkFreeGrpIdBegin ) >= numGrpIDs ) )
//  394   {
//  395     *pGrpIDsBegin = touchLinkFreeGrpIdBegin;
//  396 
//  397     // Update min free group id
//  398     touchLinkFreeGrpIdBegin += numGrpIDs;
//  399 
//  400     *pGrpIDsEnd = touchLinkFreeGrpIdBegin - 1;
//  401   }
//  402   else
//  403   {
//  404     *pGrpIDsBegin = *pGrpIDsEnd = 0;
//  405   }
//  406 }
//  407 
//  408 /*********************************************************************
//  409  * @fn      touchLink_PopNwkAddress
//  410  *
//  411  * @brief   Pop an avaialble short address out of the free network addresses range.
//  412  *
//  413  * @param   none
//  414  *
//  415  * @return  free address if available. 0, otherwise.
//  416  */
//  417 uint16 touchLink_PopNwkAddress( void )
//  418 {
//  419   if ( ( touchLinkFreeNwkAddrBegin == 0 ) || ( touchLinkFreeNwkAddrBegin > touchLinkFreeNwkAddrEnd ) )
//  420   {
//  421     return ( 0 );
//  422   }
//  423 
//  424   return ( touchLinkFreeNwkAddrBegin++ );
//  425 }
//  426 
//  427 /*********************************************************************
//  428  * @fn      touchLink_GetNumSubDevices
//  429  *
//  430  * @brief   Get the total number of sub-devices (endpoints) registered.
//  431  *
//  432  * @param   startIndex - starting index
//  433  *
//  434  * @return  number of sub-devices
//  435  */
//  436 uint8 touchLink_GetNumSubDevices( uint8 startIndex )
//  437 {
//  438   uint8 numEPs = 0;
//  439 
//  440   for ( uint8 i = startIndex; i < TOUCHLINK_NUM_DEVICE_INFO_ENTRIES; i++ )
//  441   {
//  442     if ( touchLinkSubDevicesTbl[i] != NULL )
//  443     numEPs++;
//  444   }
//  445 
//  446   return ( numEPs );
//  447 }
//  448 
//  449 /*********************************************************************
//  450  * @fn      touchLink_GetNumGrpIDs
//  451  *
//  452  * @brief   Get the total number of group IDs required by this device.
//  453  *
//  454  * @param   none
//  455  *
//  456  * @return  number of group IDs
//  457  */
//  458 uint8 touchLink_GetNumGrpIDs( void )
//  459 {
//  460   uint8 numGrpIDs = 0;
//  461 
//  462   for ( uint8 i = 0; i < TOUCHLINK_NUM_DEVICE_INFO_ENTRIES; i++ )
//  463   {
//  464     if ( touchLinkSubDevicesTbl[i] != NULL )
//  465     {
//  466       numGrpIDs += touchLinkSubDevicesTbl[i]->grpIdCnt;
//  467     }
//  468   }
//  469 
//  470   return ( numGrpIDs );
//  471 }
//  472 
//  473 /*********************************************************************
//  474  * @fn      touchLink_GetSubDeviceInfo
//  475  *
//  476  * @brief   Get the sub-device information.
//  477  *
//  478  * input parameter
//  479  *
//  480  * @param   index - index of sub-device
//  481  *
//  482  * output parameter
//  483  *
//  484  * @param   pInfo - sub-device info (to be returned)
//  485  *
//  486  * @return  none
//  487  */
//  488 void touchLink_GetSubDeviceInfo( uint8 index, bdbTLDeviceInfo_t *pInfo )
//  489 {
//  490   if ( pInfo == NULL )
//  491   {
//  492     return;
//  493   }
//  494   if ( ( index < TOUCHLINK_NUM_DEVICE_INFO_ENTRIES ) &&
//  495        ( touchLinkSubDevicesTbl[index] != NULL ) )
//  496   {
//  497     endPointDesc_t *epDesc = afFindEndPointDesc( touchLinkSubDevicesTbl[index]->endpoint );
//  498     if ( epDesc != NULL )
//  499     {
//  500       // Copy sub-device info
//  501       *pInfo = *(touchLinkSubDevicesTbl[index]);
//  502     }
//  503   }
//  504   else
//  505   {
//  506     osal_memset( pInfo, 0, sizeof( bdbTLDeviceInfo_t ) );
//  507   }
//  508 }
//  509 
//  510 
//  511 /*********************************************************************
//  512  * @fn      touchLink_EncryptNwkKey
//  513  *
//  514  * @brief   Encrypt the current network key to be sent to a Target.
//  515  *          In case of Factory New device generate new key.
//  516  *
//  517  * output parameter
//  518  *
//  519  * @param   pNwkKey - pointer to encrypted network key
//  520  *
//  521  * input parameters
//  522  *
//  523  * @param   keyIndex - key index
//  524  * @param   transID - transaction id
//  525  * @param   responseID - response id
//  526  *
//  527  * @return  none
//  528  */
//  529 void touchLink_EncryptNwkKey( uint8 *pNwkKey, uint8 keyIndex, uint32 transID, uint32 responseID )
//  530 {
//  531   uint8 aesKeyKey[SEC_KEY_LEN] = TOUCHLINK_DEFAULT_AES_KEY;
//  532   uint8 masterKey[SEC_KEY_LEN] = TOUCHLINK_ENC_KEY;
//  533   uint8 nwkKey[SEC_KEY_LEN];
//  534 
//  535   if ( bdbAttributes.bdbNodeIsOnANetwork == FALSE )
//  536   {
//  537     touchLink_GenerateRandNum( nwkKey, SEC_KEY_LEN );
//  538   }
//  539   else
//  540   {
//  541     nwkActiveKeyItems keyItems;
//  542     SSP_ReadNwkActiveKey( &keyItems );
//  543     osal_memcpy( nwkKey, keyItems.active.key , SEC_KEY_LEN);
//  544   }
//  545 
//  546   // Build the AES key
//  547   touchLink_BuildAesKey( aesKeyKey, transID, responseID, keyIndex );
//  548 
//  549   if ( ( keyIndex == TOUCHLINK_KEY_INDEX_MASTER ) || ( keyIndex == TOUCHLINK_KEY_INDEX_CERT ) )
//  550   {
//  551     // Encypt with the master key
//  552     sspAesEncrypt( masterKey, aesKeyKey );
//  553   }
//  554   // Encrypt the network key with the AES key
//  555   sspAesEncrypt( aesKeyKey, nwkKey );
//  556 
//  557   // Copy in the encrypted network key
//  558   osal_memcpy( pNwkKey, nwkKey, SEC_KEY_LEN );
//  559 }
//  560 
//  561 /*********************************************************************
//  562  * @fn      touchLink_DecryptNwkKey
//  563  *
//  564  * @brief   Decrypt the received network key and update.
//  565  *
//  566  * @param   pNwkKey - pointer to the encrypted network key
//  567  * @param   keyIndex - key index
//  568  * @param   transID - transaction id
//  569  * @param   responseID - response id
//  570  *
//  571  * @return  none
//  572  */
//  573 void touchLink_DecryptNwkKey( uint8 *pNwkKey, uint8 keyIndex, uint32 transID, uint32 responseID )
//  574 {
//  575   uint8 aesKeyKey[SEC_KEY_LEN] = TOUCHLINK_DEFAULT_AES_KEY;
//  576 
//  577   uint8 nwkKey[SEC_KEY_LEN];
//  578 
//  579   uint8 masterKey[SEC_KEY_LEN] = TOUCHLINK_ENC_KEY;
//  580 
//  581   // Copy in the encrypted network key
//  582   osal_memcpy( nwkKey, pNwkKey, SEC_KEY_LEN );
//  583 
//  584   touchLink_BuildAesKey( aesKeyKey, transID, responseID, keyIndex );
//  585 
//  586   if ( ( keyIndex == TOUCHLINK_KEY_INDEX_MASTER ) || ( keyIndex == TOUCHLINK_KEY_INDEX_CERT ) )
//  587   {
//  588     //encypt with the master key
//  589     sspAesEncrypt( masterKey, aesKeyKey );
//  590   }
//  591   // Decrypt the network key with the AES key
//  592   sspAesDecrypt( aesKeyKey, nwkKey );
//  593 
//  594   touchLink_UpdateNwkKey( nwkKey, keyIndex );
//  595 }
//  596 
//  597 /*********************************************************************
//  598  * @fn      touchLink_BuildAesKey
//  599  *
//  600  * @brief   Build an AES key using Transaction ID and Response ID.
//  601  *
//  602  * @param   pAesKey - pointer to AES to be built
//  603  * @param   transID - transaction id
//  604  * @param   responseID - response id
//  605  *
//  606  * @return  none
//  607  */
//  608 static void touchLink_BuildAesKey( uint8 *pAesKey, uint32 transID, uint32 responseID, uint8 keyIndex )
//  609 {
//  610 
//  611   if ( ( keyIndex == TOUCHLINK_KEY_INDEX_MASTER ) || ( keyIndex == TOUCHLINK_KEY_INDEX_CERT ) )
//  612   {
//  613     // Copy transaction identifier to 1st byte
//  614     pAesKey[0] = BREAK_UINT32( transID, 3 );
//  615     pAesKey[1] = BREAK_UINT32( transID, 2 );
//  616     pAesKey[2] = BREAK_UINT32( transID, 1 );
//  617     pAesKey[3] = BREAK_UINT32( transID, 0 );
//  618 
//  619     // Copy response identifier 3rd bute
//  620     pAesKey[8] = BREAK_UINT32( responseID, 3 );
//  621     pAesKey[9] = BREAK_UINT32( responseID, 2 );
//  622     pAesKey[10] = BREAK_UINT32( responseID, 1 );
//  623     pAesKey[11] = BREAK_UINT32( responseID, 0 );
//  624   }
//  625 
//  626   // Copy in the transaction identifier
//  627   pAesKey[4] = BREAK_UINT32( transID, 3 );
//  628   pAesKey[5] = BREAK_UINT32( transID, 2 );
//  629   pAesKey[6] = BREAK_UINT32( transID, 1 );
//  630   pAesKey[7] = BREAK_UINT32( transID, 0 );
//  631 
//  632   // Copy in the response identifier
//  633   pAesKey[12] = BREAK_UINT32( responseID, 3 );
//  634   pAesKey[13] = BREAK_UINT32( responseID, 2 );
//  635   pAesKey[14] = BREAK_UINT32( responseID, 1 );
//  636   pAesKey[15] = BREAK_UINT32( responseID, 0 );
//  637 }
//  638 
//  639 /*********************************************************************
//  640  * @fn      touchLink_UpdateNwkKey
//  641  *
//  642  * @brief   Update the network key.
//  643  *
//  644  * @param   pNwkParams - pointer to new network key
//  645  * @param   keyIndex - key index
//  646  *
//  647  * @return  none
//  648  */
//  649 void touchLink_UpdateNwkKey( uint8 *pNwkKey, uint8 keyIndex )
//  650 {
//  651   uint32 nwkFrameCounterTmp;
//  652   (void)keyIndex;
//  653 
//  654   // To prevent Framecounter out of sync issues, store the lastkey
//  655   nwkFrameCounterTmp = nwkFrameCounter;  // (Global in SSP).
//  656 
//  657   // Update the network key
//  658   SSP_UpdateNwkKey( pNwkKey, 0 );
//  659 
//  660   SSP_SwitchNwkKey( 0 );
//  661 
//  662   nwkFrameCounter  = nwkFrameCounterTmp; // restore
//  663 
//  664   // Save off the security
//  665   ZDApp_SaveNwkKey();
//  666 }
//  667 
//  668 /*********************************************************************
//  669  * @fn      touchLink_GetNwkKeyBitmask
//  670  *
//  671  * @brief   Get the supported network key bitmask.
//  672  *
//  673  * @param   none
//  674  *
//  675  * @return  network key bitmask
//  676  */
//  677 uint16 touchLink_GetNwkKeyBitmask( void )
//  678 {
//  679   return ( (uint16)1 << TOUCHLINK_KEY_INDEX );
//  680 }
//  681 
//  682 /*********************************************************************
//  683  * @fn      touchLink_GenerateRandNum
//  684  *
//  685  * @brief   Fill buffer with random bytes.
//  686  *
//  687  * input parameter
//  688  *
//  689  * @param   numSize - size of buffer in bytes
//  690  *
//  691  * output parameter
//  692  *
//  693  * @param   pNum - pointer to buffer to be filled with random values
//  694  *
//  695  * @return  none
//  696  */
//  697 void touchLink_GenerateRandNum( uint8 *pNum, uint8 numSize )
//  698 {
//  699   if ( pNum && numSize )
//  700   {
//  701     uint8 lastByte = ( numSize - 1 );
//  702     for ( uint8 i = 0; i < lastByte; i += 2 )
//  703     {
//  704       uint16 rand = osal_rand();
//  705       pNum[i]   = LO_UINT16( rand );
//  706       pNum[i+1] = HI_UINT16( rand );
//  707     }
//  708 
//  709     // In case the number is odd
//  710     if ( numSize % 2 )
//  711     {
//  712       pNum[lastByte] = LO_UINT16( osal_rand() );
//  713     }
//  714   }
//  715 }
//  716 
//  717 /*********************************************************************
//  718  * @fn      touchLink_GetRandPrimaryChannel
//  719  *
//  720  * @brief   Get randomly chosen TOUCHLINK primary channel.
//  721  *
//  722  * @return  channel
//  723  */
//  724 uint8 touchLink_GetRandPrimaryChannel()
//  725 {
//  726   uint8 channel = osal_rand() & 0x1F;
//  727   if ( channel <= TOUCHLINK_FIRST_CHANNEL )
//  728   {
//  729     channel = TOUCHLINK_FIRST_CHANNEL;
//  730   }
//  731   else if ( channel <= TOUCHLINK_SECOND_CHANNEL )
//  732   {
//  733     channel = TOUCHLINK_SECOND_CHANNEL;
//  734   }
//  735   else if ( channel <= TOUCHLINK_THIRD_CHANNEL )
//  736   {
//  737     channel = TOUCHLINK_THIRD_CHANNEL;
//  738   }
//  739   else
//  740   {
//  741     channel = TOUCHLINK_FOURTH_CHANNEL;
//  742   }
//  743 #ifdef TOUCHLINK_DEV_SELECT_FIRST_CHANNEL
//  744 #warning The device will always select the first primary channel
//  745   channel = TOUCHLINK_FIRST_CHANNEL;
//  746 #endif
//  747   return channel;
//  748 }
//  749 
//  750 /*********************************************************************
//  751  * @fn      touchLink_SetNIB
//  752  *
//  753  * @brief   Copy new Network Parameters to the NIB.
//  754  *
//  755  * @param   nwkState - network state
//  756  * @param   nwkAddr - short address
//  757  * @param   pExtendedPANID - pointer to extended PAN ID
//  758  * @param   logicalChannel - channel
//  759  * @param   panId - PAN identifier
//  760  * @param   nwkUpdateId - nwtwork update identifier
//  761  *
//  762  * @return      void
//  763  */
//  764 void touchLink_SetNIB( nwk_states_t nwkState, uint16 nwkAddr, uint8 *pExtendedPANID,
//  765                  uint8 logicalChannel, uint16 panId, uint8 nwkUpdateId )
//  766 {
//  767   // Copy the new network parameters to NIB
//  768   _NIB.nwkState = nwkState;
//  769   _NIB.nwkDevAddress = nwkAddr;
//  770   _NIB.nwkLogicalChannel = logicalChannel;
//  771   _NIB.nwkCoordAddress = INVALID_NODE_ADDR;
//  772   _NIB.channelList = (uint32)1 << logicalChannel;
//  773   _NIB.nwkPanId = panId;
//  774   _NIB.nodeDepth = 1;
//  775   _NIB.MaxRouters = (uint8)gNWK_MAX_DEVICE_LIST;
//  776   _NIB.MaxChildren = (uint8)gNWK_MAX_DEVICE_LIST;
//  777   _NIB.allocatedRouterAddresses = 1;
//  778   _NIB.allocatedEndDeviceAddresses = 1;
//  779 
//  780   if ( _NIB.nwkUpdateId != nwkUpdateId )
//  781   {
//  782     NLME_SetUpdateID( nwkUpdateId );
//  783   }
//  784 
//  785   osal_cpyExtAddr( _NIB.extendedPANID, pExtendedPANID );
//  786 
//  787   // Save the NIB
//  788   if ( ( nwkState == NWK_ROUTER ) || ( nwkState == NWK_ENDDEVICE ) )
//  789   {
//  790     touchLink_UpdateNV( TOUCHLINK_UPDATE_NV_NIB );
//  791   }
//  792   // else will be updated when ED joins its parent
//  793 }
//  794 
//  795 /*********************************************************************
//  796  * @fn      touchLink_ProcessNwkUpdate
//  797  *
//  798  * @brief   Update our local network update id and logical channel.
//  799  *
//  800  * @param   nwkUpdateId - new network update id
//  801  * @param   logicalChannel - new logical channel
//  802  *
//  803  * @return  void
//  804  */
//  805 void touchLink_ProcessNwkUpdate( uint8 nwkUpdateId, uint8 logicalChannel )
//  806 {
//  807   // Update the network update id
//  808   NLME_SetUpdateID( nwkUpdateId );
//  809 
//  810   // Switch channel
//  811   if ( _NIB.nwkLogicalChannel != logicalChannel )
//  812   {
//  813     _NIB.nwkLogicalChannel = logicalChannel;
//  814     touchLink_SetChannel( logicalChannel );
//  815   }
//  816 
//  817   // Update channel list
//  818   _NIB.channelList = (uint32)1 << logicalChannel;
//  819 
//  820   // Our Channel has been changed -- notify to save info into NV
//  821   ZDApp_NwkStateUpdateCB();
//  822   touchLink_UpdateNV( TOUCHLINK_UPDATE_NV_NIB );
//  823 
//  824   // Reset the total transmit count and the transmit failure counters
//  825   _NIB.nwkTotalTransmissions = 0;
//  826   nwkTransmissionFailures( TRUE );
//  827 }
//  828 
//  829 /*********************************************************************
//  830  * @fn      touchLink_UpdateNV
//  831  *
//  832  * @brief   Updates NV with NIB and free ranges items
//  833  *
//  834  * @param   enables - specifies what to update
//  835  *
//  836  * @return  none
//  837  */
//  838 void touchLink_UpdateNV( uint8 enables )
//  839 {
//  840 #if defined ( NV_RESTORE )
//  841 
//  842  #if defined ( NV_TURN_OFF_RADIO )
//  843   // Turn off the radio's receiver during an NV update
//  844   uint8 RxOnIdle;
//  845   uint8 x = FALSE;
//  846   ZMacGetReq( ZMacRxOnIdle, &RxOnIdle );
//  847   ZMacSetReq( ZMacRxOnIdle, &x );
//  848  #endif
//  849 
//  850   if ( enables & TOUCHLINK_UPDATE_NV_NIB )
//  851   {
//  852     // Update NIB in NV
//  853     osal_nv_write( ZCD_NV_NIB, 0, sizeof( nwkIB_t ), &_NIB );
//  854 
//  855     // Reset the NV startup option to resume from NV by clearing
//  856     // the "New" join option.
//  857     zgWriteStartupOptions( ZG_STARTUP_CLEAR, ZCD_STARTOPT_DEFAULT_NETWORK_STATE );
//  858   }
//  859 
//  860   if ( enables & TOUCHLINK_UPDATE_NV_RANGES )
//  861   {
//  862     // Store our free network address and group ID ranges
//  863     osal_nv_write( ZCD_NV_MIN_FREE_NWK_ADDR, 0, sizeof( touchLinkFreeNwkAddrBegin ), &touchLinkFreeNwkAddrBegin );
//  864     osal_nv_write( ZCD_NV_MAX_FREE_NWK_ADDR, 0, sizeof( touchLinkFreeNwkAddrEnd ), &touchLinkFreeNwkAddrEnd );
//  865     osal_nv_write( ZCD_NV_MIN_FREE_GRP_ID, 0, sizeof( touchLinkFreeGrpIdBegin ), &touchLinkFreeGrpIdBegin );
//  866     osal_nv_write( ZCD_NV_MAX_FREE_GRP_ID, 0, sizeof( touchLinkFreeGrpIdEnd ), &touchLinkFreeGrpIdEnd );
//  867 
//  868     // Store our group ID range
//  869     osal_nv_write( ZCD_NV_MIN_GRP_IDS, 0, sizeof( touchLinkGrpIDsBegin ), &touchLinkGrpIDsBegin );
//  870     osal_nv_write( ZCD_NV_MAX_GRP_IDS, 0, sizeof( touchLinkGrpIDsEnd ), &touchLinkGrpIDsEnd );
//  871   }
//  872 
//  873  #if defined ( NV_TURN_OFF_RADIO )
//  874   ZMacSetReq( ZMacRxOnIdle, &RxOnIdle );
//  875  #endif
//  876 
//  877 #endif // NV_RESTORE
//  878 }
//  879 
//  880 /*********************************************************************
//  881  * @fn          touchLink_InitNV
//  882  *
//  883  * @brief       Initialize free range RAM variables from NV. If NV items
//  884  *              don't exist, then the NV is initialize with what is in
//  885  *              RAM variables.
//  886  *
//  887  * @param       none
//  888  *
//  889  * @return      none
//  890  */
//  891 static void touchLink_InitNV( void )
//  892 {
//  893   // Initialize our free network address and group ID ranges
//  894   touchLink_ItemInit( ZCD_NV_MIN_FREE_NWK_ADDR, sizeof( touchLinkFreeNwkAddrBegin ), &touchLinkFreeNwkAddrBegin );
//  895   touchLink_ItemInit( ZCD_NV_MAX_FREE_NWK_ADDR, sizeof( touchLinkFreeNwkAddrEnd ), &touchLinkFreeNwkAddrEnd );
//  896   touchLink_ItemInit( ZCD_NV_MIN_FREE_GRP_ID, sizeof( touchLinkFreeGrpIdBegin ), &touchLinkFreeGrpIdBegin );
//  897   touchLink_ItemInit( ZCD_NV_MAX_FREE_GRP_ID, sizeof( touchLinkFreeGrpIdEnd ), &touchLinkFreeGrpIdEnd );
//  898 
//  899   // Initialize our group ID range
//  900   touchLink_ItemInit( ZCD_NV_MIN_GRP_IDS, sizeof( touchLinkGrpIDsBegin ), &touchLinkGrpIDsBegin );
//  901   touchLink_ItemInit( ZCD_NV_MAX_GRP_IDS, sizeof( touchLinkGrpIDsEnd ), &touchLinkGrpIDsEnd );
//  902 }
//  903 
//  904 /*********************************************************************
//  905  * @fn      touchLink_ItemInit
//  906  *
//  907  * @brief   Initialize an NV item. If the item doesn't exist in NV memory,
//  908  *          write the default (value passed in) into NV memory. But if
//  909  *          it exists, set the item to the value stored in NV memory.
//  910  *
//  911  * @param   id - item id
//  912  * @param   len - item len
//  913  * @param   buf - pointer to the item
//  914  *
//  915  * @return  none
//  916  */
//  917 void touchLink_ItemInit( uint16 id, uint16 len, void *pBuf )
//  918 {
//  919 #if defined ( NV_RESTORE )
//  920   // If the item doesn't exist in NV memory, create and initialize
//  921   // it with the value passed in.
//  922   if ( osal_nv_item_init( id, len, pBuf ) == ZSuccess )
//  923   {
//  924     // The item already exists in NV memory, read it from NV memory
//  925     osal_nv_read( id, 0, len, pBuf );
//  926   }
//  927 #endif // NV_RESTORE
//  928 }
//  929 
//  930 /*********************************************************************
//  931  * @fn      touchLink_SetMacNwkParams
//  932  *
//  933  * @brief   Configure MAC with our Network Parameters.
//  934  *
//  935  * @param   nwkAddr - network address
//  936  * @param   panId - PAN identifier
//  937  * @param   channel
//  938  *
//  939  * @return  void
//  940  */
//  941 void touchLink_SetMacNwkParams( uint16 nwkAddr, uint16 panId, uint8 channel )
//  942 {
//  943   // Set our short address
//  944   ZMacSetReq( ZMacShortAddress, (byte*)&nwkAddr );
//  945 
//  946   // Set our PAN ID
//  947   ZMacSetReq( ZMacPanId, (byte*)&panId );
//  948 
//  949   // Tune to the selected logical channel
//  950   touchLink_SetChannel( channel );
//  951 }
//  952 
//  953 /*********************************************************************
//  954  * @fn      touchLink_SetChannel
//  955  *
//  956  * @brief   Set our channel.
//  957  *
//  958  * @param   channel - new channel to change to
//  959  *
//  960  * @return  void
//  961  */
//  962 void touchLink_SetChannel( uint8 channel )
//  963 {
//  964   bdb_setChannel( (uint32) ( 1L << channel ) );
//  965 
//  966   // Set the new channel
//  967   ZMacSetReq( ZMacChannel, &channel );
//  968 }
//  969 
//  970 /*********************************************************************
//  971  * @fn      touchLink_SendDeviceInfoRsp
//  972  *
//  973  * @brief   Send out a Device Information Response command.
//  974  *
//  975  * @param   srcEP - sender's endpoint
//  976  * @param   dstAddr - destination address
//  977  * @param   startIndex - start index
//  978  * @param   transID - received transaction id
//  979  * @param   seqNum - received sequence number
//  980  *
//  981  * @return  ZStatus_t
//  982  */
//  983 uint8 touchLink_SendDeviceInfoRsp( uint8 srcEP, afAddrType_t *dstAddr, uint8 startIndex,
//  984                              uint32 transID, uint8 seqNum )
//  985 {
//  986   bdbTLDeviceInfoRsp_t *pRsp;
//  987   uint8 cnt;
//  988   uint8 rspLen;
//  989   uint8 status = ZSuccess;
//  990 
//  991   cnt = touchLink_GetNumSubDevices( startIndex );
//  992   if ( cnt > TOUCHLINK_DEVICE_INFO_RSP_REC_COUNT_MAX )
//  993   {
//  994     cnt = TOUCHLINK_DEVICE_INFO_RSP_REC_COUNT_MAX; // should be between 0x00-0x05
//  995   }
//  996 
//  997   rspLen = sizeof( bdbTLDeviceInfoRsp_t ) + ( cnt * sizeof( devInfoRec_t ) );
//  998 
//  999   pRsp = (bdbTLDeviceInfoRsp_t *)osal_mem_alloc( rspLen );
// 1000   if ( pRsp )
// 1001   {
// 1002     pRsp->transID = transID;
// 1003 
// 1004     pRsp->numSubDevices = touchLink_GetNumSubDevices( 0 );
// 1005     pRsp->startIndex = startIndex;
// 1006     pRsp->cnt = cnt;
// 1007 
// 1008     for ( uint8 i = 0; i < cnt; i++ )
// 1009     {
// 1010       devInfoRec_t *pRec = &(pRsp->devInfoRec[i]);
// 1011 
// 1012       osal_cpyExtAddr( pRec->ieeeAddr, NLME_GetExtAddr() );
// 1013 
// 1014       touchLink_GetSubDeviceInfo( startIndex + i, &(pRec->deviceInfo) );
// 1015 
// 1016       pRec->sort = 0;
// 1017     }
// 1018 
// 1019     // Send a response back
// 1020     status = bdbTL_Send_DeviceInfoRsp( srcEP, dstAddr, pRsp, seqNum );
// 1021 
// 1022     osal_mem_free( pRsp );
// 1023   }
// 1024   else
// 1025   {
// 1026     status = ZMemError;
// 1027   }
// 1028 
// 1029   return ( status );
// 1030 }
// 1031 
// 1032 /*********************************************************************
// 1033  * @fn      touchLink_SendLeaveReq
// 1034  *
// 1035  * @brief   Send out a Leave Request command.
// 1036  *
// 1037  * @param   void
// 1038  *
// 1039  * @return  ZStatus_t
// 1040  */
// 1041 ZStatus_t touchLink_SendLeaveReq( void )
// 1042 {
// 1043   NLME_LeaveReq_t leaveReq;
// 1044   
// 1045   // Set every field to 0
// 1046   osal_memset( &leaveReq, 0, sizeof( NLME_LeaveReq_t ) );
// 1047   
// 1048   // Send out our leave
// 1049   return ( NLME_LeaveReq( &leaveReq ) );
// 1050 }
// 1051 
// 1052 /*********************************************************************
// 1053  * @fn      touchLink_GetMsgRssi
// 1054  *
// 1055  * @brief   Get the RSSI of the message just received through a ZCL callback.
// 1056  *
// 1057  * @param   none
// 1058  *
// 1059  * @return  RSSI if AF message was received, TOUCHLINK_WORST_RSSI otherwise.
// 1060  */
// 1061 int8 touchLink_GetMsgRssi( void )
// 1062 {
// 1063   afIncomingMSGPacket_t *pAF = zcl_getRawAFMsg();
// 1064 
// 1065   if ( pAF != NULL )
// 1066   {
// 1067     return ( pAF->rssi );
// 1068   }
// 1069 
// 1070   return ( TOUCHLINK_WORST_RSSI );
// 1071 }
// 1072 
// 1073 /*********************************************************************
// 1074  * @fn      touchLink_NewNwkUpdateId
// 1075  *
// 1076  * @brief   Determine the new network update id. The nwkUpdateId attribute
// 1077  *          can take the value of 0x00 - 0xff and may wrap around so care
// 1078  *          must be taken when comparing for newness.
// 1079  *
// 1080  * @param   ID1 - first nwk update id
// 1081  * @param   ID2 - second nwk update id
// 1082  *
// 1083  * @return  new nwk update ID
// 1084  */
// 1085 uint8 touchLink_NewNwkUpdateId( uint8 ID1, uint8 ID2 )
// 1086 {
// 1087   if ( ( (ID1 >= ID2) && ((ID1 - ID2) > 200) )
// 1088       || ( (ID1 < ID2) && ((ID2 - ID1) > 200) ) )
// 1089   {
// 1090     return ( MIN( ID1, ID2 ) );
// 1091   }
// 1092 
// 1093   return ( MAX( ID1, ID2 ) );
// 1094 }
// 1095 
// 1096 /*********************************************************************
// 1097  * @fn      touchLink_SetTouchLinkTaskId
// 1098  *
// 1099  * @brief   Register Target/Initiator taskID for commissioning events
// 1100  *
// 1101  * @param   taskID
// 1102  *
// 1103  * @return  none
// 1104  */
// 1105 void touchLink_SetTouchLinkTaskId( uint8 taskID )
// 1106 {
// 1107   touchLinkTaskId = taskID;
// 1108 
// 1109   // register internal EP for TOUCHLINK messages
// 1110   bdb_RegisterSimpleDescriptor( &touchLink_EP_SimpleDesc );
// 1111 
// 1112 #if defined( INTER_PAN )
// 1113   // Register with Stub APS
// 1114   StubAPS_RegisterApp( &touchLink_EP );
// 1115 #endif // INTER_PAN
// 1116 }
// 1117 
// 1118 /*********************************************************************
// 1119  * @fn      touchLink_PerformNetworkDisc
// 1120  *
// 1121  * @brief   Perform a Network Discovery scan.
// 1122  *          Scan results will be stored locally to analyze.
// 1123  *
// 1124  * @param   scanChannelList - channels to perform discovery scan
// 1125  *
// 1126  * @return  void
// 1127  */
// 1128 void touchLink_PerformNetworkDisc( uint32 scanChannelList )
// 1129 {
// 1130   NLME_ScanFields_t scan;
// 1131 
// 1132   scan.channels = scanChannelList;
// 1133   scan.duration = BEACON_ORDER_240_MSEC;
// 1134   scan.scanType = ZMAC_ACTIVE_SCAN;
// 1135   scan.scanApp  = NLME_DISC_SCAN;
// 1136 
// 1137   if ( NLME_NwkDiscReq2( &scan ) == ZSuccess )
// 1138   {
// 1139     // Register ZDO callback to handle the network discovery confirm and
// 1140     // beacon notification confirm
// 1141     ZDO_RegisterForZdoCB( ZDO_NWK_DISCOVERY_CNF_CBID, touchLink_NwkDiscoveryCnfCB );
// 1142     ZDO_RegisterForZdoCB( ZDO_BEACON_NOTIFY_IND_CBID, touchLink_BeaconIndCB );
// 1143   }
// 1144   else
// 1145   {
// 1146     NLME_NwkDiscTerm();
// 1147   }
// 1148 }
// 1149 
// 1150 /*********************************************************************
// 1151  * @fn      touchLink_BeaconIndCB
// 1152  *
// 1153  * @brief   Process the incoming beacon indication.
// 1154  *
// 1155  * @param   param -  pointer to a parameter and a structure of parameters
// 1156  *
// 1157  * @return  void
// 1158  */
// 1159 static void *touchLink_BeaconIndCB ( void *param )
// 1160 {
// 1161   NLME_beaconInd_t *pBeacon = param;
// 1162   touchLinkDiscoveredNwkParam_t *pParam = pDiscoveredNwkParamList;
// 1163   touchLinkDiscoveredNwkParam_t *pLastParam;
// 1164   uint8 found = FALSE;
// 1165 
// 1166 
// 1167   // Add the network parameter to the Network Parameter List
// 1168   while ( pParam != NULL )
// 1169   {
// 1170     if ( ( pParam->PANID == pBeacon->panID ) &&
// 1171         ( pParam->logicalChannel == pBeacon->logicalChannel ) )
// 1172     {
// 1173       found = TRUE;
// 1174       break;
// 1175     }
// 1176     
// 1177     pLastParam = pParam;
// 1178     pParam = pParam->nextParam;
// 1179   }
// 1180   
// 1181   // If no existing parameter found, make a new one and add to the list
// 1182   if ( found == FALSE )
// 1183   {
// 1184     pParam = osal_mem_alloc( sizeof( touchLinkDiscoveredNwkParam_t ) );
// 1185     if ( pParam == NULL )
// 1186     {
// 1187       // Memory alloc failed, discard this beacon
// 1188       return ( NULL );
// 1189     }
// 1190     
// 1191     // Clear the network descriptor
// 1192     osal_memset( pParam, 0, sizeof( touchLinkDiscoveredNwkParam_t )  );
// 1193     
// 1194     // Initialize the descriptor
// 1195     pParam->chosenRouter = INVALID_NODE_ADDR;
// 1196     pParam->chosenRouterDepth = 0xFF;
// 1197     
// 1198     // Save new entry into the descriptor list
// 1199     if ( pDiscoveredNwkParamList == NULL )
// 1200     {
// 1201       // First element in the list
// 1202       pDiscoveredNwkParamList = pParam;
// 1203     }
// 1204     else
// 1205     {
// 1206       // Last element in the list
// 1207       pLastParam->nextParam = pParam;
// 1208     }
// 1209   }
// 1210   
// 1211   // Update the descriptor with the incoming beacon
// 1212   pParam->logicalChannel = pBeacon->logicalChannel;
// 1213   pParam->PANID          = pBeacon->panID;
// 1214   
// 1215   // Save the extended PAN ID from the beacon payload only if 1.1 version network
// 1216   if ( pBeacon->protocolVersion != ZB_PROT_V1_0 )
// 1217   {
// 1218     osal_cpyExtAddr( pParam->extendedPANID, pBeacon->extendedPanID );
// 1219   }
// 1220   else
// 1221   {
// 1222     osal_memset( pParam->extendedPANID, 0xFF, Z_EXTADDR_LEN );
// 1223   }
// 1224   
// 1225   // check if this device is a better choice to join...
// 1226   // ...dont bother checking assocPermit flag is doing a rejoin
// 1227   if ( pBeacon->LQI > gMIN_TREE_LQI )
// 1228   {
// 1229     uint8 selected = FALSE;
// 1230     uint8 capacity = FALSE;
// 1231     
// 1232     if ( _NIB.spare3 == ZIGBEEPRO )
// 1233     {
// 1234       if ( ((pBeacon->LQI   > pParam->chosenRouterLinkQuality) &&
// 1235             (pBeacon->depth < MAX_NODE_DEPTH)) ||
// 1236           ((pBeacon->LQI   == pParam->chosenRouterLinkQuality) &&
// 1237            (pBeacon->depth < pParam->chosenRouterDepth)) )
// 1238       {
// 1239         selected = TRUE;
// 1240       }
// 1241     }
// 1242     else
// 1243     {
// 1244       if ( pBeacon->depth < pParam->chosenRouterDepth )
// 1245       {
// 1246         selected = TRUE;
// 1247       }
// 1248     }
// 1249     
// 1250     capacity = pBeacon->routerCapacity;
// 1251     
// 1252     if ( (capacity) && (selected) )
// 1253     {
// 1254       // this is the new chosen router for joining...
// 1255       pParam->chosenRouter            = pBeacon->sourceAddr;
// 1256       pParam->chosenRouterLinkQuality = pBeacon->LQI;
// 1257       pParam->chosenRouterDepth       = pBeacon->depth;
// 1258     }
// 1259     
// 1260     if ( pBeacon->deviceCapacity )
// 1261       pParam->deviceCapacity = 1;
// 1262     
// 1263     if ( pBeacon->routerCapacity )
// 1264       pParam->routerCapacity = 1;
// 1265   }
// 1266     
// 1267   return ( NULL );
// 1268 }
// 1269 
// 1270 /*********************************************************************
// 1271  * @fn      touchLink_NwkDiscoveryCnfCB
// 1272  *
// 1273  * @brief   Send an event to inform the target the completion of
// 1274  *          network discovery scan
// 1275  *
// 1276  * @param   param - pointer to a parameter and a structure of parameters
// 1277  *
// 1278  * @return  void
// 1279  */
// 1280 static void *touchLink_NwkDiscoveryCnfCB ( void *param )
// 1281 {
// 1282 #if ( BDB_TOUCHLINK_CAPABILITY_ENABLED == TRUE )
// 1283   // Scan completed. De-register the callbacks with ZDO
// 1284   ZDO_DeregisterForZdoCB( ZDO_NWK_DISCOVERY_CNF_CBID );
// 1285   ZDO_DeregisterForZdoCB( ZDO_BEACON_NOTIFY_IND_CBID );
// 1286 
// 1287   NLME_NwkDiscTerm();
// 1288 
// 1289   if ( pDiscoveredNwkParamList != NULL )
// 1290   {
// 1291     // proceed to join the network, otherwise
// 1292     // Notify our task
// 1293     osal_set_event( touchLinkTaskId, TOUCHLINK_NWK_DISC_CNF_EVT );
// 1294   }
// 1295   else
// 1296   {
// 1297     // no suitable network in secondary channel list, then just wait for touchlink
// 1298 #if ( ZSTACK_ROUTER_BUILD )
// 1299     // Try to create a new distributed network
// 1300     osal_set_event( touchLinkTaskId, TOUCHLINK_NWK_DISC_CNF_EVT );
// 1301 #elif ( ZSTACK_END_DEVICE_BUILD )
// 1302     // Notify the BDB state machine 
// 1303     bdbAttributes.bdbCommissioningStatus = BDB_COMMISSIONING_NO_NETWORK;
// 1304     bdb_reportCommissioningState( BDB_COMMISSIONING_STATE_TL, FALSE );
// 1305     // No parent to join in 
// 1306     bdbCommissioningProcedureState.bdbCommissioningState = BDB_PARENT_LOST;
// 1307     NLME_OrphanStateSet( );
// 1308     bdb_ZedAttemptRecoverNwk( );
// 1309 #endif
// 1310   }
// 1311 
// 1312 #else
// 1313   (void)touchLinkTaskId;
// 1314   (void)param;
// 1315 #endif
// 1316   return ( NULL );
// 1317 }
// 1318 
// 1319 /****************************************************************************
// 1320  * @fn      touchLink_FreeNwkParamList
// 1321  *
// 1322  * @brief   This function frees any network discovery data.
// 1323  *
// 1324  * @param   none
// 1325  *
// 1326  * @return  none
// 1327  */
// 1328 void touchLink_FreeNwkParamList( void )
// 1329 {
// 1330   touchLinkDiscoveredNwkParam_t *pParam = pDiscoveredNwkParamList;
// 1331   touchLinkDiscoveredNwkParam_t *pNextParam;
// 1332 
// 1333   // deallocate the pDiscoveredNwkParamList memory
// 1334   while ( pParam != NULL )
// 1335   {
// 1336     pNextParam = pParam->nextParam;
// 1337 
// 1338     osal_mem_free( pParam );
// 1339 
// 1340     pParam = pNextParam;
// 1341   }
// 1342 
// 1343   pDiscoveredNwkParamList = NULL;
// 1344 }
// 1345 
// 1346 /****************************************************************************
// 1347  * @fn      touchLink_IsValidTransID
// 1348  *
// 1349  * @brief   Transaction ID Filter for Touch-Link received commands.
// 1350  *
// 1351  * @param   transID - received transaction ID
// 1352  *
// 1353  * @return  FALSE if not matching current or transaction expired
// 1354  */
// 1355 bool touchLink_IsValidTransID( uint32 transID )
// 1356 {
// 1357   if ( ( touchLinkTransID == 0 ) || ( ( touchLinkTransID != transID ) && ( touchLinkLastAcceptedTransID != transID ) ) )
// 1358   {
// 1359     return ( FALSE );
// 1360   }
// 1361   return ( TRUE );
// 1362 }
// 1363 
// 1364 /*********************************************************************
// 1365  * @fn      touchLink_RouterProcessZDOMsg
// 1366  *
// 1367  * @brief   Process incoming ZDO messages (for routers)
// 1368  *
// 1369  * @param   inMsg - message to process
// 1370  *
// 1371  * @return  none
// 1372  */
// 1373 void touchLink_RouterProcessZDOMsg( zdoIncomingMsg_t *inMsg )
// 1374 {
// 1375   ZDO_DeviceAnnce_t devAnnce;
// 1376 
// 1377   switch ( inMsg->clusterID )
// 1378   {
// 1379     case Device_annce:
// 1380       {
// 1381         // all devices should send link status, including the one sending it
// 1382         ZDO_ParseDeviceAnnce( inMsg, &devAnnce );
// 1383 
// 1384         linkInfo_t *linkInfo;
// 1385 
// 1386         // check if entry exists
// 1387         linkInfo = nwkNeighborGetLinkInfo( devAnnce.nwkAddr, _NIB.nwkPanId );
// 1388 
// 1389         // if not, look for a vacant entry to add this node...
// 1390         if ( linkInfo == NULL )
// 1391         {
// 1392           nwkNeighborAdd( devAnnce.nwkAddr, _NIB.nwkPanId, DEF_LQI );
// 1393           linkInfo = nwkNeighborGetLinkInfo( devAnnce.nwkAddr, _NIB.nwkPanId );
// 1394           linkInfo->txCost = DEF_LINK_COST;
// 1395           linkInfo->rxLqi = MIN_LQI_COST_1; 
// 1396   
// 1397           // if we have end device childs, send link status
// 1398           if ( AssocCount(CHILD_RFD, CHILD_RFD_RX_IDLE) > 0 )
// 1399           {
// 1400             NLME_UpdateLinkStatus();
// 1401           }
// 1402         }
// 1403       }
// 1404       break;
// 1405 
// 1406     case Mgmt_Permit_Join_req:
// 1407       {
// 1408         uint8 duration = inMsg->asdu[ZDP_MGMT_PERMIT_JOIN_REQ_DURATION];
// 1409         ZStatus_t stat = NLME_PermitJoiningRequest( duration );
// 1410         // Send a response if unicast
// 1411         if ( !inMsg->wasBroadcast )
// 1412         {
// 1413           ZDP_MgmtPermitJoinRsp( inMsg->TransSeq, &(inMsg->srcAddr), stat, false );
// 1414         }
// 1415       }
// 1416       break;
// 1417 
// 1418     default:
// 1419       break;
// 1420   }
// 1421 }
// 1422 
// 1423 /*********************************************************************
// 1424  * @fn      touchLink_PermitJoin
// 1425  *
// 1426  * @brief   Set the router permit join flag, to allow or deny classical
// 1427  *          commissioning by other ZigBee devices.
// 1428  *
// 1429  * @param   duration - enable up to aplcMaxPermitJoinDuration seconds,
// 1430  *                     0 to disable
// 1431  *
// 1432  * @return  status
// 1433  */
// 1434 ZStatus_t touchLink_PermitJoin( uint8 duration )
// 1435 {
// 1436   if ( duration > APLC_MAX_PERMIT_JOIN_DURATION )
// 1437   {
// 1438     duration = APLC_MAX_PERMIT_JOIN_DURATION;
// 1439   }
// 1440   return NLME_PermitJoiningRequest( duration );
// 1441 }
// 1442 
// 1443 /*********************************************************************
// 1444  * @fn      targetStartRtr
// 1445  *
// 1446  * @brief   Start operating on the new network.
// 1447  *
// 1448  * @param   pParams - pointer to received network parameters
// 1449  * @param   transID - transaction id
// 1450  *
// 1451  * @return  none
// 1452  */
// 1453 void touchLinkStartRtr( bdbTLNwkParams_t *pParams, uint32 transID )
// 1454 {
// 1455   // Copy the new network parameters to
// 1456   touchLink_SetNIB( NWK_ROUTER, pParams->nwkAddr, pParams->extendedPANID,
// 1457               pParams->logicalChannel, pParams->panId, _NIB.nwkUpdateId );
// 1458 
// 1459   // Apply the received network key
// 1460   touchLink_DecryptNwkKey( pParams->nwkKey, pParams->keyIndex, transID, touchLinkResponseID );
// 1461 
// 1462   // setting apsTrustCenterAddress to 0xffffffff
// 1463   ZDSecMgrUpdateTCAddress( NULL );
// 1464 
// 1465   NLME_PermitJoiningRequest(0);
// 1466   
// 1467   // Touchlink distributed network flag
// 1468   touchlinkDistNwk = TRUE;
// 1469 
// 1470   // Use the new free ranges
// 1471   //touchLink_UpdateFreeRanges( pParams );
// 1472 
// 1473   // Save free ranges
// 1474   touchLink_UpdateNV( TOUCHLINK_UPDATE_NV_RANGES );
// 1475 
// 1476   // In case we're here after a leave
// 1477   touchLinkLeaveInitiated = FALSE;
// 1478 
// 1479   // Clear leave control logic
// 1480   ZDApp_LeaveCtrlReset();
// 1481 
// 1482   // Start operating on the new network
// 1483   ZDOInitDeviceEx( 0, 1 );
// 1484 }
// 1485 
// 1486 /*********************************************************************
// 1487  * @fn      touchLink_DevRejoin
// 1488  *
// 1489  * @brief   Perform a network rejoin
// 1490  *
// 1491  * @param   rejoinInf - pointer to received network parameters
// 1492  *
// 1493  * @return  none
// 1494  */
// 1495 void touchLink_DevRejoin( bdbTLNwkRejoin_t *rejoinInf )
// 1496 {
// 1497     networkDesc_t *pNwkDesc = NULL;
// 1498      
// 1499     // Initialize the security for type of device
// 1500     ZDApp_SecInit( ZDO_INITDEV_RESTORED_NETWORK_STATE );
// 1501     
// 1502     pNwkDesc = (networkDesc_t *)osal_mem_alloc( sizeof( networkDesc_t ) );
// 1503     if( pNwkDesc == NULL )
// 1504     {
// 1505       return;
// 1506     }
// 1507          
// 1508     NwkDescList = pNwkDesc;
// 1509     pNwkDesc->panId = rejoinInf->panId;
// 1510     pNwkDesc->logicalChannel = rejoinInf->logicalChannel;
// 1511     osal_memcpy( pNwkDesc->extendedPANID, rejoinInf->extendedPANID, Z_EXTADDR_LEN);
// 1512     pNwkDesc->chosenRouterDepth = 1;
// 1513     pNwkDesc->routerCapacity = 1;
// 1514     pNwkDesc->deviceCapacity = 1;
// 1515     pNwkDesc->version = 2;
// 1516     pNwkDesc->stackProfile = 2;
// 1517     pNwkDesc->chosenRouterLinkQuality = DEF_LQI;
// 1518     pNwkDesc->chosenRouter = rejoinInf->nwkAddr;
// 1519     pNwkDesc->updateId = rejoinInf->nwkUpdateId;
// 1520     pNwkDesc->nextDesc = NULL;
// 1521     
// 1522     // Save free ranges
// 1523     touchLink_UpdateNV( TOUCHLINK_UPDATE_NV_RANGES );
// 1524 
// 1525     // In case we're here after a leave
// 1526     touchLinkLeaveInitiated = FALSE;
// 1527 
// 1528     // Clear leave control logic
// 1529     ZDApp_LeaveCtrlReset();
// 1530     
// 1531     // Let's join the network started by the target
// 1532     NLME_ReJoinRequest( rejoinInf->extendedPANID, _NIB.nwkLogicalChannel);
// 1533 }
// 1534 
// 1535 /*********************************************************************
// 1536  * @fn      touchLink_DeviceIsInitiator
// 1537  *
// 1538  * @brief   Set device initiator flag.
// 1539  *
// 1540  * @param   initiator - new flag value
// 1541  *
// 1542  * @return  none
// 1543  */
// 1544 void touchLink_DeviceIsInitiator( bool initiator )
// 1545 {
// 1546   touchLinkIsInitiator = initiator;
// 1547 }
// 1548 
// 1549 /*********************************************************************
// 1550  * @fn      touchLink_DeviceIsInitiator
// 1551  *
// 1552  * @brief   Get device initiator flag.
// 1553  *
// 1554  * @param   none
// 1555  *
// 1556  * @return  touchLinkIsInitiator - flag value
// 1557  */
// 1558 bool touchLink_GetDeviceInitiator( void )
// 1559 {
// 1560   return touchLinkIsInitiator;
// 1561 }
// 1562 
// 1563 #endif // BDB_TL_TARGET || BDB_TL_INITIATOR
// 1564 
// 1565 /*********************************************************************
// 1566 *********************************************************************/
// 
//
// 
//
//
//Errors: none
//Warnings: none
