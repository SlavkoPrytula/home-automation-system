###############################################################################
#
# IAR C/C++ Compiler V10.30.1.6000 for 8051               18/Apr/2021  13:21:52
# Copyright 2004-2018 IAR Systems AB.
# Evaluation license - IAR Embedded Workbench for 8051, Evaluation edition 10.30
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Components\stack\bdb\bdb_touchlink_initiator.c
#    Command line       =  
#        -f C:\users\slavko\Temp\EWc9bd.tmp ("C:\Texas Instruments\Z-Stack
#        3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Components\stack\bdb\bdb_touchlink_initiator.c" -D SECURE=1 -D
#        TC_LINKKEY_JOIN -D NV_INIT -D NV_RESTORE -D xZTOOL_P1 -D xMT_TASK -D
#        xMT_APP_FUNC -D xMT_SYS_FUNC -D xMT_ZDO_FUNC -D xMT_ZDO_MGMT -D
#        xMT_APP_CNF_FUNC -D LEGACY_LCD_DEBUG -D LCD_SUPPORTED=DEBUG -D
#        MULTICAST_ENABLED=FALSE -D ZCL_READ -D ZCL_WRITE -D ZCL_BASIC -D
#        ZCL_IDENTIFY -D ZCL_SCENES -D ZCL_GROUPS -lC "C:\Texas
#        Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\GenericApp\CC2530DB\CoordinatorEB\List"
#        -lA "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\GenericApp\CC2530DB\CoordinatorEB\List"
#        --diag_suppress Pe001,Pa010 -o "C:\Texas Instruments\Z-Stack
#        3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\GenericApp\CC2530DB\CoordinatorEB\Obj"
#        -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data_rom --nr_virtual_regs 16 -f "C:\Texas
#        Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\GenericApp\CC2530DB\..\..\..\Tools\CC2530DB\f8wCoord.cfg"
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRUE
#        -DMAC_CFG_TX_DATA_MAX=5 -DMAC_CFG_TX_MAX=8 -DMAC_CFG_RX_MAX=5
#        -DZDO_COORDINATOR -DRTR_NWK) -f "C:\Texas Instruments\Z-Stack
#        3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\GenericApp\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg"
#        (-DZIGBEEPRO -DSECURE=1 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0xFFFF
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 -DDEFAULT_KEY={0} -DMAC_MAX_FRAME_SIZE=116
#        -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const __code"
#        -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000
#        -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100 -DREJOIN_POLL_RATE=440
#        -DREJOIN_BACKOFF=900000 -DREJOIN_SCAN=900000 -DENABLE_LED4_DISABLE_S1)
#        -f "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\GenericApp\CC2530DB\..\..\..\Tools\CC2530DB\f8wZCL.cfg"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\GenericApp\CC2530DB\" -I
#        "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\GenericApp\CC2530DB\..\Source\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\GenericApp\CC2530DB\..\..\Source\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\GenericApp\CC2530DB\..\..\..\ZMain\TI2530DB\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\GenericApp\CC2530DB\..\..\..\..\..\Components\hal\include\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\GenericApp\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\GenericApp\CC2530DB\..\..\..\..\..\Components\mac\include\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\GenericApp\CC2530DB\..\..\..\..\..\Components\mac\high_level\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\GenericApp\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\GenericApp\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\single_chip\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\GenericApp\CC2530DB\..\..\..\..\..\Components\mt\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\GenericApp\CC2530DB\..\..\..\..\..\Components\osal\include\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\GenericApp\CC2530DB\..\..\..\..\..\Components\services\saddr\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\GenericApp\CC2530DB\..\..\..\..\..\Components\services\sdata\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\GenericApp\CC2530DB\..\..\..\..\..\Components\stack\af\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\GenericApp\CC2530DB\..\..\..\..\..\Components\stack\bdb\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\GenericApp\CC2530DB\..\..\..\..\..\Components\stack\gp\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\GenericApp\CC2530DB\..\..\..\..\..\Components\stack\nwk\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\GenericApp\CC2530DB\..\..\..\..\..\Components\stack\sapi\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\GenericApp\CC2530DB\..\..\..\..\..\Components\stack\sec\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\GenericApp\CC2530DB\..\..\..\..\..\Components\stack\sys\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\GenericApp\CC2530DB\..\..\..\..\..\Components\stack\zcl\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\GenericApp\CC2530DB\..\..\..\..\..\Components\stack\zdo\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\GenericApp\CC2530DB\..\..\..\..\..\Components\zmac\"
#        -I "C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\GenericApp\CC2530DB\..\..\..\..\..\Components\zmac\f8w\"
#        -Ohz --require_prototypes)
#    Locale             =  English_USA.1252
#    List file          =  
#        C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\GenericApp\CC2530DB\CoordinatorEB\List\bdb_touchlink_initiator.lst
#    Object file        =  
#        C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack
#        3.0.2\Projects\zstack\HomeAutomation\GenericApp\CC2530DB\CoordinatorEB\Obj\bdb_touchlink_initiator.r51
#
###############################################################################

C:\Texas Instruments\Z-Stack 3.0.2-20210417T211827Z-001\Z-Stack 3.0.2\Components\stack\bdb\bdb_touchlink_initiator.c
      1          /**************************************************************************************************
      2            Filename:       bdb_touchlink_initiator.c
      3            Revised:        $Date: 2013-11-22 16:17:23 -0800 (Fri, 22 Nov 2013) $
      4            Revision:       $Revision: 36220 $
      5          
      6            Description:    Zigbee Cluster Library - Light Link Initiator.
      7          
      8          
      9            Copyright 2011-2013 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          
     41          /*********************************************************************
     42           * INCLUDES
     43           */
     44          #include "ZComDef.h"
     45          #include "OSAL.h"
     46          #include "OSAL_Tasks.h"
     47          #include "OSAL_Nv.h"
     48          #include "AF.h"
     49          #include "ZDApp.h"
     50          #include "ZDSecMgr.h"
     51          #include "ZDObject.h"
     52          #include "nwk_util.h"
     53          #include "ZGlobals.h"
     54          #include "AddrMgr.h"
     55          
     56          #if defined ( POWER_SAVING )
     57          #include "OSAL_PwrMgr.h"
     58          #endif
     59          
     60          #include "stub_aps.h"
     61          
     62          #include "zcl.h"
     63          #include "zcl_general.h"
     64          #include "bdb.h"
     65          #include "bdb_interface.h"
     66          #include "bdb_tlCommissioning.h"
     67          #include "bdb_touchlink.h"
     68          
     69          #include "bdb_touchlink_initiator.h"
     70          #include "hal_lcd.h"
     71          #include "hal_led.h"
     72          
     73          #if defined ( BDB_TL_INITIATOR )
     74             
     75          /*********************************************************************
     76           * MACROS
     77           */
     78          
     79          /*********************************************************************
     80           * CONSTANTS
     81           */
     82          
     83          #define TOUCHLINK_INITIATOR_REJOIN_TIMEOUT             2500 // 2.5 sec
     84          
     85          // for non-polling end-devices only
     86          #define TOUCHLINK_INITIATOR_TEMP_POST_TL_POLL_RATE     1000
     87          
     88          #define DEV_INFO_INVALID_EP                            0xFE
     89          
     90          #define TOUCHLINK_INITIATOR_NUM_SCAN_REQ_PRIMARY       8  // 5 times on 1st channel, plus once for each remianing primary channel
     91          #define TOUCHLINK_INITIATOR_NUM_SCAN_REQ_EXTENDED      20 // (TOUCHLINK_NUM_SCAN_REQ_PRIMARY + sizeof(TOUCHLINK_SECONDARY_CHANNELS_SET))
     92          
     93          /*********************************************************************
     94           * TYPEDEFS
     95           */
     96          typedef union
     97          {
     98            bdbTLNwkStartRsp_t nwkStartRsp;
     99            bdbTLNwkJoinRsp_t nwkJoinRsp;
    100          } bdbTLRsp_t;
    101          
    102          typedef struct
    103          {
    104            bdbTLScanRsp_t scanRsp;
    105            afAddrType_t srcAddr;
    106            uint16 newNwkAddr;
    107            uint8 rxChannel;  // channel scan response was heard on
    108            int8 lastRssi;    // receieved RSSI
    109          } targetCandidate_t;
    110          
    111          /*********************************************************************
    112           * GLOBAL VARIABLES
    113           */
    114          uint8 touchLinkInitiator_TaskID;
    115          
    116          /*********************************************************************
    117           * EXTERNAL VARIABLES
    118           */
    119          extern devStartModes_t devStartMode;
    120          extern uint8 _tmpRejoinState;
    121          
    122          /*********************************************************************
    123           * EXTERNAL FUNCTIONS
    124           */
    125          extern void bdb_setNodeIsOnANetwork(bool isOnANetwork);
    126          
    127          /*********************************************************************
    128           * LOCAL VARIABLES
    129           */
    130          static uint8 initiatorSeqNum;
    131          
    132          // Touch Link channel tracking
    133          static uint8 numScanReqSent;
    134          static uint8 scanReqChannels;
    135          
    136          // Network key sent to the target to start the network with
    137          static uint8 keyIndexSent;
    138          static uint8 encKeySent[SEC_KEY_LEN];
    139          static uint32 responseIDSent;
    140          
    141          // Info related to the received request
    142          #if ZSTACK_END_DEVICE_BUILD
    143          static bdbTLNwkJoinReq_t joinReq;
    144          #endif
    145          
    146          // Info related to the received response
    147          static targetCandidate_t selectedTarget;
    148          static uint16 selectedTargetNwkAddr;
    149          static ZLongAddr_t selectedTargetIEEEAddr;
    150          static bdbTLRsp_t rxRsp; // network start or join response
    151          
    152          static bdbTLNwkParams_t initiatorNwkParams = {0};
    153          
    154          // Addresses used for sending/receiving messages
    155          static afAddrType_t bcastAddr;
    156          
    157          static uint16 savedPollRate;
    158          static uint16 savedQueuedPollRate;
    159          static uint16 savedResponsePollRate;
    160          static uint8 savedRxOnIdle;
    161          
    162          // Application callback
    163          static touchLink_NotifyAppTLCB_t pfnNotifyAppCB = NULL;
    164          static touchLink_SelectDiscDevCB_t pfnSelectDiscDevCB = NULL;
    165          
    166          static uint8 initiatorRegisteredMsgAppTaskID = TASK_NO_TASK;
    167          
    168          /*********************************************************************
    169           * GLOBAL FUNCTIONS
    170           */
    171          extern void touchLink_ItemInit( uint16 id, uint16 len, void *pBuf );
    172          
    173          /*********************************************************************
    174           * LOCAL FUNCTIONS
    175           */
    176          
    177          static ZStatus_t initiatorScanReqCB( afAddrType_t *srcAddr, bdbTLScanReq_t *pReq, uint8 seqNum );
    178          static ZStatus_t initiatorDeviceInfoReqCB( afAddrType_t *srcAddr, bdbTLDeviceInfoReq_t *pReq, uint8 seqNum );
    179          static ZStatus_t initiatorIdentifyReqCB( afAddrType_t *srcAddr, bdbTLIdentifyReq_t *pReq );
    180          static ZStatus_t initiatorNwkJoinReqCB( afAddrType_t *srcAddr, bdbTLNwkJoinReq_t *pReq, uint8 seqNum );
    181          static ZStatus_t initiatorNwkUpdateReqCB( afAddrType_t *srcAddr, bdbTLNwkUpdateReq_t *pReq );
    182          static ZStatus_t initiatorScanRspCB( afAddrType_t *srcAddr, bdbTLScanRsp_t *pRsp );
    183          static ZStatus_t initiatorDeviceInfoRspCB( afAddrType_t *srcAddr, bdbTLDeviceInfoRsp_t *pRsp );
    184          static ZStatus_t initiatorNwkStartRspCB( afAddrType_t *srcAddr, bdbTLNwkStartRsp_t *pRsp );
    185          static ZStatus_t initiatorNwkJoinRtrRspCB( afAddrType_t *srcAddr, bdbTLNwkJoinRsp_t *pRsp );
    186          static ZStatus_t initiatorNwkJoinEDRspCB( afAddrType_t *srcAddr, bdbTLNwkJoinRsp_t *pRsp );
    187          static void *initiatorZdoLeaveCnfCB( void *pParam );
    188          static ZStatus_t touchLink_InitiatorSendScanRsp( uint8 srcEP, afAddrType_t *dstAddr, uint32 transID, uint8 seqNum );
    189          static void initiatorProcessStateChange( devStates_t state );
    190          static void initiatorSetNwkToInitState( void );
    191          #if ( ZSTACK_ROUTER_BUILD )
    192          static void initiatorJoinNwk( void );
    193          #endif
    194          static void initiatorReJoinNwk( devStartModes_t startMode );
    195          static void initiatorSendScanReq( bool freshScan );
    196          static ZStatus_t initiatorSendNwkStartReq( bdbTLScanRsp_t *pRsp );
    197          static ZStatus_t initiatorSendNwkJoinReq( bdbTLScanRsp_t *pRsp );
    198          static ZStatus_t initiatorSendNwkUpdateReq( bdbTLScanRsp_t *pRsp );
    199          static void initiatorClearSelectedTarget( void );
    200          
    201          /*********************************************************************
    202           * TOUCHLINK Initiator Callback Table
    203           */
    204          // Initiator Command Callbacks table
    205          static bdbTL_InterPANCallbacks_t touchLinkInitiator_CmdCBs =
    206          {
    207            // Received Server Commands
    208            initiatorScanReqCB,       // Scan Request command
    209            initiatorDeviceInfoReqCB, // Device Information Request command
    210            initiatorIdentifyReqCB,   // Identify Request command
    211            NULL,                     // Reset to Factory New Request command
    212            NULL,                     // Network Start Request command
    213          #if ( ZSTACK_ROUTER_BUILD )
    214            initiatorNwkJoinReqCB,    // Network Join Router Request command
    215            NULL,                     // Network Join End Device Request command
    216          #else
    217            NULL,                     // Network Join Router Request command
    218            initiatorNwkJoinReqCB,    // Network Join End Device Request command
    219          #endif
    220            initiatorNwkUpdateReqCB,  // Network Update Request command
    221          
    222            // Received Client Commands
    223            initiatorScanRspCB,       // Scan Response command
    224            initiatorDeviceInfoRspCB, // Device Information Response command
    225            initiatorNwkStartRspCB,   // Network Start Response command
    226            initiatorNwkJoinRtrRspCB, // Network Join Router Response command
    227            initiatorNwkJoinEDRspCB   // Network Join End Device Response command
    228          };
    229          
    230          /*********************************************************************
    231           * PUBLIC FUNCTIONS
    232           */
    233          
    234          /*********************************************************************
    235           * @fn      touchLinkInitiator_InitDevice
    236           *
    237           * @brief   Start the TOUCHLINK Initiator device in the network if it's not
    238           *          factory new. Otherwise, determine the network parameters
    239           *          and wait for a touchlink command.
    240           *
    241           * @param   none
    242           *
    243           * @return  status
    244           */
    245          ZStatus_t touchLinkInitiator_InitDevice( void )
    246          {
    247            ZDO_Config_Node_Descriptor.LogicalType = zgDeviceLogicalType;
    248            
    249            // Is not factory new?
    250            if ( bdbAttributes.bdbNodeIsOnANetwork == TRUE )
    251            {
    252              // Resume ZigBee functionality based on the info stored in NV
    253              initiatorReJoinNwk( MODE_RESUME );
    254            }
    255            else
    256            {
    257              initiatorSelectNwkParams();
    258            }
    259          
    260          #if defined ( POWER_SAVING )
    261            osal_pwrmgr_device( PWRMGR_BATTERY );
    262          #endif
    263          
    264          #if ( ZSTACK_ROUTER_BUILD )
    265            // Enable our receiver
    266            savedRxOnIdle = TRUE;
    267            ZMacSetReq( ZMacRxOnIdle, &savedRxOnIdle );
    268            touchLink_PermitJoin(0);
    269          #endif
    270          
    271            return ( ZSuccess );
    272          }
    273          
    274          /*********************************************************************
    275           * @fn      touchLinkInitiator_RegisterNotifyTLCB
    276           *
    277           * @brief   Register an Application's Touch-Link Notify callback function.
    278           *
    279           * @param   pfnNotifyApp - application callback
    280           *
    281           * @return  none
    282           */
    283          void touchLinkInitiator_RegisterNotifyTLCB( touchLink_NotifyAppTLCB_t pfnNotifyApp )
    284          {
    285            pfnNotifyAppCB = pfnNotifyApp;
    286          }
    287          
    288          /*********************************************************************
    289           * @fn      touchLinkInitiator_RegisterSelectDiscDevCB
    290           *
    291           * @brief   Register an Application's Selection callback function, to select
    292           *          a target from the discovered devices during a Touch-link scan.
    293           *
    294           * @param   pfnSelectDiscDev - application callback
    295           *
    296           * @return  none
    297           */
    298          void touchLinkInitiator_RegisterSelectDiscDevCB( touchLink_SelectDiscDevCB_t pfnSelectDiscDev )
    299          {
    300            pfnSelectDiscDevCB = pfnSelectDiscDev;
    301          }
    302          
    303          /*********************************************************************
    304           * @fn      touchLinkInitiator_StartDevDisc
    305           *
    306           * @brief   Start device discovery, scanning for other devices in the vicinity
    307           *          of the originator (initiating first part of the Touch-Link process).
    308           *          Device discovery shall only be initiated by address assignment capable
    309           *          devices. To perform device discovery, the initiator shall broadcast
    310           *          inter-PAN Scan Requests, spaced at an interval of
    311           *          BDBCTL_SCAN_TIME_BASE_DURATION seconds.
    312           *
    313           * @param   none
    314           *
    315           * @return  status
    316           */
    317          ZStatus_t touchLinkInitiator_StartDevDisc( void )
    318          {
    319            osal_clear_event( ZDAppTaskID, ZDO_NETWORK_INIT ); // in case orphaned rejoin was called
    320            ZDApp_StopJoiningCycle();
    321          
    322            //abort any touchlink in progress and start the new dev discovery.
    323            touchLinkInitiator_AbortTL();
    324          
    325            // To perform device discovery, switch to channel 11 and broadcast five
    326            // consecutive inter-PAN Scan Requests. Then switch to each remaining
    327            // TOUCHLINK channels in turn (i.e., 15, 20, and 25) and broadcast a single
    328            // inter-PAN Scan Request on each channel.
    329            if ( !osal_get_timeoutEx( touchLinkInitiator_TaskID, TOUCHLINK_TL_SCAN_BASE_EVT ) )
    330            {
    331              uint8 x = TRUE;
    332          
    333              // Generate a new Transaction Id
    334              touchLinkTransID = ( ( (uint32)osal_rand() ) << 16 ) + osal_rand();
    335              osal_start_timerEx( touchLinkInitiator_TaskID, TOUCHLINK_TRANS_LIFETIME_EXPIRED_EVT,
    336                                  BDBCTL_INTER_PAN_TRANS_ID_LIFETIME );
    337          
    338              if ( bdbAttributes.bdbNodeIsOnANetwork == TRUE )
    339              {
    340                // Turn off polling during touch-link procedure
    341                savedPollRate = zgPollRate;
    342                savedQueuedPollRate = zgQueuedPollRate;
    343                savedResponsePollRate = zgResponsePollRate;
    344          
    345                NLME_SetPollRate( 0 );
    346                NLME_SetQueuedPollRate( 0 );
    347                NLME_SetResponseRate( 0 );
    348              }
    349          
    350              // Remember current rx state
    351              ZMacGetReq( ZMacRxOnIdle, &savedRxOnIdle );
    352          
    353              // MAC receiver should be on during touch-link procedure
    354              ZMacSetReq( ZMacRxOnIdle, &x );
    355          
    356              scanReqChannels = TOUCHLINK_SCAN_PRIMARY_CHANNELS;
    357              numScanReqSent = 0;
    358          
    359              // Send out the first Scan Request
    360              initiatorSendScanReq( TRUE );
    361          
    362              return ( ZSuccess );
    363            }
    364          
    365            return ( ZFailure );
    366          }
    367          
    368          /*********************************************************************
    369           * @fn      bdbTL_Send_IndentifyReq
    370           *
    371           * @brief   Call to send out a scan request for factory new procedure
    372           *
    373           * @param   
    374           *
    375           * @return 
    376           */
    377          void touchLinkInitiator_ResetToFNProcedure( void )
    378          {
    379            if ( ( bdbCommissioningProcedureState.bdbCommissioningState == 0 ) || ( osal_get_timeoutEx( bdb_TaskID,BDB_CHANGE_COMMISSIONING_STATE ) == 0 ) )
    380            {
    381              touchlinkFNReset = TRUE;
    382              touchLinkInitiator_StartDevDisc( );
    383            }
    384          }
    385          
    386          /*********************************************************************
    387           * @fn      touchLinkInitiator_AbortTL
    388           *
    389           * @brief   Abort Touch-link device discovery.
    390           *          Successful execution could be done before Network Start/Join
    391           *          commands are sent. Until then, since no device parameters
    392           *          such as network settings are altered, the Touch-Link is
    393           *          still reversible.
    394           *
    395           * @param   none
    396           *
    397           * @return  status
    398           */
    399          ZStatus_t touchLinkInitiator_AbortTL( void )
    400          {
    401            if ( ( osal_stop_timerEx( touchLinkInitiator_TaskID, TOUCHLINK_TL_SCAN_BASE_EVT ) == SUCCESS )
    402                 || ( osal_stop_timerEx( touchLinkInitiator_TaskID, TOUCHLINK_CFG_TARGET_EVT ) == SUCCESS )
    403                 || ( osal_stop_timerEx( touchLinkInitiator_TaskID, TOUCHLINK_W4_NWK_START_RSP_EVT ) == SUCCESS )
    404                 || ( osal_stop_timerEx( touchLinkInitiator_TaskID, TOUCHLINK_W4_NWK_JOIN_RSP_EVT ) == SUCCESS ) )
    405            {
    406              initiatorSetNwkToInitState();
    407              touchLinkTransID = 0;
    408              numScanReqSent = 0;
    409              initiatorClearSelectedTarget();
    410              selectedTargetNwkAddr = 0;
    411          
    412              return ( ZSuccess );
    413            }
    414          
    415            return ( ZFailure );
    416          }
    417          
    418          /*********************************************************************
    419           * @fn          touchLinkInitiator_Init
    420           *
    421           * @brief       Initialization function for the TOUCHLINK Initiator task.
    422           *
    423           * @param       task_id - TOUCHLINK Initiator task id
    424           *
    425           * @return      none
    426           */
    427          void touchLinkInitiator_Init( uint8 task_id )
    428          {
    429            // Save our own Task ID
    430            touchLinkInitiator_TaskID = task_id;
    431          
    432            touchLink_SetTouchLinkTaskId( touchLinkInitiator_TaskID );
    433          
    434          
    435            // Build a broadcast address for the Scan Request
    436            bcastAddr.addrMode = afAddrBroadcast;
    437            bcastAddr.addr.shortAddr = NWK_BROADCAST_SHORTADDR_DEVALL;
    438            bcastAddr.panId = 0xFFFF;
    439            bcastAddr.endPoint = STUBAPS_INTER_PAN_EP;
    440          
    441            // Initialize TOUCHLINK common variables
    442            touchLink_InitVariables( TRUE );
    443          
    444            savedPollRate = POLL_RATE;
    445            savedQueuedPollRate = QUEUED_POLL_RATE;
    446            savedResponsePollRate = RESPONSE_POLL_RATE;
    447          
    448            numScanReqSent = 0;
    449            initiatorClearSelectedTarget();
    450            scanReqChannels = TOUCHLINK_SCAN_PRIMARY_CHANNELS;
    451          
    452            initiatorSeqNum = 0;
    453          
    454            // Register to receive the unprocessed Foundation command/response messages
    455            zcl_registerForMsg( touchLinkInitiator_TaskID );
    456          
    457            // Register for TOUCHLINK Initiator callbacks (for Inter-PAN commands)
    458            bdbTL_RegisterInterPANCmdCallbacks( &touchLinkInitiator_CmdCBs );
    459          
    460            // Register for Initiator to receive Leave Confirm
    461            ZDO_RegisterForZdoCB( ZDO_LEAVE_CNF_CBID, initiatorZdoLeaveCnfCB );
    462          
    463          #if (ZSTACK_ROUTER_BUILD)
    464            // Register to process ZDO messages
    465            ZDO_RegisterForZDOMsg( touchLinkInitiator_TaskID, Mgmt_Permit_Join_req );
    466            ZDO_RegisterForZDOMsg( touchLinkInitiator_TaskID, Device_annce );
    467          #endif
    468          
    469          }
    470          
    471          /*********************************************************************
    472           * @fn      initiatorSelectNwkParams
    473           *
    474           * @brief   Select a unique PAN ID and Extended PAN ID when compared to
    475           *          the PAN IDs and Extended PAN IDs of the networks detected
    476           *          on the TOUCHLINK channels. The selected Extended PAN ID must be
    477           *          a random number (and not equal to our IEEE address).
    478           *
    479           * @param   void
    480           *
    481           * @return  void
    482           */
    483          void initiatorSelectNwkParams( void )
    484          {
    485            // Set our group ID range
    486            touchLink_PopGrpIDRange( touchLink_GetNumGrpIDs(), &touchLinkGrpIDsBegin, &touchLinkGrpIDsEnd );
    487          
    488            // Select a random Extended PAN ID
    489            touchLink_GenerateRandNum( _NIB.extendedPANID, Z_EXTADDR_LEN );
    490          
    491            // Select a random PAN ID
    492            _NIB.nwkPanId = osal_rand();
    493          
    494            if ( _NIB.nwkLogicalChannel == 0 )
    495            {
    496              if (TOUCHLINK_FIXED_CHANNEL_ENABLE == TRUE )
    497              {
    498                // Use the fixed channel defined in bdb_interface
    499                _NIB.nwkLogicalChannel = TOUCHLINK_FIXED_CHANNEL;
    500              }
    501              else
    502              {
    503                // Select randomly one of the TouchLink channels as our logical channel
    504                _NIB.nwkLogicalChannel = touchLink_GetRandPrimaryChannel( );
    505              }
    506            }
    507            
    508            selectedTargetNwkAddr = 0;
    509          
    510            if ( devState != DEV_INIT )
    511            {
    512              // Let's assume we're the first initiator
    513              _NIB.nwkDevAddress = touchLink_PopNwkAddress();
    514            }
    515          
    516            // Configure MAC with our network parameters
    517            touchLink_SetMacNwkParams( _NIB.nwkDevAddress, _NIB.nwkPanId, _NIB.nwkLogicalChannel );
    518          }
    519          
    520          /*********************************************************************
    521           * @fn      touchLinkInitiator_RegisterForMsg
    522           *
    523           * @brief   Register application task to receive unprocessed messages
    524           *          received by the initiator endpoint.
    525           *
    526           * @param   taskId - task Id of the Application where commands will be sent to
    527           *
    528           * @return  ZSuccess if task registration successful
    529           *********************************************************************/
    530          ZStatus_t touchLinkInitiator_RegisterForMsg( uint8 taskId )
    531          {
    532            if ( initiatorRegisteredMsgAppTaskID == TASK_NO_TASK )
    533            {
    534              initiatorRegisteredMsgAppTaskID = taskId;
    535              return ( ZSuccess );
    536            }
    537            return ( ZFailure );
    538          }
    539          
    540          /*********************************************************************
    541           * @fn          touchLinkInitiator_event_loop
    542           *
    543           * @brief       Event Loop Processor for TOUCHLINK Initiator.
    544           *
    545           * @param       task_id - task id
    546           * @param       events - event bitmap
    547           *
    548           * @return      unprocessed events
    549           */
    550          uint16 touchLinkInitiator_event_loop( uint8 task_id, uint16 events )
    551          {
    552            if ( events & SYS_EVENT_MSG )
    553            {
    554              osal_event_hdr_t *pMsg;
    555              ZStatus_t stat = ZFailure;
    556          
    557              if ( (pMsg = (osal_event_hdr_t *)osal_msg_receive( task_id )) != NULL )
    558              {
    559                switch ( pMsg->event )
    560                {
    561          
    562          #if (ZSTACK_ROUTER_BUILD)
    563                  case ZDO_CB_MSG:
    564                    // ZDO sends the message that we registered for
    565                    touchLink_RouterProcessZDOMsg( (zdoIncomingMsg_t *)pMsg );
    566                    stat = ZSuccess;
    567                    break;
    568          #endif
    569                  case ZDO_STATE_CHANGE:
    570                    initiatorProcessStateChange( (devStates_t)pMsg->status );
    571                    stat = ZSuccess;
    572                    break;
    573          
    574                  default:
    575                    break;
    576                }
    577          
    578                if ( stat == ZSuccess )
    579                {
    580                  // Release the OSAL message
    581                  VOID osal_msg_deallocate( (uint8 *)pMsg );
    582                }
    583                else
    584                {
    585                  // forward to the application
    586                  osal_msg_send( initiatorRegisteredMsgAppTaskID, (uint8 *)pMsg );
    587                }
    588              }
    589          
    590              // return unprocessed events
    591              return ( events ^ SYS_EVENT_MSG );
    592            }
    593          
    594            if ( events & TOUCHLINK_TL_SCAN_BASE_EVT )
    595            {
    596              if ( ( ( scanReqChannels == TOUCHLINK_SCAN_PRIMARY_CHANNELS ) && ( numScanReqSent < TOUCHLINK_INITIATOR_NUM_SCAN_REQ_PRIMARY  ) ) ||
    597                   ( ( scanReqChannels == TOUCHLINK_SCAN_SECONDARY_CHANNELS ) && ( numScanReqSent < TOUCHLINK_INITIATOR_NUM_SCAN_REQ_EXTENDED ) ) )
    598              {
    599                // Send another Scan Request on the next channel
    600                initiatorSendScanReq( FALSE );
    601              }
    602              else // Channels scan is complete
    603              {
    604                if ( ( scanReqChannels == TOUCHLINK_SCAN_PRIMARY_CHANNELS ) && ( bdbAttributes.bdbNodeIsOnANetwork == FALSE ) )
    605                {
    606                  // Extended scan is required, lets scan secondary channels
    607                  scanReqChannels = TOUCHLINK_SCAN_SECONDARY_CHANNELS;
    608          
    609                  // Send another Scan Request on the next channel
    610                  initiatorSendScanReq( FALSE );
    611                }
    612                // See if we've received any Scan Responses back
    613                else if ( ( selectedTarget.lastRssi != TOUCHLINK_WORST_RSSI )
    614                         && ( selectedTarget.scanRsp.deviceInfo.endpoint != DEV_INFO_INVALID_EP ) )
    615                {
    616                  // Make sure the responder is not a factory new initiator if this device is also 
    617                  // factory new
    618                  if ( ( selectedTarget.scanRsp.touchLinkInitiator == FALSE ) ||
    619                       ( bdbAttributes.bdbNodeIsOnANetwork == TRUE ) )
    620                  {
    621                    bdbTLIdentifyReq_t req;
    622          
    623                    // Tune to the channel that the Scan Response was heard on
    624                    touchLink_SetChannel( selectedTarget.rxChannel );
    625          
    626                    req.transID = selectedTarget.scanRsp.transID;
    627                    req.IdDuration = BDB_TL_IDENTIFY_TIME;
    628                    
    629                    if ( touchlinkFNReset == TRUE )
    630                    {
    631                      osal_set_event( touchLinkInitiator_TaskID, TOUCHLINK_CFG_TARGET_EVT );
    632                      return ( events ^ TOUCHLINK_TL_SCAN_BASE_EVT );
    633                    }
    634                    
    635                    bdbTL_Send_IndentifyReq( TOUCHLINK_INTERNAL_ENDPOINT, &(selectedTarget.srcAddr), &req, initiatorSeqNum++ );
    636          
    637          #if ZSTACK_ROUTER_BUILD
    638                    uint8 i = 0;
    639                      
    640                    while ( !CHECK_BIT ( selectedTarget.scanRsp.keyBitmask , i ) ) 
    641                    {
    642                      i++;
    643                    }
    644              
    645                    initiatorNwkParams.keyIndex = i;
    646                    zTouchLinkNwkStartRtr = TRUE;
    647                    // Disabe other TouchLink events
    648                    osal_set_event( touchLinkInitiator_TaskID, TOUCHLINK_DISABLE_RX_EVT );
    649          #endif
    650                    osal_start_timerEx( touchLinkInitiator_TaskID, TOUCHLINK_CFG_TARGET_EVT, TOUCHLINK_INITIATOR_IDENTIFY_INTERVAL );
    651                  }
    652                  // else wait for touch-link commands from the other initiator
    653                }
    654                else
    655                {
    656                  // We did not manage to select any target
    657                  // Let's just go back to our initial configuration
    658                  osal_set_event( touchLinkInitiator_TaskID, TOUCHLINK_DISABLE_RX_EVT );
    659                  bdbAttributes.bdbCommissioningStatus = BDB_COMMISSIONING_TL_NO_SCAN_RESPONSE;
    660                  bdb_reportCommissioningState( BDB_COMMISSIONING_STATE_TL, FALSE );
    661                }
    662              }
    663          
    664              // return unprocessed events
    665              return ( events ^ TOUCHLINK_TL_SCAN_BASE_EVT );
    666            }
    667          
    668            if ( events & TOUCHLINK_CFG_TARGET_EVT )
    669            {
    670              ZStatus_t status = ZFailure;
    671          
    672              bdbTLIdentifyReq_t req;
    673          
    674              req.transID = selectedTarget.scanRsp.transID;
    675              req.IdDuration = 0x00;
    676              uint8 tcExtAddr[Z_EXTADDR_LEN];
    677              uint8 DistributedSecurityNwkAddress[Z_EXTADDR_LEN] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };
    678                  
    679              if ( zTouchLinkNwkStartRtr == FALSE )
    680              {
    681                // Send an Identify stop Request
    682                bdbTL_Send_IndentifyReq( TOUCHLINK_INTERNAL_ENDPOINT, &(selectedTarget.srcAddr), &req, initiatorSeqNum++ );
    683              }
    684              
    685             // See if the target is part of our network
    686              if ( !TOUCHLINK_SAME_NWK( selectedTarget.scanRsp.PANID, selectedTarget.scanRsp.extendedPANID ) )
    687              {
    688                // If the local device is not the trust center, always return TRUE
    689                status = APSME_GetRequest( apsTrustCenterAddress, 0, tcExtAddr );
    690                  
    691                // Notify BDB state machine
    692                if ( bdbAttributes.bdbNodeIsOnANetwork == TRUE )
    693                {
    694                  if ( ( status == ZSuccess ) && ( !osal_ExtAddrEqual( DistributedSecurityNwkAddress, tcExtAddr ) ) )
    695                  {
    696                    bdbAttributes.bdbCommissioningStatus = BDB_COMMISSIONING_TL_NOT_PERMITTED;
    697                    bdb_reportCommissioningState( BDB_COMMISSIONING_STATE_TL, FALSE );
    698                    return ( events ^ TOUCHLINK_CFG_TARGET_EVT );
    699                  }
    700                }
    701                      
    702                // verify address ranges split possible if required
    703                if ( !touchLink_IsValidSplitFreeRanges( selectedTarget.scanRsp.totalGrpIDs ) )
    704                {
    705                  bdbAttributes.bdbCommissioningStatus = BDB_COMMISSIONING_TL_NOT_AA_CAPABLE;
    706                  bdb_reportCommissioningState( BDB_COMMISSIONING_STATE_TL, FALSE );
    707                  return ( events ^ TOUCHLINK_CFG_TARGET_EVT );
    708                }
    709                
    710                if ( touchlinkFNReset == TRUE )
    711                {
    712                  touchlinkFNReset = FALSE;
    713                  touchLinkInitiator_ResetToFNSelectedTarget( );
    714                  osal_set_event( touchLinkInitiator_TaskID, TOUCHLINK_DISABLE_RX_EVT );
    715                  
    716                  return ( events ^ TOUCHLINK_CFG_TARGET_EVT );
    717                }
    718                  
    719                if ( bdbAttributes.bdbNodeIsOnANetwork == TRUE )
    720                {
    721                  // Ask the target to join our network
    722                  osal_start_timerEx( touchLinkInitiator_TaskID, TOUCHLINK_NWK_FORMATION_SUCCESS_EVT, 50);
    723                  zTouchLinkNwkStartRtr = FALSE;
    724                  return ( events ^ TOUCHLINK_CFG_TARGET_EVT );
    725                }
    726                else if ( ZSTACK_ROUTER_BUILD == TRUE )
    727                {
    728                  // Tune to the channel that the Scan Response was heard on
    729                  touchLink_SetChannel( selectedTarget.rxChannel );
    730                  
    731                  // Try to form a new network
    732                  osal_set_event( touchLinkInitiator_TaskID, TOUCHLINK_NWK_RTR_START_EVT);
    733                  return ( events ^ TOUCHLINK_CFG_TARGET_EVT );
    734                }
    735                else if ( ZSTACK_ROUTER_BUILD == FALSE )
    736                {
    737                  if ( selectedTarget.scanRsp.zLogicalType == ZG_DEVICETYPE_ROUTER )
    738                  {
    739                    if ( bdbAttributes.bdbNodeIsOnANetwork == FALSE )
    740                    {
    741                      _NIB.nwkDevAddress = APL_FREE_NWK_ADDR_RANGE_BEGIN;
    742                    }
    743                    
    744                    // Must be the first light; ask the light to start the network
    745                    status = initiatorSendNwkStartReq( &(selectedTarget.scanRsp) );
    746                  }
    747                  else
    748                  {
    749                    // Notify the BDB state machine 
    750                    bdbAttributes.bdbCommissioningStatus = BDB_COMMISSIONING_NO_NETWORK;
    751                    bdb_reportCommissioningState( BDB_COMMISSIONING_STATE_TL, FALSE );
    752                    return ( events ^ TOUCHLINK_CFG_TARGET_EVT );
    753                  }
    754                }
    755              }
    756              
    757              else if ( _NIB.nwkUpdateId != selectedTarget.scanRsp.nwkUpdateId )
    758              {
    759                // Set NWK task to run
    760                nwk_setStateIdle( TRUE );
    761                
    762                // Target is already part of our network
    763                if ( selectedTarget.scanRsp.nwkUpdateId > _NIB.nwkUpdateId )
    764                {
    765                  // Update our network update id and logical channel
    766                  touchLink_ProcessNwkUpdate( selectedTarget.scanRsp.nwkUpdateId, selectedTarget.scanRsp.logicalChannel );
    767          
    768                  // We're done here
    769                  status = ZSuccess;
    770                }
    771                else if ( selectedTarget.scanRsp.nwkUpdateId < _NIB.nwkUpdateId )
    772                {
    773                  // Inform the target to update its network update id and logical channel
    774                  initiatorSendNwkUpdateReq( &(selectedTarget.scanRsp) ); // there's no corresponding response!
    775          
    776                  // Notify the application about this device
    777                  osal_set_event( touchLinkInitiator_TaskID, TOUCHLINK_NOTIFY_APP_EVT );
    778                }
    779                
    780                bdbAttributes.bdbCommissioningStatus = BDB_COMMISSIONING_SUCCESS;
    781                bdb_reportCommissioningState( BDB_COMMISSIONING_STATE_TL, TRUE );
    782                return ( events ^ TOUCHLINK_CFG_TARGET_EVT );
    783              }
    784              
    785              //we are touchlinking to a light in our network, just send application the device info
    786              else if ( selectedTarget.scanRsp.touchLinkInitiator == FALSE )
    787              {
    788                epInfoRec_t rec;
    789                rec.nwkAddr = selectedTarget.scanRsp.nwkAddr;
    790                rec.endpoint = selectedTarget.scanRsp.deviceInfo.endpoint;
    791                rec.profileID = selectedTarget.scanRsp.deviceInfo.profileID;
    792                rec.deviceID = selectedTarget.scanRsp.deviceInfo.deviceID;
    793                rec.version = selectedTarget.scanRsp.deviceInfo.version;
    794                // Notify the application
    795                if ( pfnNotifyAppCB )
    796                {
    797                  (*pfnNotifyAppCB)( &rec );
    798                }
    799                bdbAttributes.bdbCommissioningStatus = BDB_COMMISSIONING_SUCCESS;
    800                bdb_reportCommissioningState( BDB_COMMISSIONING_STATE_TL, TRUE );
    801              }
    802          
    803              // return unprocessed events
    804              return ( events ^ TOUCHLINK_CFG_TARGET_EVT );
    805            }
    806          
    807            if ( events & TOUCHLINK_W4_NWK_START_RSP_EVT )
    808            {
    809              bdbTLNwkStartRsp_t *pRsp = &(rxRsp.nwkStartRsp);
    810          
    811              // Look if we have a valid response
    812              if ( ( pRsp->status == TOUCHLINK_NETWORK_START_RSP_STATUS_SUCCESS )
    813                 && ( ( nwk_ExtPANIDValid( pRsp->extendedPANID ) ) && ( touchLink_IsValidTransID( pRsp->transID ) ) ) )
    814              {
    815                // Copy the new network parameters to NIB
    816                touchLink_SetNIB( ( ZSTACK_ROUTER_BUILD ? NWK_ROUTER : NWK_REJOINING ),
    817                            _NIB.nwkDevAddress, pRsp->extendedPANID,
    818                            pRsp->logicalChannel, pRsp->panId, pRsp->nwkUpdateId );
    819          
    820                // Apply the received network key
    821                touchLink_DecryptNwkKey( encKeySent, keyIndexSent, pRsp->transID, responseIDSent );
    822          
    823                // This is not a usual Trust Center protected network
    824                ZDSecMgrUpdateTCAddress( NULL );
    825          
    826                // Notify the application about this device
    827                osal_set_event( touchLinkInitiator_TaskID, TOUCHLINK_NOTIFY_APP_EVT );
    828          
    829                // Wait at least BDBCTL_MIN_STARTUP_DELAY_TIME seconds to allow the
    830                // target to start the network correctly. Join the target afterwards.
    831                osal_start_timerEx( touchLinkInitiator_TaskID, TOUCHLINK_START_NWK_EVT, BDBCTL_MIN_STARTUP_DELAY_TIME );
    832              }
    833              else
    834              {
    835                // Notify the BDB state machine 
    836                bdbAttributes.bdbCommissioningStatus = BDB_COMMISSIONING_NO_NETWORK;
    837                bdb_reportCommissioningState( BDB_COMMISSIONING_STATE_TL, FALSE );        
    838              }
    839          
    840              // return unprocessed events
    841              return ( events ^ TOUCHLINK_W4_NWK_START_RSP_EVT );
    842            }
    843          
    844            if ( events & TOUCHLINK_START_NWK_EVT )
    845            {
    846              // Rejoins without NWK scan
    847          
    848              bdbTLNwkStartRsp_t *pRsp = &(rxRsp.nwkStartRsp);
    849              bdbTLNwkRejoin_t rejoinInf;
    850              
    851              rejoinInf.panId = pRsp->panId;
    852              rejoinInf.logicalChannel = pRsp->logicalChannel;
    853              osal_memcpy( rejoinInf.extendedPANID, pRsp->extendedPANID, Z_EXTADDR_LEN);
    854              rejoinInf.nwkAddr = selectedTargetNwkAddr;
    855              rejoinInf.nwkUpdateId = pRsp->nwkUpdateId;
    856                
    857              touchLink_DevRejoin( &rejoinInf );
    858          
    859              // return unprocessed events
    860              return ( events ^ TOUCHLINK_START_NWK_EVT );
    861            }
    862          
    863            if ( events & TOUCHLINK_W4_NWK_JOIN_RSP_EVT )
    864            {
    865              bdbTLNwkJoinRsp_t *pRsp = &(rxRsp.nwkJoinRsp);
    866          
    867              if ( pRsp->status == TOUCHLINK_NETWORK_JOIN_RSP_STATUS_SUCCESS )
    868              {
    869                // Wait at least BDBCTL_MIN_STARTUP_DELAY_TIME seconds to allow the
    870                // target to start operating on the network correctly. Notify the
    871                // application afterwards.
    872                osal_start_timerEx( touchLinkInitiator_TaskID, TOUCHLINK_NOTIFY_APP_EVT,
    873                                    BDBCTL_MIN_STARTUP_DELAY_TIME );
    874                
    875                // Establish bind links
    876                if ( pRespondentHead != NULL )
    877                {
    878                  AddrMgrEntry_t entry;
    879          
    880                  // add the device's address information
    881                  entry.user    = ADDRMGR_USER_BINDING;
    882                  entry.nwkAddr = selectedTargetNwkAddr;
    883                  osal_cpyExtAddr( entry.extAddr, selectedTargetIEEEAddr );
    884                  AddrMgrEntryUpdate( &entry );
    885                  osal_start_timerEx( bdb_TaskID, BDB_RESPONDENT_PROCESS_TIMEOUT, SIMPLEDESC_RESPONSE_TIMEOUT );
    886                }
    887                
    888                // We're done with touch-link procedure here
    889                initiatorSetNwkToInitState();
    890                //bdbAttributes.bdbCommissioningStatus = BDB_COMMISSIONING_SUCCESS;
    891                //bdb_reportCommissioningState( BDB_COMMISSIONING_STATE_TL, TRUE );
    892          
    893                touchLink_UpdateNV( TOUCHLINK_UPDATE_NV_RANGES );
    894          
    895                if ( ( POLL_RATE == 0 ) && ( selectedTarget.scanRsp.zLogicalType == ZG_DEVICETYPE_ENDDEVICE ) )
    896                {
    897                  //allow to respond to TOUCHLINK commission utility commands after TL
    898                  NLME_SetPollRate( TOUCHLINK_INITIATOR_TEMP_POST_TL_POLL_RATE );
    899                  //polling should reset when TL life time expires
    900                }
    901              }
    902              else 
    903              {
    904                touchLink_SendLeaveReq( );
    905                bdbAttributes.bdbCommissioningStatus = BDB_COMMISSIONING_TL_TARGET_FAILURE;
    906                bdb_reportCommissioningState( BDB_COMMISSIONING_STATE_TL, FALSE );
    907              }
    908          
    909              // return unprocessed events
    910              return ( events ^ TOUCHLINK_W4_NWK_JOIN_RSP_EVT );
    911            }
    912          
    913            if ( events & TOUCHLINK_NWK_JOIN_IND_EVT )
    914            {
    915              // If not factory new, perform a Leave on our old network
    916              if ( ( bdbAttributes.bdbNodeIsOnANetwork == TRUE ) && ( touchLink_SendLeaveReq( ) == ZSuccess ) )
    917              {
    918                // Wait for Leave confirmation before joining the new network
    919                touchLinkLeaveInitiated = TOUCHLINK_LEAVE_TO_JOIN_NWK;
    920              }
    921              else
    922              {
    923          #if ( ZSTACK_ROUTER_BUILD )
    924                // Notify our task to join this network
    925                osal_set_event( touchLinkInitiator_TaskID, TOUCHLINK_JOIN_NWK_ATTEMPT_EVT );
    926          #else
    927                bdbTLNwkParams_t *pParams = &(joinReq.nwkParams);
    928                
    929                // Notify our task to join this network
    930                // Perform Network Discovery to verify our new network parameters uniqeness
    931                touchLink_PerformNetworkDisc( (uint32)1 << pParams->logicalChannel );
    932          #endif
    933              }
    934          
    935              // return unprocessed events
    936              return ( events ^ TOUCHLINK_NWK_JOIN_IND_EVT );
    937            }
    938          
    939            if ( events & TOUCHLINK_JOIN_NWK_ATTEMPT_EVT )
    940            {
    941              // Join the network
    942          #if ( ZSTACK_ROUTER_BUILD )
    943              initiatorJoinNwk();
    944          #else
    945              bdbTLNwkParams_t *pParams = &(joinReq.nwkParams);
    946              
    947              bdbTLNwkRejoin_t rejoinInf;
    948                   
    949              rejoinInf.panId = pParams->panId;
    950              rejoinInf.logicalChannel = pParams->logicalChannel;
    951              osal_memcpy( rejoinInf.extendedPANID, pParams->extendedPANID, Z_EXTADDR_LEN);
    952              rejoinInf.nwkAddr = pDiscoveredNwkParamList->chosenRouter;
    953              rejoinInf.nwkUpdateId = joinReq.nwkUpdateId;
    954                
    955              touchLink_DevRejoin( &rejoinInf );
    956          #endif
    957              touchLink_FreeNwkParamList();
    958          
    959              // return unprocessed events
    960              return ( events ^ TOUCHLINK_JOIN_NWK_ATTEMPT_EVT );
    961            }
    962          
    963            if ( events & TOUCHLINK_DISABLE_RX_EVT )
    964            {
    965              // We're not asked to join a network
    966              initiatorSetNwkToInitState();
    967          
    968              scanReqChannels = TOUCHLINK_SCAN_PRIMARY_CHANNELS;
    969              numScanReqSent = 0;
    970              // Reset selected target
    971              if ( zTouchLinkNwkStartRtr == FALSE )
    972              {
    973                initiatorClearSelectedTarget();
    974              }
    975          
    976              // return unprocessed events
    977              return ( events ^ TOUCHLINK_DISABLE_RX_EVT );
    978            }
    979          
    980            if ( events & TOUCHLINK_W4_REJOIN_EVT )
    981            {
    982              // Stop joining cycle
    983              ZDApp_StopJoiningCycle();
    984          
    985              // return unprocessed events
    986              return ( events ^ TOUCHLINK_W4_REJOIN_EVT );
    987            }
    988          
    989            if ( events & TOUCHLINK_NOTIFY_APP_EVT )
    990            {
    991              ZDP_DeviceAnnce( NLME_GetShortAddr(), NLME_GetExtAddr(),
    992                               ZDO_Config_Node_Descriptor.CapabilityFlags, 0 );
    993              
    994              if ( selectedTarget.lastRssi > TOUCHLINK_WORST_RSSI )
    995              {
    996                epInfoRec_t rec;
    997                rec.nwkAddr = selectedTarget.newNwkAddr; // newly assigned network address
    998                rec.endpoint = selectedTarget.scanRsp.deviceInfo.endpoint;
    999                rec.profileID = selectedTarget.scanRsp.deviceInfo.profileID;
   1000                rec.deviceID = selectedTarget.scanRsp.deviceInfo.deviceID;
   1001                rec.version = selectedTarget.scanRsp.deviceInfo.version;
   1002                // Notify the application
   1003                if ( pfnNotifyAppCB )
   1004                {
   1005                  (*pfnNotifyAppCB)( &rec );
   1006                }
   1007              }
   1008              // return unprocessed events
   1009              return ( events ^ TOUCHLINK_NOTIFY_APP_EVT );
   1010            }
   1011            
   1012            if ( events & TOUCHLINK_NWK_RTR_START_EVT )
   1013            {
   1014              uint16 nwkAddr = INVALID_NODE_ADDR;
   1015              
   1016              osal_nv_write( ZCD_NV_NIB, osal_offsetof( nwkIB_t, nwkDevAddress ),
   1017                             sizeof( uint16), &nwkAddr );
   1018              
   1019              // If the PAN Id, Extended PAN Id or Logical Channel are zero then
   1020              // determine each of these parameters
   1021              if ( !nwk_ExtPANIDValid( initiatorNwkParams.extendedPANID ) )
   1022              {
   1023                touchLink_GenerateRandNum( initiatorNwkParams.extendedPANID, Z_EXTADDR_LEN );
   1024              }
   1025          
   1026              if ( initiatorNwkParams.panId == 0 )
   1027              {
   1028                initiatorNwkParams.panId = osal_rand();
   1029              }
   1030          
   1031              if ( initiatorNwkParams.logicalChannel == 0 )
   1032              {
   1033                initiatorNwkParams.logicalChannel = touchLink_GetRandPrimaryChannel();
   1034              }
   1035          
   1036              if ( selectedTarget.scanRsp.touchLinkAddressAssignment)
   1037              {
   1038                touchLink_GerFreeRanges( &initiatorNwkParams );
   1039              }
   1040          
   1041              // Perform Network Discovery to verify our new network parameters uniqeness
   1042              touchLink_PerformNetworkDisc( (uint32)1 << initiatorNwkParams.logicalChannel );
   1043          
   1044              // return unprocessed events
   1045              return ( events ^ TOUCHLINK_NWK_RTR_START_EVT );
   1046            }
   1047            
   1048            if ( events & TOUCHLINK_NWK_FORMATION_SUCCESS_EVT )
   1049            {
   1050              if( bdbCommissioningProcedureState.bdbCommissioningState == BDB_COMMISSIONING_STATE_TL )
   1051              {
   1052                bdbTLNwkJoinRsp_t *pRsp = &(rxRsp.nwkJoinRsp);
   1053                pRsp->status = TOUCHLINK_NETWORK_JOIN_RSP_STATUS_FAILURE;
   1054                
   1055                // Tune to the channel that the Scan Response was heard on
   1056                touchLink_SetChannel( selectedTarget.rxChannel );
   1057                
   1058                if ( _NIB.nwkUpdateId <= selectedTarget.scanRsp.nwkUpdateId )
   1059                {
   1060                  NLME_SetUpdateID( selectedTarget.scanRsp.nwkUpdateId );
   1061                }
   1062                // Ask the target to join our network
   1063                bdb_Initiator_SendNwkJoinReq( );
   1064                zTouchLinkNwkStartRtr = FALSE;
   1065              }
   1066              return ( events ^ TOUCHLINK_NWK_FORMATION_SUCCESS_EVT );
   1067            }
   1068          
   1069            if ( events & TOUCHLINK_NWK_DISC_CNF_EVT )
   1070            {
   1071          #if ZSTACK_ROUTER_BUILD
   1072              if ( bdbAttributes.bdbNodeIsOnANetwork == FALSE )
   1073              {
   1074                initiatorNwkParams.nwkAddr = APL_FREE_NWK_ADDR_RANGE_BEGIN;
   1075              }
   1076              // Copy in the encrypted network key
   1077              touchLink_EncryptNwkKey( initiatorNwkParams.nwkKey, initiatorNwkParams.keyIndex, touchLinkTransID, touchLinkResponseID );
   1078              // Start operating on the new network
   1079              touchLinkStartRtr( &initiatorNwkParams, touchLinkTransID );
   1080          #else
   1081              // Join to the chosen network
   1082              osal_set_event( touchLinkInitiator_TaskID, TOUCHLINK_JOIN_NWK_ATTEMPT_EVT );
   1083          #endif
   1084              // return unprocessed events
   1085              return ( events ^ TOUCHLINK_NWK_DISC_CNF_EVT );
   1086            }
   1087          
   1088            if ( events & TOUCHLINK_TRANS_LIFETIME_EXPIRED_EVT )
   1089            {
   1090              touchLinkTransID = 0;
   1091              initiatorClearSelectedTarget();
   1092              initiatorSetNwkToInitState();
   1093          
   1094              // return unprocessed events
   1095              return ( events ^ TOUCHLINK_TRANS_LIFETIME_EXPIRED_EVT );
   1096            }
   1097          
   1098            // If reach here, the events are unknown
   1099            // Discard or make more handlers
   1100            return 0;
   1101          }
   1102          
   1103          /*********************************************************************
   1104           * @fn      touchLinkInitiator_ChannelChange
   1105           *
   1106           * @brief   Change channel to supprot Frequency agility.
   1107           *
   1108           * @param   targetChannel - channel to
   1109           *
   1110           * @return  status
   1111           */
   1112          ZStatus_t touchLinkInitiator_ChannelChange( uint8 targetChannel )
   1113          {
   1114              uint32 channelMask;
   1115              zAddrType_t dstAddr = {0};
   1116              if ( ( targetChannel < 11 ) || targetChannel > 26 )
   1117              {
   1118                if (TOUCHLINK_PRIMARY_CHANNEL (_NIB.nwkLogicalChannel))
   1119                {
   1120                  switch (_NIB.nwkLogicalChannel)
   1121                  {
   1122                  case TOUCHLINK_FIRST_CHANNEL:
   1123                    targetChannel = TOUCHLINK_SECOND_CHANNEL;
   1124                    break;
   1125                  case TOUCHLINK_SECOND_CHANNEL:
   1126                    targetChannel = TOUCHLINK_THIRD_CHANNEL;
   1127                    break;
   1128                  case TOUCHLINK_THIRD_CHANNEL:
   1129                    targetChannel = TOUCHLINK_FOURTH_CHANNEL;
   1130                    break;
   1131                  case TOUCHLINK_FOURTH_CHANNEL:
   1132                    targetChannel = TOUCHLINK_FIRST_CHANNEL;
   1133                  }
   1134                }
   1135                else
   1136                {
   1137                  targetChannel = _NIB.nwkLogicalChannel + 1;
   1138                  if ( _NIB.nwkLogicalChannel > 26 )
   1139                    targetChannel = 11;
   1140                }
   1141              }
   1142          
   1143              dstAddr.addrMode = AddrBroadcast;
   1144              dstAddr.addr.shortAddr = NWK_BROADCAST_SHORTADDR_DEVRXON;
   1145              channelMask = (uint32)1 << targetChannel;
   1146          
   1147              // Increment the nwkUpdateId parameter and set the updateID in the beacon
   1148              NLME_SetUpdateID(_NIB.nwkUpdateId + 1);
   1149          
   1150              ZDP_MgmtNwkUpdateReq( &dstAddr, channelMask, 0xfe, 0, _NIB.nwkUpdateId, 0 );
   1151          
   1152              return ZSuccess;
   1153          }
   1154          
   1155          /*********************************************************************
   1156           * @fn      touchLinkSampleRemote_SendEPInfo
   1157           *
   1158           * @brief   Send Endpoint info command.
   1159           *
   1160           * @param   srcEP - source endpoint
   1161           * @param   dstAddr - destination address
   1162           * @param   seqNum - transaction sequnece number
   1163           *
   1164           * @return  ZStatus_t
   1165           */
   1166          ZStatus_t touchLinkInitiator_SendEPInfo( uint8 srcEP, afAddrType_t *dstAddr, uint8 seqNum)
   1167          {
   1168              bdbTLEndpointInfo_t bdbTLEndpointInfoCmd;
   1169              bdbTLDeviceInfo_t  bdbTLDeviceInfo;
   1170                //send Epinfo cmd
   1171              touchLink_GetSubDeviceInfo( 0, &bdbTLDeviceInfo );
   1172              bdbTLEndpointInfoCmd.endpoint = bdbTLDeviceInfo.endpoint;
   1173              bdbTLEndpointInfoCmd.profileID = bdbTLDeviceInfo.profileID;
   1174              bdbTLEndpointInfoCmd.deviceID = bdbTLDeviceInfo.deviceID;
   1175              bdbTLEndpointInfoCmd.version = bdbTLDeviceInfo.version;
   1176          
   1177              osal_cpyExtAddr( bdbTLEndpointInfoCmd.ieeeAddr, NLME_GetExtAddr() );
   1178              bdbTLEndpointInfoCmd.nwkAddr = NLME_GetShortAddr();
   1179          
   1180              dstAddr->panId = _NIB.nwkPanId;
   1181              return bdbTL_Send_EndpointInfo( srcEP, dstAddr, &bdbTLEndpointInfoCmd,
   1182                                                    0, seqNum );
   1183          }
   1184          
   1185          /*********************************************************************
   1186           * @fn      touchLinkInitiator_ResetToFNSelectedTarget
   1187           *
   1188           * @brief   Send Reset to Factory New Request command to the selected
   1189           *          target of the current Touch-Link transaction.
   1190           *          Note - this function should be called within no later than
   1191           *          BDBCTL_INTER_PAN_TRANS_ID_LIFETIME ms from the Scan Request.
   1192           *
   1193           * @param   none
   1194           *
   1195           * @return  status - failure is returned due to invalid selected target or
   1196           *          expired Touch-Link transaction.
   1197           */
   1198          ZStatus_t touchLinkInitiator_ResetToFNSelectedTarget( void )
   1199          {
   1200            bdbTLResetToFNReq_t req;
   1201            req.transID = touchLinkTransID;
   1202          
   1203            // Cancel further touch-link commissioning (if called during identify interval)
   1204            osal_stop_timerEx( touchLinkInitiator_TaskID, TOUCHLINK_CFG_TARGET_EVT );
   1205          
   1206            touchLink_SetChannel( selectedTarget.rxChannel );
   1207            return bdbTL_Send_ResetToFNReq( TOUCHLINK_INTERNAL_ENDPOINT, &(selectedTarget.srcAddr), &req, initiatorSeqNum++ );
   1208          }
   1209          
   1210          /*********************************************************************
   1211           * @fn      touchLink_InitiatorSendScanRsp
   1212           *
   1213           * @brief   Send out a Scan Response command.
   1214           *
   1215           * @param   srcEP - sender's endpoint
   1216           * @param   dstAddr - pointer to destination address struct
   1217           * @param   transID - received transaction id
   1218           * @param   seqNum - received sequence number
   1219           *
   1220           * @return  ZStatus_t
   1221           */
   1222          static ZStatus_t touchLink_InitiatorSendScanRsp( uint8 srcEP, afAddrType_t *dstAddr, uint32 transID, uint8 seqNum )
   1223          {
   1224            ZStatus_t status = ZSuccess;
   1225          
   1226            // Make sure we respond only once during a Device Discovery
   1227            if ( touchLinkLastAcceptedTransID != transID )
   1228            {
   1229              bdbTLScanRsp_t *pRsp;    
   1230          
   1231              pRsp = (bdbTLScanRsp_t *)osal_mem_alloc( sizeof( bdbTLScanRsp_t ) );
   1232              if ( pRsp )
   1233              {
   1234                osal_memset( pRsp, 0, sizeof( bdbTLScanRsp_t ) );
   1235          
   1236                // Save transaction id
   1237                touchLinkLastAcceptedTransID = transID;
   1238                osal_start_timerEx( touchLinkInitiator_TaskID, TOUCHLINK_TRANS_LIFETIME_EXPIRED_EVT,
   1239                                    BDBCTL_INTER_PAN_TRANS_ID_LIFETIME );
   1240          
   1241                pRsp->transID = transID;
   1242                pRsp->rssiCorrection = TOUCHLINK_RSSI_CORRECTION;
   1243                pRsp->zLogicalType = zgDeviceLogicalType;
   1244                pRsp->touchLinkAddressAssignment = touchLink_IsValidSplitFreeRanges( 0 );
   1245                pRsp->touchLinkInitiator = TRUE;
   1246                pRsp->touchLinkProfileInterop = TRUE;
   1247          
   1248                if ( ZDO_Config_Node_Descriptor.CapabilityFlags & CAPINFO_RCVR_ON_IDLE )
   1249                {
   1250                  pRsp->zRxOnWhenIdle = TRUE;
   1251                }
   1252          
   1253                pRsp->touchLinklinkPriority = FALSE;
   1254                pRsp->keyBitmask = touchLink_GetNwkKeyBitmask();
   1255          
   1256                // Generate a new Response ID
   1257                touchLinkResponseID = ( ((uint32)osal_rand()) << 16 ) + osal_rand();
   1258                pRsp->responseID = touchLinkResponseID;
   1259          
   1260                pRsp->touchLinkFactoryNew = !bdbAttributes.bdbNodeIsOnANetwork;
   1261                if ( pRsp->touchLinkFactoryNew )
   1262                {
   1263                  pRsp->nwkAddr = 0xFFFF;
   1264                  pRsp->nwkUpdateId = 0;
   1265                }
   1266                else
   1267                {
   1268                  pRsp->nwkAddr = _NIB.nwkDevAddress;
   1269                  pRsp->nwkUpdateId = _NIB.nwkUpdateId;
   1270                }
   1271                pRsp->PANID = _NIB.nwkPanId;
   1272                pRsp->logicalChannel = _NIB.nwkLogicalChannel;
   1273                osal_cpyExtAddr( pRsp->extendedPANID, _NIB.extendedPANID );
   1274          
   1275                pRsp->numSubDevices = touchLink_GetNumSubDevices( 0 );
   1276                if ( pRsp->numSubDevices == 1 )
   1277                {
   1278                  touchLink_GetSubDeviceInfo( 0, &(pRsp->deviceInfo) );
   1279                }
   1280          
   1281                pRsp->totalGrpIDs = touchLink_GetNumGrpIDs();
   1282          
   1283                // Send a response back
   1284                status = bdbTL_Send_ScanRsp( srcEP, dstAddr, pRsp, seqNum );
   1285          
   1286                osal_mem_free( pRsp );
   1287              }
   1288              else
   1289              {
   1290                status = ZMemError;
   1291              }
   1292            }
   1293          
   1294            return ( status );
   1295          }
   1296          
   1297          /*********************************************************************
   1298           * @fn      bdb_Initiator_SendNwkJoinReq
   1299           *
   1300           * @brief   Send out a Network Join Router or End Device Request command.
   1301           *          using the selected Target.
   1302           *
   1303           * @param   -
   1304           *
   1305           * @return  ZStatus_t
   1306           */
   1307          ZStatus_t bdb_Initiator_SendNwkJoinReq( void )
   1308          {
   1309            // Set NWK task to idle
   1310            nwk_setStateIdle( TRUE );
   1311            return initiatorSendNwkJoinReq( &(selectedTarget.scanRsp) );
   1312          }  
   1313          
   1314          #if (ZSTACK_ROUTER_BUILD)
   1315          /*********************************************************************
   1316           * @fn      touchLinkInitiator_PermitJoin
   1317           *
   1318           * @brief   Set the router permit join flag, to allow or deny classical
   1319           *          commissioning by other ZigBee devices.
   1320           *
   1321           * @param   duration - enable up to aplcMaxPermitJoinDuration seconds,
   1322           *                     0 to disable
   1323           *
   1324           * @return  status
   1325           */
   1326          ZStatus_t touchLinkInitiator_PermitJoin( uint8 duration )
   1327          {
   1328            return touchLink_PermitJoin( duration );
   1329          }  
   1330          #endif //(ZSTACK_ROUTER_BUILD)
   1331          
   1332          /*********************************************************************
   1333           * LOCAL FUNCTIONS
   1334           */
   1335          
   1336          /*********************************************************************
   1337           * @fn      initiatorScanReqCB
   1338           *
   1339           * @brief   This callback is called to process a Scan Request command.
   1340           *
   1341           * @param   srcAddr - sender's address
   1342           * @param   pReq - parsed command
   1343           * @param   seqNum - command sequence number
   1344           *
   1345           * @return  ZStatus_t
   1346           */
   1347          static ZStatus_t initiatorScanReqCB( afAddrType_t *srcAddr, bdbTLScanReq_t *pReq, uint8 seqNum )
   1348          {
   1349            int8 rssi;
   1350            rssi = touchLink_GetMsgRssi();
   1351            if( ( rssi > TOUCHLINK_WORST_RSSI ) && ( pReq->touchLinkInitiator == TRUE ) )
   1352            {
   1353              // response to the originator, but switch to dst PAN 0xFFFF
   1354              afAddrType_t dstAddr;
   1355              osal_memcpy(&dstAddr, srcAddr, sizeof(afAddrType_t));
   1356              dstAddr.panId = 0xFFFF;
   1357          
   1358              // If we are factory new and revice a Scan Request from other factory new
   1359              // device then drop the request.
   1360              if ( ( pReq->touchLinkFactoryNew == TRUE ) && ( bdbAttributes.bdbNodeIsOnANetwork == FALSE ) )
   1361              {
   1362                return ( ZSuccess );
   1363              }
   1364              // If, during its scan, a non factory new initiator receives another scan
   1365              // request inter-PAN command frame from a factory new target, it shall be ignored.
   1366              if ( ( pReq->touchLinkFactoryNew == TRUE ) && ( bdbAttributes.bdbNodeIsOnANetwork == TRUE ) &&
   1367                   osal_get_timeoutEx( touchLinkInitiator_TaskID, TOUCHLINK_TL_SCAN_BASE_EVT ) )
   1368              {
   1369                return ( ZSuccess );
   1370              }
   1371          
   1372              // Send a Scan Response back
   1373              if ( touchLink_InitiatorSendScanRsp( TOUCHLINK_INTERNAL_ENDPOINT, &dstAddr, pReq->transID, seqNum ) == ZSuccess )
   1374              {
   1375                // If we're a factory new initiator and are in the middle of a Device
   1376                // Discovery, stop the procedure and wait for subsequent configuration
   1377                // information from the non-factory new initiator that we just responded to.
   1378                if ( ( bdbAttributes.bdbNodeIsOnANetwork == FALSE ) && !pReq->touchLinkFactoryNew )
   1379                {
   1380                  osal_stop_timerEx( touchLinkInitiator_TaskID, TOUCHLINK_TL_SCAN_BASE_EVT );
   1381                }
   1382              }
   1383            }
   1384          
   1385            return ( ZSuccess );
   1386          }
   1387          
   1388          /*********************************************************************
   1389           * @fn      initiatorDeviceInfoReqCB
   1390           *
   1391           * @brief   This callback is called to process a Device Information
   1392           *          Request command.
   1393           *
   1394           * @param   srcAddr - sender's address
   1395           * @param   pReq - parsed command
   1396           * @param   seqNum - command sequence number
   1397           *
   1398           * @return  ZStatus_t
   1399           */
   1400          static ZStatus_t initiatorDeviceInfoReqCB( afAddrType_t *srcAddr, bdbTLDeviceInfoReq_t *pReq, uint8 seqNum )
   1401          {
   1402            if ( touchLink_IsValidTransID( pReq->transID ) == FALSE )
   1403            {
   1404              return ( ZFailure );
   1405            }
   1406            return ( touchLink_SendDeviceInfoRsp( TOUCHLINK_INTERNAL_ENDPOINT, srcAddr,
   1407                                            pReq->startIndex, pReq->transID, seqNum ) );
   1408          }
   1409          
   1410          /*********************************************************************
   1411           * @fn      initiatorIdentifyReqCB
   1412           *
   1413           * @brief   This callback is called to process an Identify Request command.
   1414           *
   1415           * @param   srcAddr - sender's address
   1416           * @param   pReq - parsed command
   1417           *
   1418           * @return  ZStatus_t
   1419           */
   1420          static ZStatus_t initiatorIdentifyReqCB( afAddrType_t *srcAddr, bdbTLIdentifyReq_t *pReq )
   1421          {
   1422            if ( touchLink_IsValidTransID( pReq->transID ) == FALSE )
   1423            {
   1424              return ( ZFailure );
   1425            }
   1426          
   1427            uint16 identifyTime;
   1428            endPointDesc_t * bdb_CurrEpDescriptor;
   1429            
   1430            // Values of the Identify Duration field:
   1431            // - Exit identify mode: 0x0000
   1432            // - Length of time to remain in identify mode: 0x0001-0xfffe
   1433            // - Remain in identify mode for a default time known by the receiver: 0xffff
   1434            if ( pReq->IdDuration == 0xffff )
   1435            {
   1436              identifyTime = TOUCHLINK_DEFAULT_IDENTIFY_TIME;
   1437            }
   1438            else
   1439            {
   1440              identifyTime = pReq->IdDuration;
   1441            }
   1442          
   1443            bdb_CurrEpDescriptor = bdb_setEpDescListToActiveEndpoint( );
   1444            
   1445            bdb_ZclIdentifyCmdInd( identifyTime, bdb_CurrEpDescriptor->endPoint );
   1446          
   1447            return ( ZSuccess );
   1448          }
   1449          
   1450          /*********************************************************************
   1451           * @fn      initiatorNwkJoinReqCB
   1452           *
   1453           * @brief   This callback is called to process Network Join
   1454           *          Request and Network Join End Device Request commands.
   1455           *
   1456           * @param   srcAddr - sender's address
   1457           * @param   pReq - parsed command
   1458           * @param   seqNum - command sequence number
   1459           *
   1460           * @return  ZStatus_t
   1461           */
   1462          static ZStatus_t initiatorNwkJoinReqCB( afAddrType_t *srcAddr, bdbTLNwkJoinReq_t *pReq, uint8 seqNum )
   1463          {
   1464            bdbTLNwkJoinRsp_t rsp;
   1465            afAddrType_t dstAddr;
   1466            nwk_states_t nwkState;
   1467          
   1468            if ( touchLink_IsValidTransID( pReq->transID ) == FALSE )
   1469            {
   1470              return ( ZFailure );
   1471            }
   1472          
   1473            rsp.transID = pReq->transID;
   1474          
   1475            if ( nwk_ExtPANIDValid( pReq->nwkParams.extendedPANID ) )
   1476              //NOTE: additional nwk params verification may be added here, e.g. ranges.
   1477            {
   1478          #if ( ZSTACK_ROUTER_BUILD )
   1479              nwkState = NWK_ROUTER;
   1480          #else
   1481              // Save the request for later
   1482              joinReq = *pReq;
   1483              nwkState = NWK_ENDDEVICE;
   1484          #endif
   1485          
   1486              // Notify our task to join the new network
   1487              osal_start_timerEx( touchLinkInitiator_TaskID, TOUCHLINK_NWK_JOIN_IND_EVT, BDBCTL_MIN_STARTUP_DELAY_TIME );
   1488          
   1489              osal_stop_timerEx( touchLinkInitiator_TaskID, TOUCHLINK_DISABLE_RX_EVT );
   1490              osal_stop_timerEx( touchLinkInitiator_TaskID, TOUCHLINK_CFG_TARGET_EVT );
   1491          
   1492              rsp.status = TOUCHLINK_NETWORK_JOIN_RSP_STATUS_SUCCESS;
   1493              
   1494              bdb_setNodeIsOnANetwork(TRUE);
   1495              
   1496              // Apply the received network key
   1497              touchLink_DecryptNwkKey( pReq->nwkParams.nwkKey, pReq->nwkParams.keyIndex, pReq->transID, touchLinkResponseID );
   1498          
   1499              // This is not a usual Trust Center protected network
   1500              ZDSecMgrUpdateTCAddress( NULL );
   1501              
   1502              // Configure MAC with our network parameters
   1503              NLME_InitNV();
   1504              touchLink_SetNIB( nwkState, pReq->nwkParams.nwkAddr, pReq->nwkParams.extendedPANID,
   1505                           _NIB.nwkLogicalChannel, pReq->nwkParams.panId, pReq->nwkParams.panId );
   1506              
   1507              touchLink_SetChannel( _NIB.nwkLogicalChannel );
   1508              touchLink_SetMacNwkParams( _NIB.nwkDevAddress, _NIB.nwkPanId, _NIB.nwkLogicalChannel );
   1509            }
   1510            else
   1511            {
   1512              rsp.status = TOUCHLINK_NETWORK_JOIN_RSP_STATUS_FAILURE;
   1513            }
   1514          
   1515            dstAddr = *srcAddr;
   1516            dstAddr.panId = 0xFFFF;
   1517          
   1518            // Send a response back
   1519          #if ( ZSTACK_ROUTER_BUILD )
   1520            bdbTL_Send_NwkJoinRtrRsp( TOUCHLINK_INTERNAL_ENDPOINT, &dstAddr, &rsp, seqNum );
   1521          #else
   1522            bdbTL_Send_NwkJoinEDRsp( TOUCHLINK_INTERNAL_ENDPOINT, &dstAddr, &rsp, seqNum );
   1523          #endif
   1524          
   1525            return ( ZSuccess );
   1526          }
   1527          
   1528          /*********************************************************************
   1529           * @fn      initiatorNwkUpdateReqCB
   1530           *
   1531           * @brief   This callback is called to process a Network Update Request
   1532           *          command.
   1533           *
   1534           * @param   srcAddr - sender's address
   1535           * @param   pReq - parsed command
   1536           *
   1537           * @return  ZStatus_t
   1538           */
   1539          static ZStatus_t initiatorNwkUpdateReqCB( afAddrType_t *srcAddr, bdbTLNwkUpdateReq_t *pReq )
   1540          {
   1541            if ( touchLink_IsValidTransID( pReq->transID ) == FALSE )
   1542            {
   1543              return ( ZFailure );
   1544            }
   1545            // Discard the request if the Extended PAN ID and PAN ID are not
   1546            // identical with our corresponding stored values
   1547            if ( TOUCHLINK_SAME_NWK( pReq->PANID, pReq->extendedPANID ) )
   1548            {
   1549              uint8 newUpdateId = touchLink_NewNwkUpdateId( pReq->nwkUpdateId, _NIB.nwkUpdateId);
   1550              if ( _NIB.nwkUpdateId != newUpdateId )
   1551              {
   1552                // Update the network update id and logical channel
   1553                touchLink_ProcessNwkUpdate( pReq->nwkUpdateId, pReq->logicalChannel );
   1554              }
   1555            }
   1556          
   1557            return ( ZSuccess );
   1558          }
   1559          
   1560          /*********************************************************************
   1561           * @fn      initiatorScanRspCB
   1562           *
   1563           * @brief   This callback is called to process a Scan Response command.
   1564           *
   1565           * @param   srcAddr - sender's address
   1566           * @param   pRsp - parsed command
   1567           *
   1568           * @return  ZStatus_t
   1569           */
   1570          static ZStatus_t initiatorScanRspCB( afAddrType_t *srcAddr, bdbTLScanRsp_t *pRsp )
   1571          {
   1572            bdbFindingBindingRespondent_t *pCurr;
   1573            
   1574            if ( osal_get_timeoutEx( touchLinkInitiator_TaskID, TOUCHLINK_TL_SCAN_BASE_EVT )
   1575                 && ( touchLink_IsValidTransID( pRsp->transID ) )
   1576                 && ( pRsp->keyBitmask & touchLink_GetNwkKeyBitmask() ) )
   1577            {
   1578          
   1579              uint8 selectThisTarget = FALSE;
   1580              int8 rssi = touchLink_GetMsgRssi();
   1581              if ( pfnSelectDiscDevCB != NULL )
   1582              {
   1583                selectThisTarget = pfnSelectDiscDevCB( pRsp, rssi );
   1584              }
   1585              // Default selection - according to RSSI
   1586              else if ( rssi > TOUCHLINK_WORST_RSSI )
   1587              {
   1588                if ( ( rssi + pRsp->rssiCorrection ) > selectedTarget.lastRssi )
   1589                {
   1590                  // Better RSSI, select this target
   1591                  selectThisTarget = TRUE;
   1592                }
   1593              }
   1594          
   1595              if ( selectThisTarget )
   1596              {
   1597                selectedTarget.scanRsp = *pRsp;
   1598                selectedTarget.lastRssi = rssi;
   1599                selectedTarget.srcAddr = *srcAddr;
   1600                selectedTarget.srcAddr.panId = 0xFFFF;
   1601                touchLinkResponseID = pRsp->responseID;
   1602                touchLinkTransID = pRsp->transID;
   1603          
   1604                // Remember channel we heard back this scan response on
   1605                ZMacGetReq( ZMacChannel, &(selectedTarget.rxChannel));
   1606          
   1607                if ( pRsp->numSubDevices > 1 )
   1608                {
   1609                  selectedTarget.scanRsp.deviceInfo.endpoint = DEV_INFO_INVALID_EP;
   1610          
   1611                  bdbTLDeviceInfoReq_t devInfoReq;
   1612                  devInfoReq.transID = pRsp->transID;
   1613                  devInfoReq.startIndex = 0;
   1614          
   1615                  return bdbTL_Send_DeviceInfoReq( TOUCHLINK_INTERNAL_ENDPOINT, srcAddr,
   1616                                              &devInfoReq, initiatorSeqNum++ );
   1617                }
   1618                  
   1619                // add new node to the list
   1620                pCurr = bdb_AddRespondentNode( &pRespondentHead, NULL );
   1621                
   1622                if ( pCurr != NULL )
   1623                {
   1624                  pCurr->data.endPoint = pRsp->deviceInfo.endpoint;
   1625                  pCurr->data.panId = srcAddr->panId;
   1626                }
   1627              }
   1628              return ( ZSuccess );
   1629            }
   1630          
   1631            return ( ZFailure );
   1632          }
   1633          
   1634          /*********************************************************************
   1635           * @fn      initiatorDeviceInfoRspCB
   1636           *
   1637           * @brief   This callback is called to process a Device Information
   1638           *          Response command.
   1639           *          If sub-device is selected, selectedTarget data is updated.
   1640           *
   1641           * @param   srcAddr - sender's address
   1642           * @param   pRsp - parsed command
   1643           *
   1644           * @return  ZStatus_t
   1645           */
   1646          static ZStatus_t initiatorDeviceInfoRspCB( afAddrType_t *srcAddr, bdbTLDeviceInfoRsp_t *pRsp )
   1647          {
   1648            bdbFindingBindingRespondent_t *pCurr;
   1649            
   1650            if ( touchLink_IsValidTransID( pRsp->transID )
   1651                 && ( srcAddr->addr.shortAddr == selectedTarget.srcAddr.addr.shortAddr ) )
   1652            {
   1653              uint8 i;
   1654              uint8 selectedIdx = pRsp->cnt;
   1655              bdbTLScanRsp_t tmpInfo = selectedTarget.scanRsp;
   1656          
   1657              for ( i = 0; i < pRsp->cnt; ++i )
   1658              {
   1659                if ( pfnSelectDiscDevCB != NULL )
   1660                {
   1661                  tmpInfo.deviceInfo = pRsp->devInfoRec[i].deviceInfo;
   1662                  if ( pfnSelectDiscDevCB( &tmpInfo, selectedTarget.lastRssi ) )
   1663                  {
   1664                    selectedIdx = i;
   1665                    // no break here to allow cycling through all sub-devices
   1666                  }
   1667                }
   1668                else
   1669                {
   1670                  if ( ( pRsp->devInfoRec[i].deviceInfo.profileID == TOUCHLINK_PROFILE_ID ) ||
   1671                       ( pRsp->devInfoRec[i].deviceInfo.profileID == Z3_PROFILE_ID ) )
   1672                  {
   1673                    selectedIdx = i;
   1674                    break; // first match
   1675                  }
   1676                }
   1677              }
   1678              if ( selectedIdx < pRsp->cnt )
   1679              {
   1680                // NOTE - the original scan response device info is overwritten with the
   1681                // selected sub-device info, to complete the data required for the application.
   1682                selectedTarget.scanRsp.deviceInfo = pRsp->devInfoRec[selectedIdx].deviceInfo;
   1683                
   1684                for ( i = 0; i < pRsp->cnt; ++i )
   1685                {
   1686                  if ( ( pRsp->devInfoRec[i].deviceInfo.profileID == TOUCHLINK_PROFILE_ID ) ||
   1687                       ( pRsp->devInfoRec[i].deviceInfo.profileID == Z3_PROFILE_ID ) )
   1688                  {
   1689                    // add new node to the list
   1690                    pCurr = bdb_AddRespondentNode( &pRespondentHead, NULL );
   1691                    
   1692                    if ( pCurr != NULL )
   1693                    {
   1694                      osal_memset(pCurr, 0x00, sizeof(bdbFindingBindingRespondent_t));
   1695                      pCurr->data.endPoint = pRsp->devInfoRec[i].deviceInfo.endpoint;
   1696                      pCurr->data.panId = srcAddr->panId;
   1697                      osal_cpyExtAddr(selectedTargetIEEEAddr, pRsp->devInfoRec[i].ieeeAddr);
   1698                    }
   1699                  }
   1700                }
   1701              }
   1702              else
   1703              {
   1704                // no sub-device of the currently selected device was selected.
   1705                // clear selection
   1706                initiatorClearSelectedTarget();
   1707                bdb_zclRespondentListClean( &pRespondentHead );
   1708              }
   1709              return ( ZSuccess );
   1710            }
   1711            return ( ZFailure );
   1712          }
   1713          
   1714          /*********************************************************************
   1715           * @fn      initiatorNwkStartRspCB
   1716           *
   1717           * @brief   This callback is called to process a Network Start Response command.
   1718           *
   1719           * @param   srcAddr - sender's address
   1720           * @param   pRsp - parsed command
   1721           *
   1722           * @return  ZStatus_t
   1723           */
   1724          static ZStatus_t initiatorNwkStartRspCB( afAddrType_t *srcAddr, bdbTLNwkStartRsp_t *pRsp )
   1725          {
   1726            if ( touchLink_IsValidTransID( pRsp->transID ) == FALSE )
   1727            {
   1728              return ( ZFailure );
   1729            }
   1730            // Make sure we didn't timeout waiting for this response
   1731            if ( osal_get_timeoutEx( touchLinkInitiator_TaskID, TOUCHLINK_W4_NWK_START_RSP_EVT ) )
   1732            {
   1733              // Save the Network Start Response for later
   1734              rxRsp.nwkStartRsp = *pRsp;
   1735          
   1736              // No need to wait longer
   1737              osal_set_event( touchLinkInitiator_TaskID, TOUCHLINK_W4_NWK_START_RSP_EVT );  
   1738            }
   1739          
   1740            return ( ZSuccess );
   1741          }
   1742          
   1743          /*********************************************************************
   1744           * @fn      initiatorNwkJoinRtrRspCB
   1745           *
   1746           * @brief   This callback is called to process a Network Join Router
   1747           *          Response command.
   1748           *
   1749           * @param   srcAddr - sender's address
   1750           * @param   pRsp - parsed command
   1751           *
   1752           * @return  ZStatus_t
   1753           */
   1754          static ZStatus_t initiatorNwkJoinRtrRspCB( afAddrType_t *srcAddr, bdbTLNwkJoinRsp_t *pRsp )
   1755          {
   1756            if ( ( touchLink_IsValidTransID( pRsp->transID ) == FALSE ) || 
   1757               ( ( srcAddr->addrMode != afAddr64Bit ) || ( !osal_memcmp( selectedTarget.srcAddr.addr.extAddr, srcAddr->addr.extAddr, Z_EXTADDR_LEN ) ) ) )
   1758            {
   1759              return ( ZFailure );
   1760            }
   1761            
   1762            // Make sure we didn't timeout waiting for this response
   1763            if ( osal_get_timeoutEx( touchLinkInitiator_TaskID, TOUCHLINK_W4_NWK_JOIN_RSP_EVT ) )
   1764            {
   1765              // Save the Network Start Response for later
   1766              rxRsp.nwkJoinRsp = *pRsp;
   1767          
   1768              // No need to wait longer
   1769              osal_set_event( touchLinkInitiator_TaskID, TOUCHLINK_W4_NWK_JOIN_RSP_EVT );
   1770            }
   1771          
   1772            return ( ZSuccess );
   1773          }
   1774          
   1775          /*********************************************************************
   1776           * @fn      initiatorNwkJoinEDRspCB
   1777           *
   1778           * @brief   This callback is called to process a Network Join End Device
   1779           *          Response command.
   1780           *
   1781           * @param   srcAddr - sender's address
   1782           * @param   pRsp - parsed command
   1783           *
   1784           * @return  ZStatus_t
   1785           */
   1786          static ZStatus_t initiatorNwkJoinEDRspCB( afAddrType_t *srcAddr, bdbTLNwkJoinRsp_t *pRsp )
   1787          {
   1788            if ( ( touchLink_IsValidTransID( pRsp->transID ) == FALSE ) || 
   1789               ( ( srcAddr->addrMode != afAddr64Bit ) || ( !osal_memcmp( selectedTarget.srcAddr.addr.extAddr, srcAddr->addr.extAddr, Z_EXTADDR_LEN ) ) ) )
   1790            {
   1791              return ( ZFailure );
   1792            }
   1793            
   1794            // Make sure we didn't timeout waiting for this response
   1795            if ( osal_get_timeoutEx( touchLinkInitiator_TaskID, TOUCHLINK_W4_NWK_JOIN_RSP_EVT ) )
   1796            {
   1797              // Save the Network Start Response for later
   1798              rxRsp.nwkJoinRsp = *pRsp;
   1799          
   1800              // No need to wait longer
   1801              osal_set_event( touchLinkInitiator_TaskID, TOUCHLINK_W4_NWK_JOIN_RSP_EVT );
   1802          
   1803            }
   1804            else
   1805            {
   1806              rxRsp.nwkJoinRsp.status = TOUCHLINK_NETWORK_JOIN_RSP_STATUS_FAILURE;
   1807            }
   1808          
   1809            return ( ZSuccess );
   1810          }
   1811          
   1812          /******************************************************************************
   1813           * @fn      initiatorZdoLeaveCnfCB
   1814           *
   1815           * @brief   This callback is called to process a Leave Confirmation message.
   1816           *
   1817           *          Note: this callback function returns a pointer if it has handled
   1818           *                the confirmation message and no further action should be
   1819           *                taken with it. It returns NULL if it has not handled the
   1820           *                confirmation message and normal processing should take place.
   1821           *
   1822           * @param   pParam - received message
   1823           *
   1824           * @return  Pointer if message processed. NULL, otherwise.
   1825           */
   1826          static void *initiatorZdoLeaveCnfCB( void *pParam )
   1827          {
   1828            (void)pParam;
   1829          
   1830            // Did we initiate the leave?
   1831            if ( touchLinkLeaveInitiated == FALSE )
   1832            {
   1833              return ( NULL );
   1834            }
   1835          
   1836            if ( touchLinkLeaveInitiated == TOUCHLINK_LEAVE_TO_JOIN_NWK )
   1837            {
   1838              // Notify our task to join the new network
   1839              osal_set_event( touchLinkInitiator_TaskID, TOUCHLINK_JOIN_NWK_ATTEMPT_EVT );
   1840            }
   1841          
   1842            return ( (void *)&touchLinkLeaveInitiated );
   1843          }
   1844          
   1845          /*********************************************************************
   1846           * @fn      initiatorProcessStateChange
   1847           *
   1848           * @brief   Process ZDO device state change
   1849           *
   1850           * @param   state - The device's network state
   1851           *
   1852           * @return  none
   1853           */
   1854          static void initiatorProcessStateChange( devStates_t state )
   1855          {
   1856            if ( ( ( devState == DEV_ROUTER ) || ( devState == DEV_END_DEVICE ) ) && ( touchlinkDistNwk == TRUE ) )
   1857            {
   1858              // Set touchlink flag to false after joining is complete
   1859              touchlinkDistNwk = FALSE;
   1860              
   1861              // Save the latest NIB to update our parent's address
   1862              touchLink_UpdateNV( TOUCHLINK_UPDATE_NV_NIB );
   1863             
   1864              if ( !_NIB.CapabilityFlags )
   1865              {
   1866                _NIB.CapabilityFlags = ZDO_Config_Node_Descriptor.CapabilityFlags;
   1867              }
   1868          
   1869          #if (ZSTACK_ROUTER_BUILD)
   1870                linkInfo_t *linkInfo;
   1871                
   1872                // check if entry exists
   1873                linkInfo = nwkNeighborGetLinkInfo( selectedTargetNwkAddr, _NIB.nwkPanId );
   1874          
   1875                // if not, look for a vacant entry to add this node...
   1876                if ( linkInfo == NULL )
   1877                {
   1878                  nwkNeighborAdd( selectedTargetNwkAddr, _NIB.nwkPanId, DEF_LQI );
   1879                  linkInfo = nwkNeighborGetLinkInfo( selectedTargetNwkAddr, _NIB.nwkPanId );
   1880                  linkInfo->txCost = DEF_LINK_COST;
   1881                  linkInfo->rxLqi = MIN_LQI_COST_1; 
   1882                }
   1883                
   1884                bdb_setNodeIsOnANetwork(TRUE);
   1885                osal_start_timerEx( touchLinkInitiator_TaskID, TOUCHLINK_NWK_FORMATION_SUCCESS_EVT, 500);
   1886          #endif
   1887          
   1888              // We found our parent
   1889              osal_stop_timerEx( touchLinkInitiator_TaskID, TOUCHLINK_W4_REJOIN_EVT );
   1890            }
   1891            
   1892            else if ( ( state == DEV_NWK_ORPHAN ) || ( state == DEV_NWK_DISC ) )
   1893            {
   1894              // Device has lost information about its parent; give it some time to rejoin
   1895              if ( !osal_get_timeoutEx( touchLinkInitiator_TaskID, TOUCHLINK_W4_REJOIN_EVT ) )
   1896              {
   1897                osal_start_timerEx( touchLinkInitiator_TaskID, TOUCHLINK_W4_REJOIN_EVT,
   1898                                    (NUM_DISC_ATTEMPTS + 1) * TOUCHLINK_INITIATOR_REJOIN_TIMEOUT );
   1899              }
   1900            }
   1901          }
   1902          
   1903          /*********************************************************************
   1904           * @fn      initiatorSetNwkToInitState
   1905           *
   1906           * @brief   Set our network state to its original state.
   1907           *
   1908           * @param   void
   1909           *
   1910           * @return  void
   1911           */
   1912          static void initiatorSetNwkToInitState()
   1913          {
   1914            // Turn MAC receiver back to its old state
   1915            ZMacSetReq( ZMacRxOnIdle, &savedRxOnIdle );
   1916          
   1917            // Tune back to our channel
   1918            touchLink_SetChannel( _NIB.nwkLogicalChannel );
   1919          
   1920            // Set NWK task to run
   1921            nwk_setStateIdle( FALSE );
   1922          
   1923            if ( savedPollRate != zgPollRate )
   1924            {
   1925              NLME_SetPollRate( savedPollRate );
   1926              savedPollRate = POLL_RATE;
   1927            }
   1928          
   1929            if ( savedQueuedPollRate != zgQueuedPollRate )
   1930            {
   1931              NLME_SetQueuedPollRate( savedQueuedPollRate );
   1932              savedQueuedPollRate = QUEUED_POLL_RATE;
   1933            }
   1934          
   1935            if ( savedResponsePollRate != zgResponsePollRate )
   1936            {
   1937              NLME_SetResponseRate( savedResponsePollRate );
   1938              savedResponsePollRate = RESPONSE_POLL_RATE;
   1939            }
   1940          }
   1941          
   1942          #if ( ZSTACK_ROUTER_BUILD )
   1943          /*********************************************************************
   1944           * @fn      initiatorJoinNwk
   1945           *
   1946           * @brief   Initiate a network join request.
   1947           *
   1948           * @param   void
   1949           *
   1950           * @return  void
   1951           */
   1952          static void initiatorJoinNwk( void )
   1953          {
   1954            // Save free ranges
   1955            touchLink_UpdateNV( TOUCHLINK_UPDATE_NV_RANGES );
   1956          
   1957            // In case we're here after a leave
   1958            touchLinkLeaveInitiated = FALSE;
   1959          
   1960            // Clear leave control logic
   1961            ZDApp_LeaveCtrlReset();
   1962          
   1963            if ( POLL_RATE == 0 )
   1964            {
   1965              //allow to respond to TOUCHLINK commission utility commands after TL
   1966              NLME_SetPollRate( TOUCHLINK_INITIATOR_TEMP_POST_TL_POLL_RATE );
   1967              //polling should reset when TL life time expires
   1968            }
   1969          
   1970            touchLinkInitiator_PermitJoin( 0 );
   1971          
   1972            ZDOInitDevice( 0 );
   1973            // Perform a network rejoin request
   1974            _NIB.nwkState = NWK_REJOINING;
   1975            initiatorReJoinNwk( MODE_REJOIN );
   1976          }
   1977          #endif
   1978          
   1979          /*********************************************************************
   1980           * @fn      initiatorReJoinNwk
   1981           *
   1982           * @brief   Send out an Rejoin Request.
   1983           *
   1984           * @param   startMode - MODE_REJOIN or MODE_RESUME
   1985           *
   1986           * @return  none
   1987           */
   1988          static void initiatorReJoinNwk( devStartModes_t startMode )
   1989          {
   1990            // Set NWK task to run
   1991            nwk_setStateIdle( FALSE );
   1992          
   1993            // Configure MAC with our network parameters
   1994            touchLink_SetMacNwkParams( _NIB.nwkDevAddress, _NIB.nwkPanId, _NIB.nwkLogicalChannel );
   1995          
   1996            // Use the new network paramters
   1997            zgConfigPANID = _NIB.nwkPanId;
   1998            zgDefaultChannelList = _NIB.channelList;
   1999            osal_cpyExtAddr( ZDO_UseExtendedPANID, _NIB.extendedPANID );
   2000          
   2001            devStartMode = startMode;
   2002          
   2003            _tmpRejoinState = TRUE;
   2004          
   2005            // Start the network joining process
   2006            osal_set_event( ZDAppTaskID, ZDO_NETWORK_INIT );
   2007          }
   2008          
   2009          /*********************************************************************
   2010           * @fn      initiatorSendScanReq
   2011           *
   2012           * @brief   Send out an Scan Request command on one of the TOUCHLINK channels.
   2013           *
   2014           * @param   freshScan - TRUE to start fresh scan, FALSE to resume existing process.
   2015           *
   2016           * @return  void
   2017           */
   2018          static void initiatorSendScanReq( bool freshScan )
   2019          {
   2020            bdbTLScanReq_t req;
   2021            uint8 newChannel;
   2022            uint8 secondaryChList[] = TOUCHLINK_SECONDARY_CHANNELS_SET;
   2023            static uint8 channelIndex = 0;
   2024            
   2025            // Set the device as initiator of touchlink commissioning
   2026            touchLink_DeviceIsInitiator( TRUE );
   2027          
   2028            if ( freshScan )
   2029            {
   2030              channelIndex = 0;
   2031            }
   2032          
   2033            // First figure out the channel
   2034            if ( scanReqChannels == TOUCHLINK_SCAN_PRIMARY_CHANNELS )
   2035            {
   2036              if ( numScanReqSent < 5 )
   2037              {
   2038                // First five consecutive requests are sent on channel 11
   2039                newChannel = TOUCHLINK_FIRST_CHANNEL;
   2040              }
   2041              else if ( numScanReqSent == 5 )
   2042              {
   2043                // Sixth request is sent on channel 15
   2044                newChannel = TOUCHLINK_SECOND_CHANNEL;
   2045              }
   2046              else if ( numScanReqSent == 6 )
   2047              {
   2048                // Seventh request is sent on channel 20
   2049                newChannel = TOUCHLINK_THIRD_CHANNEL;
   2050              }
   2051              else
   2052              {
   2053                // Last request is sent on channel 25
   2054                newChannel = TOUCHLINK_FOURTH_CHANNEL;
   2055              }
   2056            }
   2057            else
   2058            {
   2059              // scan secondary channel list
   2060              if ( channelIndex < sizeof(secondaryChList) )
   2061              {
   2062                 newChannel = secondaryChList[channelIndex++];
   2063              }
   2064              else
   2065              {
   2066                // set it to initial value for next discovery process
   2067                channelIndex = 0;
   2068                return;
   2069              }
   2070            }
   2071          
   2072            if ( touchLinkTransID != 0 )
   2073            {
   2074              // Build the request
   2075              req.transID = touchLinkTransID;
   2076              touchLinkLastAcceptedTransID = touchLinkTransID;
   2077          
   2078              req.zInfo.zInfoByte = 0;
   2079              req.zLogicalType = zgDeviceLogicalType;
   2080              if ( ZDO_Config_Node_Descriptor.CapabilityFlags & CAPINFO_RCVR_ON_IDLE )
   2081              {
   2082                req.zRxOnWhenIdle = TRUE;
   2083              }
   2084          
   2085              req.touchLinkInfo.touchLinkInfoByte = 0;
   2086              req.touchLinkFactoryNew = !bdbAttributes.bdbNodeIsOnANetwork;
   2087              req.touchLinkAddressAssignment = TRUE;
   2088              req.touchLinkInitiator = TRUE;
   2089          
   2090              // First switch to the right channel
   2091              touchLink_SetChannel( newChannel );
   2092          
   2093              // Broadcast the request
   2094              bdbTL_Send_ScanReq( TOUCHLINK_INTERNAL_ENDPOINT, &bcastAddr, &req, initiatorSeqNum++ );
   2095          
   2096              numScanReqSent++;
   2097          
   2098              // After each transmission, wait BDBCTL_SCAN_TIME_BASE_DURATION seconds
   2099              // to receive any responses.
   2100              osal_start_timerEx( touchLinkInitiator_TaskID, TOUCHLINK_TL_SCAN_BASE_EVT, BDBCTL_SCAN_TIME_BASE_DURATION );
   2101            }
   2102            else
   2103            {
   2104              touchLinkInitiator_AbortTL();
   2105            }
   2106          }
   2107          
   2108          /*********************************************************************
   2109           * @fn      initiatorSendNwkStartReq
   2110           *
   2111           * @brief   Send out a Network Start Request command.
   2112           *
   2113           * @param   pRsp - received Scan Response
   2114           *
   2115           * @return  ZStatus_t
   2116           */
   2117          static ZStatus_t initiatorSendNwkStartReq( bdbTLScanRsp_t *pRsp )
   2118          {
   2119            bdbTLNwkStartReq_t *pReq;
   2120            ZStatus_t status;
   2121          
   2122            pReq = (bdbTLNwkStartReq_t *)osal_mem_alloc( sizeof( bdbTLNwkStartReq_t ) );
   2123            if ( pReq != NULL )
   2124            {
   2125              uint16 i;
   2126              bdbTLNwkParams_t *pParams = &(pReq->nwkParams);
   2127          
   2128              osal_memset( pReq, 0, sizeof( bdbTLNwkStartReq_t ) );
   2129          
   2130              // Build the request
   2131              pReq->transID = selectedTarget.scanRsp.transID;
   2132          
   2133              // Find out key index (prefer highest)
   2134              for ( i = 15; i > 0; i-- )
   2135              {
   2136                if ( ( (uint16)1 << i ) & pRsp->keyBitmask )
   2137                {
   2138                  break;
   2139                }
   2140              }
   2141              pParams->keyIndex = i;
   2142          
   2143              // Copy in the encrypted network key
   2144              touchLink_EncryptNwkKey( pParams->nwkKey, i, pRsp->transID, pRsp->responseID );
   2145          
   2146              pParams->nwkAddr = touchLink_PopNwkAddress();
   2147              if ( pParams->nwkAddr == 0 )
   2148              {
   2149                pParams->nwkAddr = osal_rand();
   2150              }
   2151              // update address for app notification
   2152              selectedTarget.newNwkAddr = pParams->nwkAddr;
   2153              selectedTargetNwkAddr = pParams->nwkAddr;
   2154          
   2155              // Set group ID range
   2156              if ( pRsp->totalGrpIDs > 0 )
   2157              {
   2158                touchLink_PopGrpIDRange( pRsp->totalGrpIDs, &(pParams->grpIDsBegin), &(pParams->grpIDsEnd) );
   2159              }
   2160          
   2161              if ( pRsp->touchLinkAddressAssignment )
   2162              {
   2163                touchLink_SplitFreeRanges( &(pParams->freeNwkAddrBegin), &(pParams->freeNwkAddrEnd),
   2164                                     &(pParams->freeGrpIDBegin), &(pParams->freeGrpIDEnd) );
   2165              }
   2166          
   2167          #ifdef TOUCHLINK_INITIATOR_SET_NEW_NWK_PARAMS
   2168              pParams->logicalChannel = _NIB.nwkLogicalChannel;
   2169              pParams->panId = _NIB.nwkPanId;
   2170              osal_memcpy( pParams->extendedPANID, _NIB.extendedPANID ,Z_EXTADDR_LEN);
   2171          #endif
   2172          
   2173              osal_cpyExtAddr( pReq->initiatorIeeeAddr, NLME_GetExtAddr() );
   2174              pReq->initiatorNwkAddr = _NIB.nwkDevAddress;
   2175          
   2176              status = bdbTL_Send_NwkStartReq( TOUCHLINK_INTERNAL_ENDPOINT, &(selectedTarget.srcAddr), pReq, initiatorSeqNum++ );
   2177              if ( status == ZSuccess )
   2178              {
   2179                // Keep a copy of the encryted network key sent to the target
   2180                keyIndexSent = i;
   2181                osal_memcpy( encKeySent, pParams->nwkKey, SEC_KEY_LEN );
   2182                responseIDSent = pRsp->responseID;
   2183          
   2184                // After the transmission, wait BDBCTL_RX_WINDOW_DURATION seconds to
   2185                // receive a response.
   2186                osal_start_timerEx( touchLinkInitiator_TaskID, TOUCHLINK_W4_NWK_START_RSP_EVT, BDBCTL_RX_WINDOW_DURATION );
   2187              }
   2188          
   2189              osal_mem_free( pReq );
   2190            }
   2191            else
   2192            {
   2193              status = ZMemError;
   2194            }
   2195          
   2196            return ( status );
   2197          }
   2198          
   2199          /*********************************************************************
   2200           * @fn      initiatorSendNwkJoinReq
   2201           *
   2202           * @brief   Send out a Network Join Router or End Device Request command.
   2203           *
   2204           * @param   pRsp - received Scan Response
   2205           *
   2206           * @return  ZStatus_t
   2207           */
   2208          static ZStatus_t initiatorSendNwkJoinReq( bdbTLScanRsp_t *pRsp )
   2209          {
   2210            bdbTLNwkJoinReq_t *pReq;
   2211            ZStatus_t status;
   2212            bdbFindingBindingRespondent_t *pCurr;
   2213          
   2214            pReq = (bdbTLNwkJoinReq_t *)osal_mem_alloc( sizeof( bdbTLNwkJoinReq_t ) );
   2215            if ( pReq != NULL )
   2216            {
   2217              uint16 i;
   2218              bdbTLNwkParams_t *pParams = &(pReq->nwkParams);
   2219          
   2220              osal_memset( pReq, 0, sizeof( bdbTLNwkJoinReq_t ) );
   2221          
   2222              // Build the request
   2223              pReq->transID = selectedTarget.scanRsp.transID;
   2224          
   2225              // Find out key index (prefer highest)
   2226              for ( i = 15; i > 0; i-- )
   2227              {
   2228                if ( ( (uint16)1 << i ) & pRsp->keyBitmask )
   2229                {
   2230                  break;
   2231                }
   2232              }
   2233              pParams->keyIndex = i;
   2234          
   2235              // Copy in the encrypted network key
   2236              touchLink_EncryptNwkKey( pParams->nwkKey, i, pRsp->transID, pRsp->responseID );
   2237          
   2238              pParams->nwkAddr = touchLink_PopNwkAddress();
   2239              if ( pParams->nwkAddr == 0 )
   2240              {
   2241                pParams->nwkAddr = osal_rand();
   2242              }
   2243              // update address for app notification
   2244              selectedTarget.newNwkAddr = pParams->nwkAddr;
   2245              selectedTargetNwkAddr = pParams->nwkAddr;
   2246              
   2247              // Set group ID range
   2248              if ( pRsp->totalGrpIDs > 0 )
   2249              {
   2250                touchLink_PopGrpIDRange( pRsp->totalGrpIDs, &(pParams->grpIDsBegin), &(pParams->grpIDsEnd) );
   2251              }
   2252          
   2253              if ( pRsp->touchLinkAddressAssignment )
   2254              {
   2255                touchLink_SplitFreeRanges( &(pParams->freeNwkAddrBegin), &(pParams->freeNwkAddrEnd),
   2256                                     &(pParams->freeGrpIDBegin), &(pParams->freeGrpIDEnd) );
   2257              }
   2258              // update 
   2259              pCurr = pRespondentHead;
   2260              while( pCurr != NULL )
   2261              {
   2262                pCurr->data.addr.shortAddr = pParams->nwkAddr;
   2263                pCurr->data.addrMode = afAddr16Bit;
   2264                pCurr->data.panId = _NIB.nwkPanId;
   2265                pCurr = pCurr->pNext;
   2266              }
   2267          
   2268              pParams->logicalChannel = _NIB.nwkLogicalChannel;
   2269              pParams->panId = _NIB.nwkPanId;
   2270              osal_cpyExtAddr( pParams->extendedPANID, _NIB.extendedPANID );
   2271              pReq->nwkUpdateId = _NIB.nwkUpdateId;
   2272          
   2273              // Let PAN ID, Extended PAN ID and Logical Channel to be determined by the target
   2274              if ( pRsp->zLogicalType == ZG_DEVICETYPE_ROUTER )
   2275              {
   2276                // It's a light
   2277                status = bdbTL_Send_NwkJoinRtrReq( TOUCHLINK_INTERNAL_ENDPOINT, &(selectedTarget.srcAddr), pReq, initiatorSeqNum++ );
   2278              }
   2279              else // another controller
   2280              {
   2281                status = bdbTL_Send_NwkJoinEDReq( TOUCHLINK_INTERNAL_ENDPOINT, &(selectedTarget.srcAddr), pReq, initiatorSeqNum++ );
   2282              }
   2283          
   2284              if ( status == ZSuccess )
   2285              {
   2286                // After the transmission, wait BDBCTL_RX_WINDOW_DURATION seconds to
   2287                // receive a response.
   2288                osal_start_timerEx( touchLinkInitiator_TaskID, TOUCHLINK_W4_NWK_JOIN_RSP_EVT, BDBCTL_RX_WINDOW_DURATION );
   2289              }
   2290          
   2291              osal_mem_free( pReq );
   2292            }
   2293            else
   2294            {
   2295              status = ZMemError;
   2296            }
   2297          
   2298            return ( status );
   2299          }
   2300          
   2301          /*********************************************************************
   2302           * @fn      initiatorSendNwkUpdateReq
   2303           *
   2304           * @brief   Send out a Network Update Request command.
   2305           *
   2306           * @param   pRsp - received Scan Response
   2307           *
   2308           * @return  ZStatus_t
   2309           */
   2310          static ZStatus_t initiatorSendNwkUpdateReq( bdbTLScanRsp_t *pRsp )
   2311          {
   2312            bdbTLNwkUpdateReq_t *pReq;
   2313            ZStatus_t status;
   2314          
   2315            pReq = (bdbTLNwkUpdateReq_t *)osal_mem_alloc( sizeof( bdbTLNwkUpdateReq_t ) );
   2316            if ( pReq!= NULL )
   2317            {
   2318              // Build the request
   2319              pReq->transID = pRsp->transID;
   2320              osal_cpyExtAddr( pReq->extendedPANID, _NIB.extendedPANID );
   2321              pReq->nwkUpdateId = _NIB.nwkUpdateId;
   2322              pReq->logicalChannel = _NIB.nwkLogicalChannel;
   2323              pReq->PANID = _NIB.nwkPanId;
   2324              pReq->nwkAddr = pRsp->nwkAddr;
   2325          
   2326              status = bdbTL_Send_NwkUpdateReq( TOUCHLINK_INTERNAL_ENDPOINT, &(selectedTarget.srcAddr), pReq, initiatorSeqNum++ );
   2327          
   2328              osal_mem_free( pReq );
   2329            }
   2330            else
   2331            {
   2332              status = ZMemError;
   2333            }
   2334          
   2335            return ( status );
   2336          }
   2337          
   2338          /*********************************************************************
   2339           * @fn      initiatorClearSelectedTarget
   2340           *
   2341           * @brief   clear selected target variable.
   2342           *
   2343           * @param   none
   2344           *
   2345           * @return  none
   2346           */
   2347          static void initiatorClearSelectedTarget( void )
   2348          {
   2349            osal_memset( &selectedTarget, 0x00, sizeof(targetCandidate_t) );
   2350            selectedTarget.lastRssi = TOUCHLINK_WORST_RSSI;
   2351          }
   2352          
   2353          #endif //BDB_TL_INITIATOR
   2354          
   2355          /*********************************************************************
   2356          *********************************************************************/


 

 


Errors: none
Warnings: none
